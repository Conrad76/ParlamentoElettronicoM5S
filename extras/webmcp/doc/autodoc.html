<html>
  <head>
    <style>
      body {
        font-family: "Liberation Sans", sans-serif;
        font-size: 11pt;
        padding-bottom: 5ex;
      }
      .warning {
        color: #ff0000;
      }
      h1, h2 {
        font-family: "Liberation Serif", Georgia, serif;
      }
      h2 {
        margin-bottom: 0.3ex;
      }
      p {
        margin: 0px;
        line-height: 130%;
      }
      tt, pre {
        font-size: 10pt;
      }
      tt {
        font-weight: bold;
        white-space: nowrap;
      }
      .autodoc_entry {
        margin-top: 1ex;
        margin-bottom: 1ex;
       }
      .autodoc_comment_tail {
        font-style: italic;
      }
      .autodoc_entry .short_synopsis {
        cursor: pointer;
      }
      .autodoc_details {
        padding-left: 1em;
        padding-right: 1em;
        border: 1px solid #777;
      }
      .autodoc_synopsis {
        font-weight: bold;
      }
      .autodoc_synopsis .autodoc_comment_tail {
        font-weight: normal;
        color: #008000;
      }
      .autodoc_entry .autodoc_comment {
        color: #400080;
      }
      .autodoc_source {
        color: #505050;
      }
    </style>
    <title>WebMCP 1.2.5 Documentation</title>
  </head>
  <body>
    <h1>WebMCP 1.2.5 Documentation</h1>
    <p>
      WebMCP is a completely new web development framework, and has not been extensively tested yet. The API might change at any time, but in future releases there will be a list of all changes, which break downward compatibility.
    </p>
    <h2>Requirements</h2>
    <p>
      WebMCP has been developed on Linux and FreeBSD. Using it with Mac&nbsp;OS&nbsp;X is completely untested; Microsoft Windows is not supported. Beside the operating system, the only mandatory dependencies for WebMCP are the programming language <a href="http://www.lua.org/">Lua</a> version 5.1, <a href="http://www.postgresql.org/">PostgreSQL</a> version 8.2 or higher, a C compiler, and a Webserver like Lighttpd or Apache.
    </p>
    <h2>Installation</h2>
    <p>
      After downloading the tar.gz package, unpack it, enter the unpacked directory and type <tt>make</tt>. If you use Mac OS X or if you experience problems during compilation, you need to edit the <tt>Makefile.options</tt> file prior to compilation. The framework itself will be available in the <tt>framework/</tt> directory, while a demo application is available in the <tt>demo-app/</tt> directory. The <tt>framework.precompiled/</tt> and <tt>demo-app.precompiled/</tt> directories will contain a version with all Lua files being byte-code pre-compiled, which can be used instead. You may copy these directories (with <tt>cp -L</tt> to follow links) to any other place you like. Use the files <tt>doc/lighttpd.sample.conf</tt> or <tt>doc/apache.sample.conf</tt> to setup your webserver appropriatly. Don't forget to setup a database, and make the <tt>tmp/</tt> directory of the application writable for the web server process. Good luck and have fun!
    </p>
    <h2>Using the atom library</h2>
    <p>
      Lua itself has only very few built-in data types. The atom library gives support for extra data types. Currently the following extra data types are provided:
    </p>
    <ul>
      <li>atom.fraction</li>
      <li>atom.date</li>
      <li>atom.time</li>
      <li>atom.timestamp (date and time combined in one data type)</li>
    </ul>
    <p>
      In addition the following pseudo-types are existent, corresponding to Lua's base types:
    </p>
    <ul>
      <li>atom.boolean</li>
      <li>atom.string</li>
      <li>atom.integer</li>
      <li>atom.number</li>
    </ul>
    <p>
      Both atom.integer and atom.number refer to Lua's base type &ldquo;number&rdquo;.
    </p>
    <p>
      New values of atom data types are created by either calling <tt>atom.<i>type</i>:load(string_representation)</tt> or by calling <tt>atom.<i>type</i>{...}</tt>, e.g. <tt>atom.date{year=1970, month=1, day=1}</tt>. You can dump any atom value as a string by calling <tt>atom.dump(value)</tt> and later reload it with <tt>atom.<i>type</i>:load(string)</tt>.
    </p>
    <h2>Using the Object-Relational Mapper &ldquo;mondelefant&rdquo;</h2>
    <p>
      The library &ldquo;mondelefant&rdquo; shipping with WebMCP can be used to access PostgreSQL databases. It also serves as an Object-Relational Mapper (ORM). Opening a connection to a database is usually done in a config file in the following way:
    </p>
    <pre>
db = assert( mondelefant.connect{ engine='postgresql', dbname='webmcp_demo' } )
at_exit(function() 
  db:close()
end)
function mondelefant.class_prototype:get_db_conn() return db end

function db:sql_tracer(command)
  return function(error_info)
    local error_info = error_info or {}
    trace.sql{ command = command, error_position = error_info.position }
  end
end</pre>
    <p>
      Overwriting the <tt>sql_tracer</tt> method of the database handle is optional, but helpful for debugging. The parameters for <tt>mondelefant.connect</tt> are directly passed to PostgreSQL's client library libpq. See <a href="http://www.postgresql.org/docs/8.4/interactive/libpq-connect.html">PostgreSQL's documentation on PQconnect</a> for information about supported parameters.
    </p>
    <p>
      To define a model to be used within a WebMCP application, create a file named with the name of the model and <tt>.lua</tt> as extension in the <tt>model/</tt> directory of your application. The most basic definition of a model (named &ldquo;movie&rdquo; in this example) is:
    </p>
    <pre>
Movie = mondelefant.new_class()
Movie.table = 'movie'</pre>
    <p>
      Note: Model classes are always written CamelCase, while the name of the file in <tt>model/</tt> is written lower_case.
    </p>
    <p>
      To select objects from the database, the mondelefant library provides a selector framework:
    </p>
    <pre>
local s = Movie:new_selector()
s:add_where{ 'id = ?', param.get_id() }
s:single_object_mode()  -- return single object instead of list
local movie = s:exec()</pre>
    <p>
      A short form of the above query would be:
    </p>
    <pre>
local movie = Movie:new_selector():add_where{ 'id = ?', param.get_id() }:single_object_mode():exec()</pre>
    <p>
      For more examples about how to use the model system, please take a look at the demo application.
    </p>
    <h2>The Model-View-Action (MVA) concept</h2>
    <p>
      As opposed to other web application frameworks, WebMCP does not use a Model-View-Controller (MVC) concept, but a Model-View-Action (MVA) concept.
    </p>
    <h3>Models</h3>
    <p>
      The models in MVA are like the models in MVC; they are used to access data stored in a relational database (PostgreSQL) in an object oriented way. They can also be used to provide methods for working with objects representing the database entries.
    </p>
    <h3>Views</h3>
    <p>
      The views in the MVA concept are different from the views in the MVC concept. As WebMCP has no controllers, the views are responsible for processing the GET/POST parameters from the webbrowser, fetching the data to be displayed, and creating the output by directly writing HTML to slots in a layout or by calling helper functions for the user interface.
    </p>
    <h3>Actions</h3>
    <p>
      Actions are similar to views, but supposed to change data in the database, hence only callable by HTTP POST requests. They are also responsible for processing the POST parameters from the webbrowser. They can modify the database, but instead of rendering a page to be displayed, they just return a status code. Depending on the status code there will be an internal forward or an HTTP 303 redirect to a view. When calling an action via a POST request, additional POST parameters, which are usually added by hidden form fields, determine the view to be displayed for each status code returned by the action.
    </p>
    <h2>Directory structure of a WebMCP application</h2>
    <ul>
      <li>
        Base Directory
        <ul>
          <li>
            <tt>app/</tt>
            <ul>
              <li>
                <tt>main/</tt>
                <ul>
                  <li>
                    <tt>_filter/</tt>
                    <ul>
                      <li>
                        <tt>10_first_filter.lua</tt>
                      <li>
                      </li>
                        <tt>30_third_filter.lua</tt>
                      </li>
                      <li>&hellip;</li>
                    </ul>
                  </li>
                  <li>
                    <tt>_filter_action/</tt>
                    <ul>
                      <li>
                        <tt>20_second_filter.lua</tt>
                      </li>
                      <li>&hellip;</li>
                    </ul>
                  </li>
                  <li>
                    <tt>_filter_view/</tt>
                    <ul>
                      <li>&hellip;</li>
                    </ul>
                  </li>
                  <li>
                    <tt>_layout/</tt>
                    <ul>
                      <li>&hellip;</li>
                    </ul>
                  </li>
                  <li>
                    <tt>index/</tt>
                    <ul>
                      <li>
                        <tt>_action/</tt>
                        <ul>
                          <li>
                            <i>action_name</i><tt>.lua</tt>
                          </li>
                          <li>
                            <i>another_action_name</i><tt>.lua</tt>
                          </li>
                          <li>&hellip;</li>
                        </ul>
                      </li>
                      <li>
                        <tt>index.lua</tt>
                      </li>
                      <li>
                        <i>other_view_name</i><tt>.lua</tt>
                      </li>
                      <li>&hellip;</li>
                    </ul>
                  </li>
                  <li>
                    <i>other_module_name</i><tt>/</tt>
                    <ul>
                      <li>&hellip;</li>
                    </ul>
                  </li>
                </ul>
              </li>
              <li>
                <i>other_application_name</i><tt>/</tt>
                <ul>
                  <li>&hellip;</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>
            <tt>config/</tt>
            <ul>
              <li>
                <tt>development.lua</tt>
              </li>
              <li>
                <tt>production.lua</tt>
              <li>
              <li>
                <i>other_config_name</i><tt>.lua</tt>
              </li>
              <li>&hellip;</li>
            </ul>
          </li>
          <li>
            <tt>db/</tt>
            <ul>
              <li>
                <tt>schema.sql</tt>
              </li>
            </ul>
          </li>
          <li>
            <tt>locale/</tt>
            <ul>
              <li>
                <tt>translations.de.lua</tt>
              </li>
              <li>
                <tt>translations.en.lua</tt>
              </li>
              <li>
                <tt>translations.</tt><i>languagecode</i><tt>.lua</tt>
              </li>
              <li>&hellip;</li>
            </ul>
          </li>
          <li>
            <tt>model/</tt>
            <ul>
              <li>
                <i>model_name</i><tt>.lua</tt>
              </li>
              <li>
                <i>another_model_name</i><tt>.lua</tt>
              </li>
              <li>&hellip;</li>
            </ul>
          </li>
          <li>
            <tt>static/</tt>
            <ul>
              <li>&hellip; (images, javascript, ...)</li>
            </ul>
          </li>
          <li>
            <tt>tmp/</tt> (writable by the web process)
          </li>
        </ul>
      </li>
    </ul>
    <h2>Automatically generated reference for the WebMCP environment</h2>
    <ul>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_1').style.display = document.getElementById('autodoc_details_1').style.display ? '' : 'none';">
    &lt;db_class&gt;.primary_key
  </div>
  <div id="autodoc_details_1" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>&lt;db_class&gt;.primary_key</pre>
    </div>
    <div class="autodoc_comment">Primary key of a database class (model). Defaults to &quot;id&quot;.    </div>
    <div class="autodoc_source">
<pre>class_prototype.primary_key = &quot;id&quot;</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_2').style.display = document.getElementById('autodoc_details_2').style.display ? '' : 'none';">
    &lt;db_class&gt;:add_reference{ ... }
  </div>
  <div id="autodoc_details_2" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>db_class =                                        <span class="autodoc_comment_tail">-- same class returned</span>
&lt;db_class&gt;:add_reference{
  mode                  = mode,                   <span class="autodoc_comment_tail">-- &quot;11&quot;, &quot;1m&quot;, &quot;m1&quot;, or &quot;mm&quot; (one/many to one/many)</span>
  to                    = to,                     <span class="autodoc_comment_tail">-- referenced class (model), optionally as string or function returning the value (avoids autoload)</span>
  this_key              = this_key,               <span class="autodoc_comment_tail">-- name of key in this class (model)</span>
  that_key              = that_key,               <span class="autodoc_comment_tail">-- name of key in the other class (model) (&quot;to&quot; argument)</span>
  ref                   = ref,                    <span class="autodoc_comment_tail">-- name of reference in this class, referring to the other class</span>
  back_ref              = back_ref,               <span class="autodoc_comment_tail">-- name of reference in other class, referring to this class</span>
  default_order         = default_order,          <span class="autodoc_comment_tail">-- expression as passed to &quot;assemble_command&quot; used for sorting</span>
  selector_generator    = selector_generator,     <span class="autodoc_comment_tail">-- alternative function used as selector generator (use only, when you know what you are doing)</span>
  connected_by_table    = connected_by_table,     <span class="autodoc_comment_tail">-- connecting table used for many to many relations</span>
  connected_by_this_key = connected_by_this_key,  <span class="autodoc_comment_tail">-- key in connecting table referring to &quot;this_key&quot; of this class (model)</span>
  connected_by_that_key = connected_by_that_key   <span class="autodoc_comment_tail">-- key in connecting table referring to &quot;that_key&quot; in other class (model) (&quot;to&quot; argument)</span>
}</pre>
    </div>
    <div class="autodoc_comment">Denotes a reference from one database class to another database class (model to model relation). There are 4 possible types of references: one-to-one (mode = &quot;11&quot;), one-to-many (mode = &quot;1m&quot;), many-to-one (&quot;m1&quot;), and many-to-many (&quot;mm&quot;). References usually should be defined in both models, which are related to each other, with mirrored mode (i.e. &quot;1m&quot; in one model, and &quot;m1&quot; in the other). One-to-one and one-to-many references may have a &quot;back_ref&quot; setting, which causes that loaded objects of the referenced class, refer back to the originating object. One-to-many and many-to-many references may have a &quot;default_order&quot; setting, which selects the default order for selected objects. When adding a many-to-many reference, the argument &quot;connected_by_table&quot;, &quot;connected_by_this_key&quot; and &quot;connected_by_that_key&quot; must be set additionally.    </div>
    <div class="autodoc_source">
<pre>function class_prototype:add_reference(args)
  local selector_generator    = args.selector_generator
  local mode                  = args.mode
  local to                    = args.to
  local this_key              = args.this_key
  local that_key              = args.that_key
  local connected_by_table    = args.connected_by_table  <span class="autodoc_comment_tail">-- TODO: split to table and schema</span>
  local connected_by_this_key = args.connected_by_this_key
  local connected_by_that_key = args.connected_by_that_key
  local ref                   = args.ref
  local back_ref              = args.back_ref
  local default_order         = args.default_order
  local model
  local function get_model()
    if not model then
      if type(to) == &quot;string&quot; then
        model = _G
        for path_element in string.gmatch(to, &quot;[^.]+&quot;) do
          model = model[path_element]
        end
      elseif type(to) == &quot;function&quot; then
        model = to()
      else
        model = to
      end
    end
    if not model or model == _G then
      error(&quot;Could not get model for reference.&quot;)
    end
    return model
  end
  self.references[ref] = {
    mode     = mode,
    this_key = this_key,
    that_key = connected_by_table and &quot;mm_ref_&quot; or that_key,
    ref      = ref,
    back_ref = back_ref,
    selector_generator = selector_generator or function(list, options)
      <span class="autodoc_comment_tail">-- TODO: support tuple keys</span>
      local options = options or {}
      local model = get_model()
      <span class="autodoc_comment_tail">-- TODO: too many records cause PostgreSQL command stack overflow</span>
      local ids = { sep = &quot;, &quot; }
      for i, object in ipairs(list) do
        local id = object[this_key]
        if id ~= nil then
          ids[#ids+1] = {&quot;?&quot;, id}
        end
      end
      if #ids == 0 then
        return model:new_selector():empty_list_mode()
      end
      local selector = model:new_selector()
      if connected_by_table then
        selector:join(
          connected_by_table,
          nil,
          {
            '$.&quot;$&quot; = $.&quot;$&quot;',
            {connected_by_table},
            {connected_by_that_key},
            {model:get_qualified_table()},
            {that_key}
          }
        )
        selector:add_field(
          {
            '$.&quot;$&quot;',
            {connected_by_table},
            {connected_by_this_key}
          },
          'mm_ref_'
        )
        selector:add_where{
          '$.&quot;$&quot; IN ($)',
          {connected_by_table},
          {connected_by_this_key},
          ids
        }
      else
        selector:add_where{'$.&quot;$&quot; IN ($)', {model:get_qualified_table()}, {that_key}, ids}
      end
      if options.order == nil and default_order then
        selector:add_order_by(default_order)
      elseif options.order then
        selector:add_order_by(options.order)
      end
      return selector
    end
  }
  if mode == &quot;m1&quot; or mode == &quot;11&quot; then
    self.foreign_keys[this_key] = ref
  end
  return self
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_3').style.display = document.getElementById('autodoc_details_3').style.display ? '' : 'none';">
    &lt;db_class&gt;:create_list()
  </div>
  <div id="autodoc_details_3" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>db_list =                 <span class="autodoc_comment_tail">-- database result being an empty list</span>
&lt;db_class&gt;:create_list()</pre>
    </div>
    <div class="autodoc_comment">Creates an empty database result representing a list of objects of the given class.    </div>
    <div class="autodoc_source">
<pre>function class_prototype:create_list()
  local list = self:get_db_conn():create_list()
  list._class = self
  return list
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_4').style.display = document.getElementById('autodoc_details_4').style.display ? '' : 'none';">
    &lt;db_class&gt;:get_columns()
  </div>
  <div id="autodoc_details_4" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>columns =                 <span class="autodoc_comment_tail">-- list of columns</span>
&lt;db_class&gt;:get_columns()</pre>
    </div>
    <div class="autodoc_comment">This method returns a list of column names of the table used for the class.    </div>
    <div class="autodoc_source">
<pre>function class_prototype:get_columns()
  if self._columns then
    return self._columns
  end
  local selector = self:get_db_conn():new_selector()
  selector:set_class(self)
  selector:from(self:get_qualified_table())
  selector:add_field(&quot;*&quot;)
  selector:add_where(&quot;FALSE&quot;)
  local db_result = selector:exec()
  local connection = db_result._connection
  local columns = {}
  for idx, info in ipairs(db_result._column_info) do
    local key   = info.field_name
    local value = {
      name = key,
      type = connection.type_mappings[info.type]
    }
    columns[key] = value
    table.insert(columns, value)
  end
  self._columns = columns
  return columns
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_5').style.display = document.getElementById('autodoc_details_5').style.display ? '' : 'none';">
    &lt;db_class&gt;:get_db_conn()
  </div>
  <div id="autodoc_details_5" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>db_handle =               <span class="autodoc_comment_tail">-- database connection handle used by this class</span>
&lt;db_class&gt;:get_db_conn()</pre>
    </div>
    <div class="autodoc_comment">By implementing this method for a particular model or overwriting it in the default prototype &quot;mondelefant.class_prototype&quot;, classes are connected with a particular database. This method needs to return a database connection handle. If it is not overwritten, an error is thrown, when invoking this method.    </div>
    <div class="autodoc_source">
<pre>function class_prototype:get_db_conn()
  error(
    &quot;Method mondelefant class(_prototype):get_db_conn() &quot; ..
    &quot;has to be implemented.&quot;
  )
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_6').style.display = document.getElementById('autodoc_details_6').style.display ? '' : 'none';">
    &lt;db_class&gt;:get_foreign_key_reference_name( foreign_key )
  </div>
  <div id="autodoc_details_6" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>reference_name =                            <span class="autodoc_comment_tail">-- reference name</span>
&lt;db_class&gt;:get_foreign_key_reference_name(
  foreign_key                               <span class="autodoc_comment_tail">-- foreign key</span>
)</pre>
    </div>
    <div class="autodoc_comment">This function performs a lookup for the given name in the &quot;foreign_keys&quot; table. Prototypes are used, when lookup was unsuccessful.    </div>
    <div class="autodoc_source">
<pre><span class="autodoc_comment_tail">-- implemented in mondelefant_native.c as</span>
<span class="autodoc_comment_tail">-- static int mondelefant_class_get_reference(lua_State *L)</span></pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_7').style.display = document.getElementById('autodoc_details_7').style.display ? '' : 'none';">
    &lt;db_class&gt;:get_primary_key_list()
  </div>
  <div id="autodoc_details_7" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>list =                             <span class="autodoc_comment_tail">-- list of column names of primary key</span>
&lt;db_class&gt;:get_primary_key_list()</pre>
    </div>
    <div class="autodoc_comment">This method returns a list of column names of the primary key.    </div>
    <div class="autodoc_source">
<pre>function class_prototype:get_primary_key_list()
  local primary_key = self.primary_key
  if type(primary_key) == &quot;string&quot; then
    return {primary_key}
  else
    return primary_key
  end
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_8').style.display = document.getElementById('autodoc_details_8').style.display ? '' : 'none';">
    &lt;db_class&gt;:get_qualified_table()
  </div>
  <div id="autodoc_details_8" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>string =                          <span class="autodoc_comment_tail">-- string of form '&quot;schemaname&quot;.&quot;tablename&quot;' or '&quot;tablename&quot;'</span>
&lt;db_class&gt;:get_qualified_table()</pre>
    </div>
    <div class="autodoc_comment">This method returns a string with the (double quoted) qualified table name used to store objects of this class.    </div>
    <div class="autodoc_source">
<pre>function class_prototype:get_qualified_table()
  if not self.table then error &quot;Table unknown.&quot; end
  if self.schema then
    return '&quot;' .. self.schema .. '&quot;.&quot;' .. self.table .. '&quot;'
  else
    return '&quot;' .. self.table .. '&quot;'
  end
end
<span class="autodoc_comment_tail">--]]--</span>

<span class="autodoc_comment_tail">--[[--</span>
string =                                  <span class="autodoc_comment_tail">-- single quoted string of form &quot;'schemaname.tablename'&quot; or &quot;'tablename'&quot;</span>
&lt;db_class&gt;:get_qualified_table_literal()

This method returns a string with an SQL literal representing the given table. It causes ambiguities when the table name contains a dot (&quot;.&quot;) character.

<span class="autodoc_comment_tail">--]]--</span>
function class_prototype:get_qualified_table_literal()
  if not self.table then error &quot;Table unknown.&quot; end
  if self.schema then
    return self.schema .. '.' .. self.table
  else
    return self.table
  end
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_9').style.display = document.getElementById('autodoc_details_9').style.display ? '' : 'none';">
    &lt;db_class&gt;:get_reference( name )
  </div>
  <div id="autodoc_details_9" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>reference_data =           <span class="autodoc_comment_tail">-- table with reference information</span>
&lt;db_class&gt;:get_reference(
  name                     <span class="autodoc_comment_tail">-- reference name</span>
)</pre>
    </div>
    <div class="autodoc_comment">This function performs a lookup for the given name in the &quot;reference&quot; table. Prototypes are used, when lookup was unsuccessful.    </div>
    <div class="autodoc_source">
<pre><span class="autodoc_comment_tail">-- implemented in mondelefant_native.c as</span>
<span class="autodoc_comment_tail">-- static int mondelefant_class_get_reference(lua_State *L)</span></pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_10').style.display = document.getElementById('autodoc_details_10').style.display ? '' : 'none';">
    &lt;db_class&gt;:new()
  </div>
  <div id="autodoc_details_10" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>db_object =       <span class="autodoc_comment_tail">-- database object (instance of model)</span>
&lt;db_class&gt;:new()</pre>
    </div>
    <div class="autodoc_comment">Creates a new object of the given class.    </div>
    <div class="autodoc_source">
<pre>function class_prototype:new()
  local object = self:get_db_conn():create_object()
  object._class = self
  object._new = true
  return object
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_11').style.display = document.getElementById('autodoc_details_11').style.display ? '' : 'none';">
    &lt;db_class&gt;:new_selector( db_conn )
  </div>
  <div id="autodoc_details_11" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>selector =                <span class="autodoc_comment_tail">-- new selector for selecting objects of this class</span>
&lt;db_class&gt;:new_selector(
  db_conn                 <span class="autodoc_comment_tail">-- optional(!) database connection handle, defaults to result of :get_db_conn()</span>
)</pre>
    </div>
    <div class="autodoc_comment">This method creates a new selector for selecting objects of the class.    </div>
    <div class="autodoc_source">
<pre>function class_prototype:new_selector(db_conn)
  local selector = (db_conn or self:get_db_conn()):new_selector()
  selector:set_class(self)
  selector:from(self:get_qualified_table())
  selector:add_field(self:get_qualified_table() .. &quot;.*&quot;)
  return selector
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_12').style.display = document.getElementById('autodoc_details_12').style.display ? '' : 'none';">
    &lt;db_error&gt;:escalate()
  </div>
  <div id="autodoc_details_12" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>&lt;db_error&gt;:escalate()</pre>
    </div>
    <div class="autodoc_comment">Causes a Lua error to be thrown. If the database connection has &quot;error_objects&quot; set to true, then the object is thrown itself, otherwise a string is thrown.    </div>
    <div class="autodoc_source">
<pre><span class="autodoc_comment_tail">-- implemented in mondelefant_native.c as</span>
<span class="autodoc_comment_tail">-- static int mondelefant_errorobject_escalate(lua_State *L)</span></pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_13').style.display = document.getElementById('autodoc_details_13').style.display ? '' : 'none';">
    &lt;db_error&gt;:is_kind_of( error_code )
  </div>
  <div id="autodoc_details_13" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>bool =                  <span class="autodoc_comment_tail">-- true or false</span>
&lt;db_error&gt;:is_kind_of(
  error_code            <span class="autodoc_comment_tail">-- error code as used by this library</span>
)</pre>
    </div>
    <div class="autodoc_comment">Checks, if a given error is of a given kind.<br/><br/>Example:<br/>db_error:is_kind_of(&quot;IntegrityConstraintViolation&quot;)    </div>
    <div class="autodoc_source">
<pre><span class="autodoc_comment_tail">-- implemented in mondelefant_native.c as</span>
<span class="autodoc_comment_tail">-- static int mondelefant_errorobject_is_kind_of(lua_State *L)</span></pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_14').style.display = document.getElementById('autodoc_details_14').style.display ? '' : 'none';">
    &lt;db_handle&gt;:assemble_command{ ... }
  </div>
  <div id="autodoc_details_14" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>sql_string =
&lt;db_handle&gt;:assemble_command{
  template,                    <span class="autodoc_comment_tail">-- template string</span>
  arg1,                        <span class="autodoc_comment_tail">-- value to be inserted</span>
  arg2,                        <span class="autodoc_comment_tail">-- another value to be inserted</span>
  key1 = named_arg3,           <span class="autodoc_comment_tail">-- named value</span>
  key2 = named_arg4,           <span class="autodoc_comment_tail">-- another named value</span>
  ...
}</pre>
    </div>
    <div class="autodoc_comment">This method returns a SQL command by inserting the given values into the template string. Placeholders are &quot;?&quot; or &quot;$&quot;, optionally followed by alphanumeric characters (including underscores). Placeholder characters can be escaped by writing them twice. A question-mark (&quot;?&quot;) denotes a single value to be inserted, a dollar-sign (&quot;$&quot;) denotes a list of sub-structures to be inserted. If alphanumeric characters are following the placeholder character, then these characters form a key, which is used to lookup the value to be used, otherwise values of numeric indicies are used.<br/><br/>TODO: documentation of input-converters<br/><br/>List of sub-structures are tables with an optional &quot;sep&quot; value, which is used as seperator. Each (numerically indexed) entry  of this table is passed to a recursive call of &quot;assemble_command&quot; and concatenated with the given seperator, or &quot;, &quot;, if no seperator is given.    </div>
    <div class="autodoc_source">
<pre><span class="autodoc_comment_tail">-- implemented in mondelefant_native.c as</span>
<span class="autodoc_comment_tail">-- static int mondelefant_conn_assemble_command(lua_State *L)</span></pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_15').style.display = document.getElementById('autodoc_details_15').style.display ? '' : 'none';">
    &lt;db_handle&gt;:close()
  </div>
  <div id="autodoc_details_15" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>&lt;db_handle&gt;:close()</pre>
    </div>
    <div class="autodoc_comment">Closes the database connection. This method may be called multiple times and is called automatically when the database handle is garbage collected.    </div>
    <div class="autodoc_source">
<pre><span class="autodoc_comment_tail">-- implemented in mondelefant_native.c as</span>
<span class="autodoc_comment_tail">-- static int mondelefant_conn_close(lua_State *L)</span></pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_16').style.display = document.getElementById('autodoc_details_16').style.display ? '' : 'none';">
    &lt;db_handle&gt;:create_list()
  </div>
  <div id="autodoc_details_16" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>db_list =                  <span class="autodoc_comment_tail">-- database result being an empty list</span>
&lt;db_handle&gt;:create_list()</pre>
    </div>
    <div class="autodoc_comment">Creates an empty database result representing a list. The used meta-table is &quot;result_metatable&quot;. The attribute &quot;_connection&quot; is set to the database handle, and the attribute &quot;_type&quot; is set to &quot;list&quot;.    </div>
    <div class="autodoc_source">
<pre><span class="autodoc_comment_tail">-- implemented in mondelefant_native.c as</span>
<span class="autodoc_comment_tail">-- static int mondelefant_conn_create_list(lua_State *L)</span></pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_17').style.display = document.getElementById('autodoc_details_17').style.display ? '' : 'none';">
    &lt;db_handle&gt;:create_object()
  </div>
  <div id="autodoc_details_17" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>db_object =                  <span class="autodoc_comment_tail">-- database result being an empty object (row)</span>
&lt;db_handle&gt;:create_object()</pre>
    </div>
    <div class="autodoc_comment">Creates an empty database result representing an object (row). The used meta-table is &quot;result_metatable&quot;. The attribute &quot;_connection&quot; is set to the database handle, and the attribute &quot;_type&quot; is set to &quot;object&quot;. Additionally the attributes &quot;_data&quot;, &quot;_dirty&quot; and &quot;_ref&quot; are initialized with an empty table. TODO: Documentation of _data, _dirty and _ref.    </div>
    <div class="autodoc_source">
<pre><span class="autodoc_comment_tail">-- implemented in mondelefant_native.c as</span>
<span class="autodoc_comment_tail">-- static int mondelefant_conn_create_object(lua_State *L)</span></pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_18').style.display = document.getElementById('autodoc_details_18').style.display ? '' : 'none';">
    &lt;db_handle&gt;:get_transaction_status()
  </div>
  <div id="autodoc_details_18" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>status =                              <span class="autodoc_comment_tail">-- status string</span>
&lt;db_handle&gt;:get_transaction_status()</pre>
    </div>
    <div class="autodoc_comment">Depending on the transaction status of the connection a string is returned:<br/>- idle<br/>- active<br/>- intrans<br/>- inerror<br/>- unknown    </div>
    <div class="autodoc_source">
<pre><span class="autodoc_comment_tail">-- implemented in mondelefant_native.c as</span>
<span class="autodoc_comment_tail">-- static int mondelefant_conn_get_transaction_status(lua_State *L)</span></pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_19').style.display = document.getElementById('autodoc_details_19').style.display ? '' : 'none';">
    &lt;db_handle&gt;:is_ok()
  </div>
  <div id="autodoc_details_19" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>status =             <span class="autodoc_comment_tail">-- true, if database connection has no malfunction</span>
&lt;db_handle&gt;:is_ok()</pre>
    </div>
    <div class="autodoc_comment">Returns false, if the database connection has a malfunction, otherwise true.    </div>
    <div class="autodoc_source">
<pre><span class="autodoc_comment_tail">-- implemented in mondelefant_native.c as</span>
<span class="autodoc_comment_tail">-- static int mondelefant_conn_is_ok(lua_State *L)</span></pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_20').style.display = document.getElementById('autodoc_details_20').style.display ? '' : 'none';">
    &lt;db_handle&gt;:new_selector()
  </div>
  <div id="autodoc_details_20" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>selector =                  <span class="autodoc_comment_tail">-- new selector</span>
&lt;db_handle&gt;:new_selector()</pre>
    </div>
    <div class="autodoc_comment">Creates a new selector to operate on the given database handle.    </div>
    <div class="autodoc_source">
<pre>function connection_prototype:new_selector()
  return init_selector(setmetatable({}, selector_metatable), self)
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_21').style.display = document.getElementById('autodoc_details_21').style.display ? '' : 'none';">
    &lt;db_handle&gt;:quote_string( raw_data )
  </div>
  <div id="autodoc_details_21" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>quoted_encoded_data =      <span class="autodoc_comment_tail">-- encoded and quoted data (as Lua string)</span>
&lt;db_handle&gt;:quote_string(
  raw_data                 <span class="autodoc_comment_tail">-- data (as Lua string) to encode and quote</span>
)</pre>
    </div>
    <div class="autodoc_comment">Prepares a binary string to be used safely within SQL queries (as &quot;bytea&quot; type). This function is database dependent.    </div>
    <div class="autodoc_source">
<pre><span class="autodoc_comment_tail">-- implemented in mondelefant_native.c as</span>
<span class="autodoc_comment_tail">-- static int mondelefant_conn_quote_binary(lua_State *L)</span></pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_22').style.display = document.getElementById('autodoc_details_22').style.display ? '' : 'none';">
    &lt;db_handle&gt;:quote_string( unencoded_string )
  </div>
  <div id="autodoc_details_22" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>quoted_encoded_string =    <span class="autodoc_comment_tail">-- encoded and quoted string</span>
&lt;db_handle&gt;:quote_string(
  unencoded_string         <span class="autodoc_comment_tail">-- string to encode and quote</span>
)</pre>
    </div>
    <div class="autodoc_comment">Prepares a string to be used safely within SQL queries. This function is database dependent (see &quot;backslash_quote&quot; server configuration option for PostgreSQL).    </div>
    <div class="autodoc_source">
<pre><span class="autodoc_comment_tail">-- implemented in mondelefant_native.c as</span>
<span class="autodoc_comment_tail">-- static int mondelefant_conn_quote_string(lua_State *L)</span></pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_23').style.display = document.getElementById('autodoc_details_23').style.display ? '' : 'none';">
    &lt;db_list&gt;:get_reference_selector{ ... }
  </div>
  <div id="autodoc_details_23" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>db_selector =
&lt;db_list&gt;:get_reference_selector(
  ref_name,                        <span class="autodoc_comment_tail">-- name of reference (e.g. &quot;children&quot;)</span>
  options,                         <span class="autodoc_comment_tail">-- table options passed to the reference loader (e.g. { order = ... })</span>
  ref_alias,                       <span class="autodoc_comment_tail">-- optional alias for the reference (e.g. &quot;ordered_children&quot;)</span>
  back_ref_alias                   <span class="autodoc_comment_tail">-- back reference name (e.g. &quot;parent&quot;)</span>
)</pre>
    </div>
    <div class="autodoc_comment">This method returns a special selector for selecting referenced objects. It is prepared in a way, that on execution of the selector, all returned objects are attached with the objects of the existent list. The &quot;ref&quot; and &quot;back_ref&quot; arguments passed to &quot;add_reference&quot; are used for the attachment, unless aliases are given with &quot;ref_alias&quot; and &quot;back_ref_alias&quot;. If &quot;options&quot; are set, these options are passed to the reference loader. The default reference loader supports only one option named &quot;order&quot;. If &quot;order&quot; is set to nil, the default order is used, if &quot;order&quot; is set to false, no ORDER BY statment is included in the selector, otherwise the given expression is used for ordering.<br/><br/>This method is not only available for database result lists but also for database result objects.    </div>
    <div class="autodoc_source">
<pre>function class_prototype.list:get_reference_selector(
  ref_name, options, ref_alias, back_ref_alias
)
  local ref_info = self._class.references[ref_name]
  if not ref_info then
    error('Reference with name &quot;' .. ref_name .. '&quot; not found.')
  end
  local selector = ref_info.selector_generator(self, options or {})
  local mode = ref_info.mode
  if mode == &quot;mm&quot; or mode == &quot;1m&quot; then
    mode = &quot;m1&quot;
  elseif mode == &quot;m1&quot; then
    mode = &quot;1m&quot;
  end
  local ref_alias = ref_alias
  if ref_alias == false then
    ref_alias = nil
  elseif ref_alias == nil then
    ref_alias = ref_name
  end
  local back_ref_alias
  if back_ref_alias == false then
    back_ref_alias = nil
  elseif back_ref_alias == nil then
    back_ref_alias = ref_info.back_ref
  end
  selector:attach(
    mode,
    self,
    ref_info.that_key,                   ref_info.this_key,
    back_ref_alias or ref_info.back_ref, ref_alias or ref_name
  )
  return selector
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_24').style.display = document.getElementById('autodoc_details_24').style.display ? '' : 'none';">
    &lt;db_list&gt;:load{ ... }
  </div>
  <div id="autodoc_details_24" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>db_list_or_object =
&lt;db_list&gt;:load(
  ref_name,          <span class="autodoc_comment_tail">-- name of reference (e.g. &quot;children&quot;)</span>
  options,           <span class="autodoc_comment_tail">-- table options passed to the reference loader (e.g. { order = ... })</span>
  ref_alias,         <span class="autodoc_comment_tail">-- optional alias for the reference (e.g. &quot;ordered_children&quot;)</span>
  back_ref_alias     <span class="autodoc_comment_tail">-- back reference name (e.g. &quot;parent&quot;)</span>
)</pre>
    </div>
    <div class="autodoc_comment">This method loads referenced objects and attaches them with the objects of the existent list. The &quot;ref&quot; and &quot;back_ref&quot; arguments passed to &quot;add_reference&quot; are used for the attachment, unless aliases are given with &quot;ref_alias&quot; and &quot;back_ref_alias&quot;. If &quot;options&quot; are set, these options are passed to the reference loader. The default reference loader supports only one option named &quot;order&quot;. If &quot;order&quot; is set to nil, the default order is used, if &quot;order&quot; is set to false, no ORDER BY statment is included in the selector, otherwise the given expression is used for ordering.<br/><br/>This method is not only available for database result lists but also for database result objects.    </div>
    <div class="autodoc_source">
<pre>function class_prototype.list.load(...)
  return class_prototype.list.get_reference_selector(...):exec()
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_25').style.display = document.getElementById('autodoc_details_25').style.display ? '' : 'none';">
    &lt;db_object&gt;:destroy()
  </div>
  <div id="autodoc_details_25" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>&lt;db_object&gt;:destroy()</pre>
    </div>
    <div class="autodoc_comment">This method deletes an object in the database. Throws error, unless successful.    </div>
    <div class="autodoc_source">
<pre>function class_prototype.object:destroy()
  local db_error = self:try_destroy()
  if db_error then
    db_error:escalate()
  end
  return self
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_26').style.display = document.getElementById('autodoc_details_26').style.display ? '' : 'none';">
    &lt;db_object&gt;:get_reference_selector{ ... }
  </div>
  <div id="autodoc_details_26" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>db_object =
&lt;db_object&gt;:get_reference_selector(
  ref_name,                          <span class="autodoc_comment_tail">-- name of reference (e.g. &quot;children&quot;)</span>
  options,                           <span class="autodoc_comment_tail">-- table options passed to the reference loader (e.g. { order = ... })</span>
  ref_alias,                         <span class="autodoc_comment_tail">-- optional alias for the reference (e.g. &quot;ordered_children&quot;)</span>
  back_ref_alias                     <span class="autodoc_comment_tail">-- back reference name (e.g. &quot;parent&quot;)</span>
)</pre>
    </div>
    <div class="autodoc_comment">This method returns a special selector for selecting referenced objects. It is prepared in a way, that on execution of the selector, all returned objects are attached with the objects of the existent list. The &quot;ref&quot; and &quot;back_ref&quot; arguments passed to &quot;add_reference&quot; are used for the attachment, unless aliases are given with &quot;ref_alias&quot; and &quot;back_ref_alias&quot;. If &quot;options&quot; are set, these options are passed to the reference loader. The default reference loader supports only one option named &quot;order&quot;. If &quot;order&quot; is set to nil, the default order is used, if &quot;order&quot; is set to false, no ORDER BY statment is included in the selector, otherwise the given expression is used for ordering.<br/><br/>This method is not only available for database result objects but also for database result lists.    </div>
    <div class="autodoc_source">
<pre>function class_prototype.object:get_reference_selector(...)
  local list = self._class:create_list()
  list[1] = self
  return list:get_reference_selector(...)
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_27').style.display = document.getElementById('autodoc_details_27').style.display ? '' : 'none';">
    &lt;db_object&gt;:load{ ... }
  </div>
  <div id="autodoc_details_27" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>db_list_or_object =
&lt;db_object&gt;:load(
  ref_name,          <span class="autodoc_comment_tail">-- name of reference (e.g. &quot;children&quot;)</span>
  options,           <span class="autodoc_comment_tail">-- table options passed to the reference loader (e.g. { order = ... })</span>
  ref_alias,         <span class="autodoc_comment_tail">-- optional alias for the reference (e.g. &quot;ordered_children&quot;)</span>
  back_ref_alias     <span class="autodoc_comment_tail">-- back reference name (e.g. &quot;parent&quot;)</span>
)</pre>
    </div>
    <div class="autodoc_comment">This method loads referenced objects and attaches them with the objects of the existent list. The &quot;ref&quot; and &quot;back_ref&quot; arguments passed to &quot;add_reference&quot; are used for the attachment, unless aliases are given with &quot;ref_alias&quot; and &quot;back_ref_alias&quot;. If &quot;options&quot; are set, these options are passed to the reference loader. The default reference loader supports only one option named &quot;order&quot;. If &quot;order&quot; is set to nil, the default order is used, if &quot;order&quot; is set to false, no ORDER BY statment is included in the selector, otherwise the given expression is used for ordering.<br/><br/>This method is not only available for database result objects but also for database result lists. Calling this method for objects is unneccessary, unless additional options and/or an alias is used.    </div>
    <div class="autodoc_source">
<pre>function class_prototype.object.load(...)
  return class_prototype.object.get_reference_selector(...):exec()
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_28').style.display = document.getElementById('autodoc_details_28').style.display ? '' : 'none';">
    &lt;db_object&gt;:save()
  </div>
  <div id="autodoc_details_28" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>&lt;db_object&gt;:save()</pre>
    </div>
    <div class="autodoc_comment">This method saves changes to an object in the database. Throws error, unless successful.    </div>
    <div class="autodoc_source">
<pre>function class_prototype.object:save()
  local db_error = self:try_save()
  if db_error then
    db_error:escalate()
  end
  return self
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_29').style.display = document.getElementById('autodoc_details_29').style.display ? '' : 'none';">
    &lt;db_object&gt;:try_destroy()
  </div>
  <div id="autodoc_details_29" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>db_error =                 <span class="autodoc_comment_tail">-- database error object, or nil in case of success</span>
&lt;db_object&gt;:try_destroy()</pre>
    </div>
    <div class="autodoc_comment">This method deletes an object in the database. Returns nil on success, otherwise an error object is returned.    </div>
    <div class="autodoc_source">
<pre>function class_prototype.object:try_destroy()
  if not self._class then
    error(&quot;Cannot destroy object: No class information available.&quot;)
  end
  local primary_key = self._class:get_primary_key_list()
  local primary_key_compare = {sep = &quot; AND &quot;}
  for idx, value in ipairs(primary_key) do
    primary_key_compare[idx] = {
      &quot;$ = ?&quot;,
      {'&quot;' .. value .. '&quot;'},
      self[value]
    }
  end
  return self._connection:try_query{
    'DELETE FROM $ WHERE $',
    {self._class:get_qualified_table()},
    primary_key_compare
  }
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_30').style.display = document.getElementById('autodoc_details_30').style.display ? '' : 'none';">
    &lt;db_object&gt;:try_save()
  </div>
  <div id="autodoc_details_30" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>db_error =              <span class="autodoc_comment_tail">-- database error object, or nil in case of success</span>
&lt;db_object&gt;:try_save()</pre>
    </div>
    <div class="autodoc_comment">This method saves changes to an object in the database. Returns nil on success, otherwise an error object is returned.    </div>
    <div class="autodoc_source">
<pre>function class_prototype.object:try_save()
  if not self._class then
    error(&quot;Cannot save object: No class information available.&quot;)
  end
  local primary_key = self._class:get_primary_key_list()
  local primary_key_sql = { sep = &quot;, &quot; }
  for idx, value in ipairs(primary_key) do
    primary_key_sql[idx] = '&quot;' .. value .. '&quot;'
  end
  if self._new then
    local fields = {sep = &quot;, &quot;}
    local values = {sep = &quot;, &quot;}
    for key, dummy in pairs(self._dirty or {}) do
      add(fields, {'&quot;$&quot;', {key}})
      add(values, {'?', self[key]})
    end
    if compat_returning then  <span class="autodoc_comment_tail">-- compatibility for PostgreSQL 8.1</span>
      local db_error, db_result1, db_result2 = self._connection:try_query(
        {
          'INSERT INTO $ ($) VALUES ($)',
          {self._class:get_qualified_table()},
          fields,
          values,
          primary_key_sql
        },
        &quot;list&quot;,
        {
          'SELECT currval(?)',
          self._class.table .. '_id_seq'
        },
        &quot;object&quot;
      )
      if db_error then
        return db_error
      end
      self.id = db_result2.id
    else
      local db_error, db_result
      if #fields == 0 then
        db_error, db_result = self._connection:try_query(
          {
            'INSERT INTO $ DEFAULT VALUES RETURNING ($)',
            {self._class:get_qualified_table()},
            primary_key_sql
          },
          &quot;object&quot;
        )
      else
        db_error, db_result = self._connection:try_query(
          {
            'INSERT INTO $ ($) VALUES ($) RETURNING ($)',
            {self._class:get_qualified_table()},
            fields,
            values,
            primary_key_sql
          },
          &quot;object&quot;
        )
      end
      if db_error then
        return db_error
      end
      for idx, value in ipairs(primary_key) do
        self[value] = db_result[value]
      end
    end
    self._new = false
  else
    local command_sets = {sep = &quot;, &quot;}
    for key, dummy in pairs(self._dirty or {}) do
      add(command_sets, {'&quot;$&quot; = ?', {key}, self[key]})
    end
    if #command_sets &gt;= 1 then
      local primary_key_compare = {sep = &quot; AND &quot;}
      for idx, value in ipairs(primary_key) do
        primary_key_compare[idx] = {
          &quot;$ = ?&quot;,
          {'&quot;' .. value .. '&quot;'},
          self[value]
        }
      end
      local db_error = self._connection:try_query{
        'UPDATE $ SET $ WHERE $',
        {self._class:get_qualified_table()},
        command_sets,
        primary_key_compare
      }
      if db_error then
        return db_error
      end
    end
  end
  return nil
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_31').style.display = document.getElementById('autodoc_details_31').style.display ? '' : 'none';">
    &lt;db_selector&gt;:add_combine( expression )
  </div>
  <div id="autodoc_details_31" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>db_selector =               <span class="autodoc_comment_tail">-- same selector returned</span>
&lt;db_selector&gt;:add_combine(
  expression                <span class="autodoc_comment_tail">-- expression as passed to &quot;assemble_command&quot;</span>
)</pre>
    </div>
    <div class="autodoc_comment">This function is used for UNION/INTERSECT/EXCEPT clauses. It does not need to be called directly. Use &quot;union&quot;, &quot;union_all&quot;, &quot;intersect&quot;, &quot;intersect_all&quot;, &quot;except&quot; and &quot;except_all&quot; instead.    </div>
    <div class="autodoc_source">
<pre>function selector_prototype:add_combine(expression)
  add(self._combine, expression)
  return self
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_32').style.display = document.getElementById('autodoc_details_32').style.display ? '' : 'none';">
    &lt;db_selector&gt;:add_distinct_on( expression )
  </div>
  <div id="autodoc_details_32" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>db_selector =                   <span class="autodoc_comment_tail">-- same selector returned</span>
&lt;db_selector&gt;:add_distinct_on(
  expression                    <span class="autodoc_comment_tail">-- expression as passed to &quot;assemble_command&quot;</span>
)</pre>
    </div>
    <div class="autodoc_comment">Adds an DISTINCT ON expression to the selector. The selector is modified and returned.    </div>
    <div class="autodoc_source">
<pre>function selector_prototype:add_distinct_on(expression)
  if self._distinct then
    error(&quot;Can not combine DISTINCT with DISTINCT ON.&quot;)
  end
  add(self._distinct_on, expression)
  return self
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_33').style.display = document.getElementById('autodoc_details_33').style.display ? '' : 'none';">
    &lt;db_selector&gt;:add_field( expression, alias, option_list )
  </div>
  <div id="autodoc_details_33" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>db_selector =             <span class="autodoc_comment_tail">-- same selector returned</span>
&lt;db_selector&gt;:add_field(
  expression,             <span class="autodoc_comment_tail">-- expression as passed to &quot;assemble_command&quot;</span>
  alias,                  <span class="autodoc_comment_tail">-- optional alias expression as passed to &quot;assemble_command&quot;</span>
  option_list             <span class="autodoc_comment_tail">-- optional list of options (may contain strings &quot;distinct&quot; or &quot;grouped&quot;)</span>
)</pre>
    </div>
    <div class="autodoc_comment">Adds fields to the selector. The selector is modified and returned. The third argument can be a list of options. If option &quot;distinct&quot; is given, then &quot;add_distinct_on&quot; will be executed for the given field or alias. If option &quot;grouped&quot; is given, then &quot;add_group_by&quot; will be executed for the given field or alias.    </div>
    <div class="autodoc_source">
<pre>function selector_prototype:add_field(expression, alias, options)
  if alias then
    add(self._fields, {'$ AS &quot;$&quot;', {expression}, {alias}})
  else
    add(self._fields, expression)
  end
  if options then
    for i, option in ipairs(options) do
      if option == &quot;distinct&quot; then
        if alias then
          self:add_distinct_on('&quot;' .. alias .. '&quot;')
        else
          self:add_distinct_on(expression)
        end
      elseif option == &quot;grouped&quot; then
        if alias then
          self:add_group_by('&quot;' .. alias .. '&quot;')
        else
          self:add_group_by(expression)
        end
      else
        error(&quot;Unknown option '&quot; .. option .. &quot;' to add_field method.&quot;)
      end
    end
  end
  return self
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_34').style.display = document.getElementById('autodoc_details_34').style.display ? '' : 'none';">
    &lt;db_selector&gt;:add_from( expression, alias, condition )
  </div>
  <div id="autodoc_details_34" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>db_selector =             <span class="autodoc_comment_tail">-- same selector returned</span>
&lt;db_selector&gt;:add_from(
  expression,             <span class="autodoc_comment_tail">-- expression as passed to &quot;assemble_command&quot;</span>
  alias,                  <span class="autodoc_comment_tail">-- optional alias expression as passed to &quot;assemble_command&quot;</span>
  condition               <span class="autodoc_comment_tail">-- optional condition expression as passed to &quot;assemble_command&quot;</span>
)</pre>
    </div>
    <div class="autodoc_comment">Adds expressions for FROM clause to the selector. The selector is modified and returned. If an additional condition is given, an INNER JOIN will be used, otherwise a CROSS JOIN.<br/><br/>This method is identical to &quot;join&quot;.    </div>
    <div class="autodoc_source">
<pre>function selector_prototype:add_from(expression, alias, condition)
  local first = (#self._from == 0)
  if not first then
    if condition then
      add(self._from, &quot;INNER JOIN&quot;)
    else
      add(self._from, &quot;CROSS JOIN&quot;)
    end
  end
  if getmetatable(expression) == selector_metatable then
    if alias then
      add(self._from, {'($) AS &quot;$&quot;', {expression}, {alias}})
    else
      add(self._from, {'($) AS &quot;subquery&quot;', {expression}})
    end
  else
    if alias then
      add(self._from, {'$ AS &quot;$&quot;', {expression}, {alias}})
    else
      add(self._from, expression)
    end
  end
  if condition then
    if first then
      self:add_where(condition)
    else
      add(self._from, &quot;ON&quot;)
      add(self._from, condition)
    end
  end
  return self
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_35').style.display = document.getElementById('autodoc_details_35').style.display ? '' : 'none';">
    &lt;db_selector&gt;:add_group_by( expression )
  </div>
  <div id="autodoc_details_35" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>db_selector =                <span class="autodoc_comment_tail">-- same selector returned</span>
&lt;db_selector&gt;:add_group_by(
  expression                 <span class="autodoc_comment_tail">-- expression as passed to &quot;assemble_command&quot;</span>
)</pre>
    </div>
    <div class="autodoc_comment">Adds expressions for GROUP BY clause to the selector. The selector is modified and returned.    </div>
    <div class="autodoc_source">
<pre>function selector_prototype:add_group_by(expression)
  add(self._group_by, expression)
  return self
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_36').style.display = document.getElementById('autodoc_details_36').style.display ? '' : 'none';">
    &lt;db_selector&gt;:add_having( expression )
  </div>
  <div id="autodoc_details_36" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>db_selector =              <span class="autodoc_comment_tail">-- same selector returned</span>
&lt;db_selector&gt;:add_having(
  expression               <span class="autodoc_comment_tail">-- expression as passed to &quot;assemble_command&quot;</span>
)</pre>
    </div>
    <div class="autodoc_comment">Adds expressions for HAVING clause to the selector. The selector is modified and returned. Multiple calls cause expressions to be AND-combined.    </div>
    <div class="autodoc_source">
<pre>function selector_prototype:add_having(expression)
  add(self._having, expression)
  return self
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_37').style.display = document.getElementById('autodoc_details_37').style.display ? '' : 'none';">
    &lt;db_selector&gt;:add_order_by( expression )
  </div>
  <div id="autodoc_details_37" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>db_selector =                <span class="autodoc_comment_tail">-- same selector returned</span>
&lt;db_selector&gt;:add_order_by(
  expression                 <span class="autodoc_comment_tail">-- expression as passed to &quot;assemble_command&quot;</span>
)</pre>
    </div>
    <div class="autodoc_comment">Adds expressions for ORDER BY clause to the selector. The selector is modified and returned.    </div>
    <div class="autodoc_source">
<pre>function selector_prototype:add_order_by(expression)
  add(self._order_by, expression)
  return self
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_38').style.display = document.getElementById('autodoc_details_38').style.display ? '' : 'none';">
    &lt;db_selector&gt;:add_where( expression )
  </div>
  <div id="autodoc_details_38" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>db_selector =             <span class="autodoc_comment_tail">-- same selector returned</span>
&lt;db_selector&gt;:add_where(
  expression              <span class="autodoc_comment_tail">-- expression as passed to &quot;assemble_command&quot;</span>
)</pre>
    </div>
    <div class="autodoc_comment">Adds expressions for WHERE clause to the selector. The selector is modified and returned. Multiple calls cause expressions to be AND-combined.    </div>
    <div class="autodoc_source">
<pre>function selector_prototype:add_where(expression)
  add(self._where, expression)
  return self
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_39').style.display = document.getElementById('autodoc_details_39').style.display ? '' : 'none';">
    &lt;db_selector&gt;:add_with( expression = expression, selector = selector )
  </div>
  <div id="autodoc_details_39" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>db_selector =
&lt;db_selector&gt;:add_with(
  expression = expression,
  selector   = selector
)</pre>
    </div>
    <div class="autodoc_comment">Adds an WITH RECURSIVE expression to the selector. The selector is modified and returned.    </div>
    <div class="autodoc_source">
<pre>function selector_prototype:add_with(expression, selector)
  add(self._with, {&quot;$ AS ($)&quot;, {expression}, {selector}})
  return self
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_40').style.display = document.getElementById('autodoc_details_40').style.display ? '' : 'none';">
    &lt;db_selector&gt;:attach{ ... }
  </div>
  <div id="autodoc_details_40" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>db_selector =          <span class="autodoc_comment_tail">-- same selector returned</span>
&lt;db_selector&gt;:attach(
  mode,                <span class="autodoc_comment_tail">-- attachment type: &quot;11&quot; one to one, &quot;1m&quot; one to many, &quot;m1&quot; many to one</span>
  data2,               <span class="autodoc_comment_tail">-- other database result list or object, the results of this selector shall be attached with</span>
  field1,              <span class="autodoc_comment_tail">-- field name(s) in result list or object of this selector used for attaching</span>
  field2,              <span class="autodoc_comment_tail">-- field name(s) in &quot;data2&quot; used for attaching</span>
  ref1,                <span class="autodoc_comment_tail">-- name of reference field in the results of this selector after attaching</span>
  ref2                 <span class="autodoc_comment_tail">-- name of reference field in &quot;data2&quot; after attaching</span>
)</pre>
    </div>
    <div class="autodoc_comment">This method causes database result lists or objects of this selector to be attached with other database result lists after execution. This method does not need to be called directly.    </div>
    <div class="autodoc_source">
<pre>function selector_prototype:attach(mode, data2, field1, field2, ref1, ref2)
  self._attach = {
    mode = mode,
    data2 = data2,
    field1 = field1,
    field2 = field2,
    ref1 = ref1,
    ref2 = ref2
  }
  return self
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_41').style.display = document.getElementById('autodoc_details_41').style.display ? '' : 'none';">
    &lt;db_selector&gt;:count()
  </div>
  <div id="autodoc_details_41" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>count =                <span class="autodoc_comment_tail">-- number of rows returned</span>
&lt;db_selector&gt;:count()</pre>
    </div>
    <div class="autodoc_comment">This function wraps the given selector inside a subquery to count the number of rows returned by the database. NOTE: The result is cached inside the selector, thus the selector should NOT be modified afterwards.    </div>
    <div class="autodoc_source">
<pre>function selector_prototype:count()
  if not self._count then
    local count_selector = self:get_db_conn():new_selector()
    count_selector:add_field('count(1)')
    count_selector:add_from(self)
    count_selector:single_object_mode()
    self._count = count_selector:exec().count
  end
  return self._count
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_42').style.display = document.getElementById('autodoc_details_42').style.display ? '' : 'none';">
    &lt;db_selector&gt;:empty_list_mode()
  </div>
  <div id="autodoc_details_42" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>db_selector =                    <span class="autodoc_comment_tail">-- same selector returned</span>
&lt;db_selector&gt;:empty_list_mode()</pre>
    </div>
    <div class="autodoc_comment">Sets selector to empty list mode. The selector is modified and returned. When using the selector, no SQL query will be issued, but instead an empty database result list is returned.    </div>
    <div class="autodoc_source">
<pre>function selector_prototype:empty_list_mode()
  self._mode = &quot;empty_list&quot;
  return self
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_43').style.display = document.getElementById('autodoc_details_43').style.display ? '' : 'none';">
    &lt;db_selector&gt;:except( expression )
  </div>
  <div id="autodoc_details_43" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>db_selector =          <span class="autodoc_comment_tail">-- same selector returned</span>
&lt;db_selector&gt;:except(
  expression           <span class="autodoc_comment_tail">-- expression or selector without ORDER BY, LIMIT, FOR UPDATE or FOR SHARE</span>
)</pre>
    </div>
    <div class="autodoc_comment">This method adds an EXCEPT clause to the given selector. The selector is modified and returned. The selector (or expression) passed as argument to this function shall not contain any ORDER BY, LIMIT, FOR UPDATE or FOR SHARE clauses.    </div>
    <div class="autodoc_source">
<pre>function selector_prototype:except(expression)
  self:add_combine{&quot;EXCEPT $&quot;, {expression}}
  return self
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_44').style.display = document.getElementById('autodoc_details_44').style.display ? '' : 'none';">
    &lt;db_selector&gt;:except_all( expression )
  </div>
  <div id="autodoc_details_44" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>db_selector =              <span class="autodoc_comment_tail">-- same selector returned</span>
&lt;db_selector&gt;:except_all(
  expression               <span class="autodoc_comment_tail">-- expression or selector without ORDER BY, LIMIT, FOR UPDATE or FOR SHARE</span>
)</pre>
    </div>
    <div class="autodoc_comment">This method adds an EXCEPT ALL clause to the given selector. The selector is modified and returned. The selector (or expression) passed as argument to this function shall not contain any ORDER BY, LIMIT, FOR UPDATE or FOR SHARE clauses.    </div>
    <div class="autodoc_source">
<pre>function selector_prototype:except_all(expression)
  self:add_combine{&quot;EXCEPT ALL $&quot;, {expression}}
  return self
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_45').style.display = document.getElementById('autodoc_details_45').style.display ? '' : 'none';">
    &lt;db_selector&gt;:exec()
  </div>
  <div id="autodoc_details_45" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>result =              <span class="autodoc_comment_tail">-- database result list or object</span>
&lt;db_selector&gt;:exec()</pre>
    </div>
    <div class="autodoc_comment">This method executes the selector on its database. The result list or object is returned on success, otherwise an error is thrown.    </div>
    <div class="autodoc_source">
<pre>function selector_prototype:exec()
  local db_error, result = self:try_exec()
  if db_error then
    db_error:escalate()
  else
    return result
  end
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_46').style.display = document.getElementById('autodoc_details_46').style.display ? '' : 'none';">
    &lt;db_selector&gt;:for_share()
  </div>
  <div id="autodoc_details_46" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>db_selector =              <span class="autodoc_comment_tail">-- same selector returned</span>
&lt;db_selector&gt;:for_share()</pre>
    </div>
    <div class="autodoc_comment">Adds FOR SHARE to the statement, to share-lock all rows read. The selector is modified and returned.    </div>
    <div class="autodoc_source">
<pre>function selector_prototype:for_share()
  self._read_lock.all = true
  return self
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_47').style.display = document.getElementById('autodoc_details_47').style.display ? '' : 'none';">
    &lt;db_selector&gt;:for_share_of( expression )
  </div>
  <div id="autodoc_details_47" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>db_selector =                <span class="autodoc_comment_tail">-- same selector returned</span>
&lt;db_selector&gt;:for_share_of(
  expression                 <span class="autodoc_comment_tail">-- expression as passed to &quot;assemble_command&quot;</span>
)</pre>
    </div>
    <div class="autodoc_comment">Adds FOR SHARE OF to the statement, to share-lock all rows read by the named table(s). The selector is modified and returned.    </div>
    <div class="autodoc_source">
<pre>function selector_prototype:for_share_of(expression)
  add(self._read_lock, expression)
  return self
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_48').style.display = document.getElementById('autodoc_details_48').style.display ? '' : 'none';">
    &lt;db_selector&gt;:for_update()
  </div>
  <div id="autodoc_details_48" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>db_selector =               <span class="autodoc_comment_tail">-- same selector returned</span>
&lt;db_selector&gt;:for_update()</pre>
    </div>
    <div class="autodoc_comment">Adds FOR UPDATE to the statement, to exclusivly lock all rows read. The selector is modified and returned.    </div>
    <div class="autodoc_source">
<pre>function selector_prototype:for_update()
  self._write_lock.all = true
  return self
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_49').style.display = document.getElementById('autodoc_details_49').style.display ? '' : 'none';">
    &lt;db_selector&gt;:for_update_of( expression )
  </div>
  <div id="autodoc_details_49" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>db_selector =                 <span class="autodoc_comment_tail">-- same selector returned</span>
&lt;db_selector&gt;:for_update_of(
  expression                  <span class="autodoc_comment_tail">-- expression as passed to &quot;assemble_command&quot;</span>
)</pre>
    </div>
    <div class="autodoc_comment">Adds FOR SHARE OF to the statement, to exclusivly lock all rows read by the named table(s). The selector is modified and returned.    </div>
    <div class="autodoc_source">
<pre>function selector_prototype:for_update_of(expression)
  add(self._write_lock, expression)
  return self
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_50').style.display = document.getElementById('autodoc_details_50').style.display ? '' : 'none';">
    &lt;db_selector&gt;:from( expression, alias, condition )
  </div>
  <div id="autodoc_details_50" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>db_selector =        <span class="autodoc_comment_tail">-- same selector returned</span>
&lt;db_selector&gt;:from(
  expression,        <span class="autodoc_comment_tail">-- expression as passed to &quot;assemble_command&quot;</span>
  alias,             <span class="autodoc_comment_tail">-- optional alias expression as passed to &quot;assemble_command&quot;</span>
  condition          <span class="autodoc_comment_tail">-- optional condition expression as passed to &quot;assemble_command&quot;</span>
)</pre>
    </div>
    <div class="autodoc_comment">Adds the first expression for FROM clause to the selector. The selector is modified and returned. If an additional condition is given, an INNER JOIN will be used, otherwise a CROSS JOIN.<br/><br/>This method is identical to &quot;add_from&quot; or &quot;join&quot;, except that an error is thrown, if there is already any FROM expression existent.    </div>
    <div class="autodoc_source">
<pre>function selector_prototype:from(expression, alias, condition)
  if #self._from &gt; 0 then
    error(&quot;From-clause already existing (hint: try join).&quot;)
  end
  return self:join(expression, alias, condition)
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_51').style.display = document.getElementById('autodoc_details_51').style.display ? '' : 'none';">
    &lt;db_selector&gt;:get_db_conn()
  </div>
  <div id="autodoc_details_51" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>db_handle =                  <span class="autodoc_comment_tail">-- handle of database connection</span>
&lt;db_selector&gt;:get_db_conn()</pre>
    </div>
    <div class="autodoc_comment">Returns the database connection handle used by a selector.    </div>
    <div class="autodoc_source">
<pre>function selector_prototype:get_db_conn()
  return self._db_conn
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_52').style.display = document.getElementById('autodoc_details_52').style.display ? '' : 'none';">
    &lt;db_selector&gt;:intersect( expression )
  </div>
  <div id="autodoc_details_52" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>db_selector =             <span class="autodoc_comment_tail">-- same selector returned</span>
&lt;db_selector&gt;:intersect(
  expression              <span class="autodoc_comment_tail">-- expression or selector without ORDER BY, LIMIT, FOR UPDATE or FOR SHARE</span>
)</pre>
    </div>
    <div class="autodoc_comment">This method adds an INTERSECT clause to the given selector. The selector is modified and returned. The selector (or expression) passed as argument to this function shall not contain any ORDER BY, LIMIT, FOR UPDATE or FOR SHARE clauses.    </div>
    <div class="autodoc_source">
<pre>function selector_prototype:intersect(expression)
  self:add_combine{&quot;INTERSECT $&quot;, {expression}}
  return self
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_53').style.display = document.getElementById('autodoc_details_53').style.display ? '' : 'none';">
    &lt;db_selector&gt;:intersect_all( expression )
  </div>
  <div id="autodoc_details_53" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>db_selector =                 <span class="autodoc_comment_tail">-- same selector returned</span>
&lt;db_selector&gt;:intersect_all(
  expression                  <span class="autodoc_comment_tail">-- expression or selector without ORDER BY, LIMIT, FOR UPDATE or FOR SHARE</span>
)</pre>
    </div>
    <div class="autodoc_comment">This method adds an INTERSECT ALL clause to the given selector. The selector is modified and returned. The selector (or expression) passed as argument to this function shall not contain any ORDER BY, LIMIT, FOR UPDATE or FOR SHARE clauses.    </div>
    <div class="autodoc_source">
<pre>function selector_prototype:intersect_all(expression)
  self:add_combine{&quot;INTERSECT ALL $&quot;, {expression}}
  return self
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_54').style.display = document.getElementById('autodoc_details_54').style.display ? '' : 'none';">
    &lt;db_selector&gt;:join( expression, alias, condition )
  </div>
  <div id="autodoc_details_54" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>db_selector =        <span class="autodoc_comment_tail">-- same selector returned</span>
&lt;db_selector&gt;:join(
  expression,        <span class="autodoc_comment_tail">-- expression as passed to &quot;assemble_command&quot;</span>
  alias,             <span class="autodoc_comment_tail">-- optional alias expression as passed to &quot;assemble_command&quot;</span>
  condition          <span class="autodoc_comment_tail">-- optional condition expression as passed to &quot;assemble_command&quot;</span>
)</pre>
    </div>
    <div class="autodoc_comment">Adds expressions for FROM clause to the selector. The selector is modified and returned. If an additional condition is given, an INNER JOIN will be used, otherwise a CROSS JOIN.<br/><br/>This method is identical to &quot;add_from&quot;.    </div>
    <div class="autodoc_source">
<pre>function selector_prototype:join(...)  <span class="autodoc_comment_tail">-- NOTE: alias for add_from</span>
  return self:add_from(...)
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_55').style.display = document.getElementById('autodoc_details_55').style.display ? '' : 'none';">
    &lt;db_selector&gt;:left_join( expression, alias, condition )
  </div>
  <div id="autodoc_details_55" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>db_selector =             <span class="autodoc_comment_tail">-- same selector returned</span>
&lt;db_selector&gt;:left_join(
  expression,             <span class="autodoc_comment_tail">-- expression as passed to &quot;assemble_command&quot;</span>
  alias,                  <span class="autodoc_comment_tail">-- optional alias expression as passed to &quot;assemble_command&quot;</span>
  condition               <span class="autodoc_comment_tail">-- optional condition expression as passed to &quot;assemble_command&quot;</span>
)</pre>
    </div>
    <div class="autodoc_comment">Adds expressions for FROM clause to the selector using a LEFT OUTER JOIN. The selector is modified and returned.    </div>
    <div class="autodoc_source">
<pre>function selector_prototype:left_join(expression, alias, condition)
  local first = (#self._from == 0)
  if not first then
    add(self._from, &quot;LEFT OUTER JOIN&quot;)
  end
  if alias then
    add(self._from, {'$ AS &quot;$&quot;', {expression}, {alias}})
  else
    add(self._from, expression)
  end
  if condition then
    if first then
      self:add_where(condition)
    else
      add(self._from, &quot;ON&quot;)
      add(self._from, condition)
    end
  end
  return self
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_56').style.display = document.getElementById('autodoc_details_56').style.display ? '' : 'none';">
    &lt;db_selector&gt;:limit( count )
  </div>
  <div id="autodoc_details_56" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>db_selector =         <span class="autodoc_comment_tail">-- same selector returned</span>
&lt;db_selector&gt;:limit(
  count               <span class="autodoc_comment_tail">-- integer used as LIMIT</span>
)</pre>
    </div>
    <div class="autodoc_comment">Limits the number of rows to a given number, by using LIMIT. The selector is modified and returned.    </div>
    <div class="autodoc_source">
<pre>function selector_prototype:limit(count)
  if type(count) ~= &quot;number&quot; or count % 1 ~= 0 then
    error(&quot;LIMIT must be an integer.&quot;)
  end
  self._limit = count
  return self
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_57').style.display = document.getElementById('autodoc_details_57').style.display ? '' : 'none';">
    &lt;db_selector&gt;:offset( count )
  </div>
  <div id="autodoc_details_57" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>db_selector =          <span class="autodoc_comment_tail">-- same selector returned</span>
&lt;db_selector&gt;:offset(
  count                <span class="autodoc_comment_tail">-- integer used as OFFSET</span>
)</pre>
    </div>
    <div class="autodoc_comment">Skips a given number of rows, by using OFFSET. The selector is modified and returned.    </div>
    <div class="autodoc_source">
<pre>function selector_prototype:offset(count)
  if type(count) ~= &quot;number&quot; or count % 1 ~= 0 then
    error(&quot;OFFSET must be an integer.&quot;)
  end
  self._offset = count
  return self
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_58').style.display = document.getElementById('autodoc_details_58').style.display ? '' : 'none';">
    &lt;db_selector&gt;:optional_object_mode()
  </div>
  <div id="autodoc_details_58" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>db_selector =                         <span class="autodoc_comment_tail">-- same selector returned</span>
&lt;db_selector&gt;:optional_object_mode()</pre>
    </div>
    <div class="autodoc_comment">Sets selector to single object mode (mode &quot;opt_object&quot; passed to &quot;query&quot; method of database handle). The selector is modified and returned.    </div>
    <div class="autodoc_source">
<pre>function selector_prototype:optional_object_mode()
  self._mode = &quot;opt_object&quot;
  return self
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_59').style.display = document.getElementById('autodoc_details_59').style.display ? '' : 'none';">
    &lt;db_selector&gt;:reset_fields()
  </div>
  <div id="autodoc_details_59" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>db_selector =                 <span class="autodoc_comment_tail">-- same selector returned</span>
&lt;db_selector&gt;:reset_fields()</pre>
    </div>
    <div class="autodoc_comment">This method removes all fields added by method &quot;add_field&quot;. The selector is modified and returned.    </div>
    <div class="autodoc_source">
<pre>function selector_prototype:reset_fields()
  for idx in ipairs(self._fields) do
    self._fields[idx] = nil
  end
  return self
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_60').style.display = document.getElementById('autodoc_details_60').style.display ? '' : 'none';">
    &lt;db_selector&gt;:set_class( class )
  </div>
  <div id="autodoc_details_60" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>db_selector =             <span class="autodoc_comment_tail">-- same selector returned</span>
&lt;db_selector&gt;:set_class(
  class                   <span class="autodoc_comment_tail">-- database class (model)</span>
)</pre>
    </div>
    <div class="autodoc_comment">This method makes the selector to return database result lists or objects of the given database class (model). The selector is modified and returned.    </div>
    <div class="autodoc_source">
<pre>function selector_prototype:set_class(class)
  self._class = class
  return self
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_61').style.display = document.getElementById('autodoc_details_61').style.display ? '' : 'none';">
    &lt;db_selector&gt;:set_distinct()
  </div>
  <div id="autodoc_details_61" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>db_selector =                <span class="autodoc_comment_tail">-- same selector returned</span>
&lt;db_selector&gt;:set_distinct()</pre>
    </div>
    <div class="autodoc_comment">Sets selector to perform a SELECT DISTINCT instead of SELECT (ALL). The selector is modified and returned. This mode can not be combined with DISTINCT ON.    </div>
    <div class="autodoc_source">
<pre>function selector_prototype:set_distinct()
  if #self._distinct_on &gt; 0 then
    error(&quot;Can not combine DISTINCT with DISTINCT ON.&quot;)
  end
  self._distinct = true
  return self
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_62').style.display = document.getElementById('autodoc_details_62').style.display ? '' : 'none';">
    &lt;db_selector&gt;:single_object_mode()
  </div>
  <div id="autodoc_details_62" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>db_selector =                       <span class="autodoc_comment_tail">-- same selector returned</span>
&lt;db_selector&gt;:single_object_mode()</pre>
    </div>
    <div class="autodoc_comment">Sets selector to single object mode (mode &quot;object&quot; passed to &quot;query&quot; method of database handle). The selector is modified and returned.    </div>
    <div class="autodoc_source">
<pre>function selector_prototype:single_object_mode()
  self._mode = &quot;object&quot;
  return self
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_63').style.display = document.getElementById('autodoc_details_63').style.display ? '' : 'none';">
    &lt;db_selector&gt;:try_exec()
  </div>
  <div id="autodoc_details_63" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>db_error,                 <span class="autodoc_comment_tail">-- database error object, or nil in case of success</span>
result =                  <span class="autodoc_comment_tail">-- database result list or object</span>
&lt;db_selector&gt;:try_exec()</pre>
    </div>
    <div class="autodoc_comment">This method executes the selector on its database. First return value is an error object or nil in case of success. Second return value is the result list or object.    </div>
    <div class="autodoc_source">
<pre>function selector_prototype:try_exec()
  if self._mode == &quot;empty_list&quot; then
    if self._class then
      return nil, self._class:create_list()
    else
       return nil, self._db_conn:create_list()
    end
  end
  local db_error, db_result = self._db_conn:try_query(self, self._mode)
  if db_error then
    return db_error
  elseif db_result then
    if self._class then set_class(db_result, self._class) end
    if self._attach then
      attach(
        self._attach.mode,
        db_result,
        self._attach.data2,
        self._attach.field1,
        self._attach.field2,
        self._attach.ref1,
        self._attach.ref2
      )
    end
    return nil, db_result
  else
    return nil
  end
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_64').style.display = document.getElementById('autodoc_details_64').style.display ? '' : 'none';">
    &lt;db_selector&gt;:union( expression )
  </div>
  <div id="autodoc_details_64" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>db_selector =         <span class="autodoc_comment_tail">-- same selector returned</span>
&lt;db_selector&gt;:union(
  expression          <span class="autodoc_comment_tail">-- expression or selector without ORDER BY, LIMIT, FOR UPDATE or FOR SHARE</span>
)</pre>
    </div>
    <div class="autodoc_comment">This method adds an UNION clause to the given selector. The selector is modified and returned. The selector (or expression) passed as argument to this function shall not contain any ORDER BY, LIMIT, FOR UPDATE or FOR SHARE clauses.    </div>
    <div class="autodoc_source">
<pre>function selector_prototype:union(expression)
  self:add_combine{&quot;UNION $&quot;, {expression}}
  return self
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_65').style.display = document.getElementById('autodoc_details_65').style.display ? '' : 'none';">
    &lt;db_selector&gt;:union_all( expression )
  </div>
  <div id="autodoc_details_65" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>db_selector =             <span class="autodoc_comment_tail">-- same selector returned</span>
&lt;db_selector&gt;:union_all(
  expression              <span class="autodoc_comment_tail">-- expression or selector without ORDER BY, LIMIT, FOR UPDATE or FOR SHARE</span>
)</pre>
    </div>
    <div class="autodoc_comment">This method adds an UNION ALL clause to the given selector. The selector is modified and returned. The selector (or expression) passed as argument to this function shall not contain any ORDER BY, LIMIT, FOR UPDATE or FOR SHARE clauses.    </div>
    <div class="autodoc_source">
<pre>function selector_prototype:union_all(expression)
  self:add_combine{&quot;UNION ALL $&quot;, {expression}}
  return self
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_66').style.display = document.getElementById('autodoc_details_66').style.display ? '' : 'none';">
    app
  </div>
  <div id="autodoc_details_66" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>app  <span class="autodoc_comment_tail">-- table to store an application state</span></pre>
    </div>
    <div class="autodoc_comment">'app' is a global table for storing any application state data    </div>
    <div class="autodoc_source">
<pre>app = {}</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_67').style.display = document.getElementById('autodoc_details_67').style.display ? '' : 'none';">
    at_exit( func )
  </div>
  <div id="autodoc_details_67" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>at_exit(
  func  <span class="autodoc_comment_tail">-- function to be called before the process is ending</span>
)</pre>
    </div>
    <div class="autodoc_comment">Registers a function to be called before the CGI process is exiting.    </div>
    <div class="autodoc_source">
<pre>do
  local exit_handlers = {}
  function at_exit(func)
    table.insert(exit_handlers, func)
  end
  function exit(code)
    for i = #exit_handlers, 1, -1 do
      exit_handlers[i]()
    end
    os.exit(code)
  end
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_68').style.display = document.getElementById('autodoc_details_68').style.display ? '' : 'none';">
    atom.boolean:load( string )
  </div>
  <div id="autodoc_details_68" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>bool =              <span class="autodoc_comment_tail">-- true, false, or nil</span>
atom.boolean:load(
  string            <span class="autodoc_comment_tail">-- string to be interpreted as boolean</span>
)</pre>
    </div>
    <div class="autodoc_comment">This method returns true or false or nil, depending on the input string.    </div>
    <div class="autodoc_source">
<pre>function boolean:load(str)
  if str == nil or str == &quot;&quot; then
    return nil
  elseif type(str) ~= &quot;string&quot; then
    error(&quot;String expected&quot;)
  elseif string.find(str, &quot;^[TtYy1]&quot;) then
    return true
  elseif string.find(str, &quot;^[FfNn0]&quot;) then
    return false
  else
    return nil  <span class="autodoc_comment_tail">-- we don't have an undefined bool</span>
  end
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_69').style.display = document.getElementById('autodoc_details_69').style.display ? '' : 'none';">
    atom.date.invalid
  </div>
  <div id="autodoc_details_69" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>atom.date.invalid</pre>
    </div>
    <div class="autodoc_comment">Value representing an invalid date.    </div>
    <div class="autodoc_source">
<pre>date.invalid = date:_create{
  jd = not_a_number,
  year = not_a_number, month = not_a_number, day = not_a_number,
  invalid = true
}</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_70').style.display = document.getElementById('autodoc_details_70').style.display ? '' : 'none';">
    atom.date.jd_to_ymd( jd, )
  </div>
  <div id="autodoc_details_70" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>year,                 <span class="autodoc_comment_tail">-- year</span>
month,                <span class="autodoc_comment_tail">-- month from 1 to 12</span>
day =                 <span class="autodoc_comment_tail">-- day from 1 to 31</span>
atom.date.jd_to_ymd(
  jd,                 <span class="autodoc_comment_tail">-- days from January 1st 1970</span>
)</pre>
    </div>
    <div class="autodoc_comment">Given the days from January 1st 1970 this function returns year, month and day.    </div>
    <div class="autodoc_source">
<pre>function date.jd_to_ymd(jd)
  assert(is_integer(jd), &quot;Invalid julian date specified.&quot;)
  local calc_jd = jd + offset
  assert(is_integer(calc_jd), &quot;Julian date is out of range.&quot;)
  local n400 = math.floor(calc_jd / c400)
  local r400 = calc_jd % c400
  local n100 = math.floor(r400 / c100)
  local r100 = r400 % c100
  if n100 == 4 then n100, r100 = 3, c100 end
  local n4 = math.floor(r100 / c4)
  local r4 = r100 % c4
  local n1 = math.floor(r4 / c1)
  local r1 = r4 % c1
  if n1 == 4 then n1, r1 = 3, c1 end
  local year = 1 + 400 * n400 + 100 * n100 + 4 * n4 + n1
  local month = 1 + math.floor(r1 / 31)
  local month_offset = get_month_offset(year, month)
  if month &lt; 12 then
    local next_month_offset = get_month_offset(year, month + 1)
    if r1 &gt;= next_month_offset then
      month = month + 1
      month_offset = next_month_offset
    end
  end
  local day = 1 + r1 - month_offset
  return year, month, day
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_71').style.display = document.getElementById('autodoc_details_71').style.display ? '' : 'none';">
    atom.date.ymd_to_jd( year, month, day )
  </div>
  <div id="autodoc_details_71" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>jd =                  <span class="autodoc_comment_tail">-- days from January 1st 1970</span>
atom.date.ymd_to_jd(
  year,               <span class="autodoc_comment_tail">-- year</span>
  month,              <span class="autodoc_comment_tail">-- month from 1 to 12</span>
  day                 <span class="autodoc_comment_tail">-- day from 1 to 31</span>
)</pre>
    </div>
    <div class="autodoc_comment">This function calculates the days from January 1st 1970 for a given year, month and day.    </div>
    <div class="autodoc_source">
<pre>local offset = 0
function date.ymd_to_jd(year, month, day)
  assert(is_integer(year), &quot;Invalid year specified.&quot;)
  assert(is_integer(month), &quot;Invalid month specified.&quot;)
  assert(is_integer(day), &quot;Invalid day specified.&quot;)
  local calc_year = year - 1
  local n400 = math.floor(calc_year / 400)
  local r400 = calc_year % 400
  local n100 = math.floor(r400 / 100)
  local r100 = r400 % 100
  local n4 = math.floor(r100 / 4)
  local n1 = r100 % 4
  local jd = (
    c400 * n400 + c100 * n100 + c4 * n4 + c1 * n1 +
    get_month_offset(year, month) + (day - 1)
  )
  return jd - offset
end
offset = date.ymd_to_jd(1970, 1, 1)</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_72').style.display = document.getElementById('autodoc_details_72').style.display ? '' : 'none';">
    atom.date:get_current()
  </div>
  <div id="autodoc_details_72" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>atom.date:get_current()</pre>
    </div>
    <div class="autodoc_comment">This function returns today's date.    </div>
    <div class="autodoc_source">
<pre>function date:get_current()
  local now = os.date(&quot;*t&quot;)
  return date{
    year = now.year, month = now.month, day = now.day
  }
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_73').style.display = document.getElementById('autodoc_details_73').style.display ? '' : 'none';">
    atom.date:load( string )
  </div>
  <div id="autodoc_details_73" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>date =           <span class="autodoc_comment_tail">-- date represented by the string</span>
atom.date:load(
  string         <span class="autodoc_comment_tail">-- string representing a date</span>
)</pre>
    </div>
    <div class="autodoc_comment">This method returns a date represented by the given string.    </div>
    <div class="autodoc_source">
<pre>function date:load(str)
  if str == nil or str == &quot;&quot; then
    return nil
  elseif type(str) ~= &quot;string&quot; then
    error(&quot;String expected&quot;)
  else
    local year, month, day = string.match(
      str, &quot;^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$&quot;
    )
    if year then
      return date{
        year = tonumber(year),
        month = tonumber(month),
        day = tonumber(day)
      }
    else
      return date.invalid
    end
  end
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_74').style.display = document.getElementById('autodoc_details_74').style.display ? '' : 'none';">
    atom.date:new{ ... }
  </div>
  <div id="autodoc_details_74" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>d =                             <span class="autodoc_comment_tail">-- date based on the given data</span>
atom.date:new{
  jd           = jd,            <span class="autodoc_comment_tail">-- days since January 1st 1970</span>
  year         = year,          <span class="autodoc_comment_tail">-- year</span>
  month        = month,         <span class="autodoc_comment_tail">-- month from 1 to 12</span>
  day          = day,           <span class="autodoc_comment_tail">-- day from 1 to 31</span>
  iso_weekyear = iso_weekyear,  <span class="autodoc_comment_tail">-- year according to ISO 8601</span>
  iso_week     = iso_week,      <span class="autodoc_comment_tail">-- week number according to ISO 8601</span>
  iso_weekday  = iso_weekday,   <span class="autodoc_comment_tail">-- day of week from 1 for monday to 7 for sunday</span>
  us_weekyear  = us_weekyear,   <span class="autodoc_comment_tail">-- year</span>
  us_week      = us_week,       <span class="autodoc_comment_tail">-- week number according to US style counting</span>
  us_weekday   = us_weekday     <span class="autodoc_comment_tail">-- day of week from 1 for sunday to 7 for saturday</span>
}</pre>
    </div>
    <div class="autodoc_comment">This method returns a new date value, based on given data.    </div>
    <div class="autodoc_source">
<pre>function date:new(args)
  local args = args
  if type(args) == &quot;number&quot; then args = { jd = args } end
  if type(args) == &quot;table&quot; then
    local year, month, day = args.year, args.month, args.day
    local jd = args.jd
    local iso_weekyear = args.iso_weekyear
    local iso_week     = args.iso_week
    local iso_weekday  = args.iso_weekday
    local us_week      = args.us_week
    local us_weekday   = args.us_weekday
    if
      type(year)  == &quot;number&quot; and
      type(month) == &quot;number&quot; and
      type(day)   == &quot;number&quot;
    then
      if
        is_integer(year)  and year &gt;= 1  and year &lt;= 9999 and
        is_integer(month) and month &gt;= 1 and month &lt;= 12  and
        is_integer(day)   and day &gt;= 1   and day &lt;= 31
      then
        return date:_create{
          jd = date.ymd_to_jd(year, month, day),
          year = year, month = month, day = day
        }
      else
        return date.invalid
      end
    elseif type(jd) == &quot;number&quot; then
      if is_integer(jd) and jd &gt;= -719162 and jd &lt;= 2932896 then
        local year, month, day = date.jd_to_ymd(jd)
        return date:_create{
          jd = jd, year = year, month = month, day = day
        }
      else
        return date.invalid
      end
    elseif
      type(year)        == &quot;number&quot; and not iso_weekyear and
      type(iso_week)    == &quot;number&quot; and
      type(iso_weekday) == &quot;number&quot;
    then
      if
        is_integer(year) and
        is_integer(iso_week)     and iso_week &gt;= 0 and iso_week &lt;= 53 and
        is_integer(iso_weekday)  and iso_weekday &gt;= 1 and iso_weekday &lt;= 7
      then
        local jan4 = date{ year = year, month = 1, day = 4 }
        local reference = jan4 - jan4.iso_weekday - 7  <span class="autodoc_comment_tail">-- Sun. of week -1</span>
        return date(reference + 7 * iso_week + iso_weekday)
      else
        return date.invalid
      end
    elseif
      type(iso_weekyear) == &quot;number&quot; and not year and
      type(iso_week)     == &quot;number&quot; and
      type(iso_weekday)  == &quot;number&quot;
    then
      if
        is_integer(iso_weekyear) and
        is_integer(iso_week)     and iso_week &gt;= 0 and iso_week &lt;= 53 and
        is_integer(iso_weekday)  and iso_weekday &gt;= 1 and iso_weekday &lt;= 7
      then
        local guessed = date{
          year        = iso_weekyear,
          iso_week    = iso_week,
          iso_weekday = iso_weekday
        }
        if guessed.invalid or guessed.iso_weekyear == iso_weekyear then
          return guessed
        else
          local year
          if iso_week &lt;= 1 then
            year = iso_weekyear - 1
          elseif iso_week &gt;= 52 then
            year = iso_weekyear + 1
          else
            error(&quot;Internal error in ISO week computation occured.&quot;)
          end
          return date{
            year = year, iso_week = iso_week, iso_weekday = iso_weekday
          }
        end
      else
        return date.invalid
      end
    elseif
      type(year) == &quot;number&quot; and
      type(us_week)     == &quot;number&quot; and
      type(us_weekday)  == &quot;number&quot;
    then
      if
        is_integer(year) and
        is_integer(us_week)     and us_week &gt;= 0    and us_week &lt;= 54   and
        is_integer(us_weekday)  and us_weekday &gt;= 1 and us_weekday &lt;= 7
      then
        local jan1 = date{ year = year, month = 1, day = 1 }
        local reference = jan1 - jan1.us_weekday - 7  <span class="autodoc_comment_tail">-- Sat. of week -1</span>
        return date(reference + 7 * us_week + us_weekday)
      else
        return date.invalid
      end
    end
  end
  error(&quot;Illegal arguments passed to date constructor.&quot;)
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_75').style.display = document.getElementById('autodoc_details_75').style.display ? '' : 'none';">
    atom.dump( value )
  </div>
  <div id="autodoc_details_75" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>string =    <span class="autodoc_comment_tail">-- string representation to be passed to a load function</span>
atom.dump(
  value     <span class="autodoc_comment_tail">-- value to be dumped</span>
)</pre>
    </div>
    <div class="autodoc_comment">This function returns a string representation of the given value.    </div>
    <div class="autodoc_source">
<pre>function dump(obj)
  if obj == nil then
    return &quot;&quot;
  else
    return tostring(obj)
  end
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_76').style.display = document.getElementById('autodoc_details_76').style.display ? '' : 'none';">
    atom.fraction.invalid
  </div>
  <div id="autodoc_details_76" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>atom.fraction.invalid</pre>
    </div>
    <div class="autodoc_comment">Value representing an invalid fraction.    </div>
    <div class="autodoc_source">
<pre>fraction.invalid = fraction:_create{
  numerator = not_a_number, denominator = not_a_number, invalid = true
}</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_77').style.display = document.getElementById('autodoc_details_77').style.display ? '' : 'none';">
    atom.fraction:load( string )
  </div>
  <div id="autodoc_details_77" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>frac =               <span class="autodoc_comment_tail">-- fraction represented by the given string</span>
atom.fraction:load(
  string             <span class="autodoc_comment_tail">-- string representation of a fraction</span>
)</pre>
    </div>
    <div class="autodoc_comment">This method returns a fraction represented by the given string.    </div>
    <div class="autodoc_source">
<pre>function fraction:load(str)
  if str == nil or str == &quot;&quot; then
    return nil
  elseif type(str) ~= &quot;string&quot; then
    error(&quot;String expected&quot;)
  else
    local sign, int = string.match(str, &quot;^(%-?)([0-9]+)$&quot;)
    if sign == &quot;&quot; then return fraction:new(tonumber(int))
    elseif sign == &quot;-&quot; then return fraction:new(- tonumber(int))
    end
    local sign, n, d = string.match(str, &quot;^(%-?)([0-9]+)/([0-9]+)$&quot;)
    if sign == &quot;&quot; then return fraction:new(tonumber(n), tonumber(d))
    elseif sign == &quot;-&quot; then return fraction:new(- tonumber(n), tonumber(d))
    end
    return fraction.invalid
  end
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_78').style.display = document.getElementById('autodoc_details_78').style.display ? '' : 'none';">
    atom.fraction:new( numerator, denominator )
  </div>
  <div id="autodoc_details_78" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>frac =              <span class="autodoc_comment_tail">-- fraction</span>
atom.fraction:new(
  numerator,        <span class="autodoc_comment_tail">-- numerator</span>
  denominator       <span class="autodoc_comment_tail">-- denominator</span>
)</pre>
    </div>
    <div class="autodoc_comment">This method creates a new fraction.    </div>
    <div class="autodoc_source">
<pre>function fraction:new(numerator, denominator)
  if not (
    (numerator == nil   or type(numerator)   == &quot;number&quot;) and
    (denominator == nil or type(denominator) == &quot;number&quot;)
  ) then
    error(&quot;Invalid arguments passed to fraction constructor.&quot;)
  elseif
    (not is_integer(numerator)) or
    (denominator and (not is_integer(denominator)))
  then
    return fraction.invalid
  elseif denominator then
    if denominator == 0 then
      return fraction.invalid
    elseif numerator == 0 then
      return fraction:_create{ numerator = 0, denominator = 1, float = 0 }
    else
      local d = gcd(math.abs(numerator), math.abs(denominator))
      if denominator &lt; 0 then d = -d end
      local numerator2, denominator2 = numerator / d, denominator / d
      return fraction:_create{
        numerator   = numerator2,
        denominator = denominator2,
        float       = numerator2 / denominator2
      }
    end
  else
    return fraction:_create{
      numerator = numerator, denominator = 1, float = numerator
    }
  end
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_79').style.display = document.getElementById('autodoc_details_79').style.display ? '' : 'none';">
    atom.gcd( a, b, ... )
  </div>
  <div id="autodoc_details_79" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>i =        <span class="autodoc_comment_tail">-- the greatest common divisor (GCD) of all given natural numbers</span>
atom.gcd(
  a,      <span class="autodoc_comment_tail">-- a natural number</span>
  b,      <span class="autodoc_comment_tail">-- another natural number</span>
  ...     <span class="autodoc_comment_tail">-- optionally more natural numbers</span>
)</pre>
    </div>
    <div class="autodoc_comment">This function returns the greatest common divisor (GCD) of two or more natural numbers.    </div>
    <div class="autodoc_source">
<pre>function gcd(a, b, ...)
  if a % 1 ~= 0 or a &lt;= 0 then return 0 / 0 end
  if b == nil then
    return a
  else
    if b % 1 ~= 0 or b &lt;= 0 then return 0 / 0 end
    if ... == nil then
      local k = 0
      local t
      while a % 2 == 0 and b % 2 == 0 do
        a = a / 2; b = b / 2; k = k + 1
      end
      if a % 2 == 0 then t = a else t = -b end
      while t ~= 0 do
        while t % 2 == 0 do t = t / 2 end
        if t &gt; 0 then a = t else b = -t end
        t = a - b
      end
      return a * 2 ^ k
    else
      return gcd(gcd(a, b), ...)
    end
  end
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_80').style.display = document.getElementById('autodoc_details_80').style.display ? '' : 'none';">
    atom.has_type( value, t )
  </div>
  <div id="autodoc_details_80" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>bool =          <span class="autodoc_comment_tail">-- true, if 'value' is of type 't'</span>
atom.has_type(
  value,        <span class="autodoc_comment_tail">-- any value</span>
  t             <span class="autodoc_comment_tail">-- atom time, e.g. atom.date, or lua type, e.g. &quot;string&quot;</span>
)</pre>
    </div>
    <div class="autodoc_comment">This function checks, if a value is of a given type. The value may be an invalid value though, e.g. atom.date.invalid.    </div>
    <div class="autodoc_source">
<pre>function has_type(value, t)
  if t == nil then error(&quot;No type passed to has_type(...) function.&quot;) end
  local lua_type = type(value)
  return
    lua_type == t or
    getmetatable(value) == t or
    (lua_type == &quot;boolean&quot; and t == _M.boolean) or
    (lua_type == &quot;string&quot; and t == _M.string) or (
      lua_type == &quot;number&quot; and
      (t == _M.number or (
        t == _M.integer and (
          not (value &lt;= 0 or value &gt;= 0) or (
            value % 1 == 0 and
            (value + 1) - value == 1 and
            value - (value - 1) == 1
          )
        )
      ))
    )
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_81').style.display = document.getElementById('autodoc_details_81').style.display ? '' : 'none';">
    atom.integer.invalid
  </div>
  <div id="autodoc_details_81" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>atom.integer.invalid</pre>
    </div>
    <div class="autodoc_comment">This represents an invalid integer.    </div>
    <div class="autodoc_source">
<pre>integer.invalid = not_a_number
<span class="autodoc_comment_tail">--//</span>



<span class="autodoc_comment_tail">------------</span>
<span class="autodoc_comment_tail">-- number --</span>
<span class="autodoc_comment_tail">------------</span>

number = create_new_type(&quot;number&quot;)

<span class="autodoc_comment_tail">--[[--</span>
int =              <span class="autodoc_comment_tail">-- a number or atom.number.invalid (atom.not_a_number)</span>
atom.number:load(
  string           <span class="autodoc_comment_tail">-- a string representing a number</span>
)

This method returns a number represented by the given string. If the string doesn't represent a valid number, then not-a-number is returned.

<span class="autodoc_comment_tail">--]]--</span>
function number:load(str)
  if str == nil or str == &quot;&quot; then
    return nil
  elseif type(str) ~= &quot;string&quot; then
    error(&quot;String expected&quot;)
  else
    return tonumber(str) or not_a_number
  end
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_82').style.display = document.getElementById('autodoc_details_82').style.display ? '' : 'none';">
    atom.integer:load( string )
  </div>
  <div id="autodoc_details_82" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>int =              <span class="autodoc_comment_tail">-- an integer or atom.integer.invalid (atom.not_a_number)</span>
atom.integer:load(
  string           <span class="autodoc_comment_tail">-- a string representing an integer</span>
)</pre>
    </div>
    <div class="autodoc_comment">This method returns an integer represented by the given string. If the string doesn't represent a valid integer, then not-a-number is returned.    </div>
    <div class="autodoc_source">
<pre>function integer:load(str)
  if str == nil or str == &quot;&quot; then
    return nil
  elseif type(str) ~= &quot;string&quot; then
    error(&quot;String expected&quot;)
  else
    local num = tonumber(str)
    if is_integer(num) then return num else return not_a_number end
  end
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_83').style.display = document.getElementById('autodoc_details_83').style.display ? '' : 'none';">
    atom.is_integer( value )
  </div>
  <div id="autodoc_details_83" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>bool =            <span class="autodoc_comment_tail">-- true, if value is an integer within resolution</span>
atom.is_integer(
  value           <span class="autodoc_comment_tail">-- value to be tested</span>
)</pre>
    </div>
    <div class="autodoc_comment">This function returns true if the given object is an integer within resolution.    </div>
    <div class="autodoc_source">
<pre>function is_integer(i)
  return
    type(i) == &quot;number&quot; and i % 1 == 0 and
    (i + 1) - i == 1 and i - (i - 1) == 1
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_84').style.display = document.getElementById('autodoc_details_84').style.display ? '' : 'none';">
    atom.is_valid( value, t )
  </div>
  <div id="autodoc_details_84" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>bool =          <span class="autodoc_comment_tail">-- true, if 'value' is of type 't'</span>
atom.is_valid(
  value,        <span class="autodoc_comment_tail">-- any value</span>
  t             <span class="autodoc_comment_tail">-- atom time, e.g. atom.date, or lua type, e.g. &quot;string&quot;</span>
)</pre>
    </div>
    <div class="autodoc_comment">This function checks, if a value is valid. It optionally checks, if the value is of a given type.    </div>
    <div class="autodoc_source">
<pre>function is_valid(value, t)
  local lua_type = type(value)
  if lua_type == &quot;table&quot; then
    local mt = getmetatable(value)
    if t then
      return t == mt and not value.invalid
    else
      return (getmetatable(mt) == type_mt) and not value.invalid
    end
  elseif lua_type == &quot;boolean&quot; then
    return not t or t == &quot;boolean&quot; or t == _M.boolean
  elseif lua_type == &quot;string&quot; then
    return not t or t == &quot;string&quot; or t == _M.string
  elseif lua_type == &quot;number&quot; then
    if t == _M.integer then
      return
        value % 1 == 0 and
        (value + 1) - value == 1 and
        value - (value - 1) == 1
    else
      return
        (not t or t == &quot;number&quot; or t == _M.number) and
        (value &lt;= 0 or value &gt;= 0)
    end
  else
    return false
  end
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_85').style.display = document.getElementById('autodoc_details_85').style.display ? '' : 'none';">
    atom.lcm( a, b, ... )
  </div>
  <div id="autodoc_details_85" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>i =        <span class="autodoc_comment_tail">--the least common multiple (LCD) of all given natural numbers</span>
atom.lcm(
  a,       <span class="autodoc_comment_tail">-- a natural number</span>
  b,       <span class="autodoc_comment_tail">-- another natural number</span>
  ...      <span class="autodoc_comment_tail">-- optionally more natural numbers</span>
)</pre>
    </div>
    <div class="autodoc_comment">This function returns the least common multiple (LCD) of two or more natural numbers.    </div>
    <div class="autodoc_source">
<pre>function lcm(a, b, ...)
  if a % 1 ~= 0 or a &lt;= 0 then return 0 / 0 end
  if b == nil then
    return a
  else
    if b % 1 ~= 0 or b &lt;= 0 then return 0 / 0 end
    if ... == nil then
      return a * b / gcd(a, b)
    else
      return lcm(lcm(a, b), ...)
    end
  end
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_86').style.display = document.getElementById('autodoc_details_86').style.display ? '' : 'none';">
    atom.not_a_number
  </div>
  <div id="autodoc_details_86" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>atom.not_a_number</pre>
    </div>
    <div class="autodoc_comment">Value representing an invalid numeric result. Used for atom.integer.invalid and atom.number.invalid.    </div>
    <div class="autodoc_source">
<pre>not_a_number = 0 / 0</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_87').style.display = document.getElementById('autodoc_details_87').style.display ? '' : 'none';">
    atom.number.invalid
  </div>
  <div id="autodoc_details_87" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>atom.number.invalid</pre>
    </div>
    <div class="autodoc_comment">This represents an invalid number.    </div>
    <div class="autodoc_source">
<pre>number.invalid = not_a_number</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_88').style.display = document.getElementById('autodoc_details_88').style.display ? '' : 'none';">
    atom.string:load( string )
  </div>
  <div id="autodoc_details_88" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>string =            <span class="autodoc_comment_tail">-- the same string</span>
atom.string:load(
  string            <span class="autodoc_comment_tail">-- a string</span>
)</pre>
    </div>
    <div class="autodoc_comment">This method returns the passed string, or throws an error, if the passed argument is not a string.    </div>
    <div class="autodoc_source">
<pre>function _M.string:load(str)
  if str == nil then
    return nil
  elseif type(str) ~= &quot;string&quot; then
    error(&quot;String expected&quot;)
  else
    return str
  end
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_89').style.display = document.getElementById('autodoc_details_89').style.display ? '' : 'none';">
    atom.time:get_current()
  </div>
  <div id="autodoc_details_89" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>t =                      <span class="autodoc_comment_tail">-- current time of day</span>
atom.time:get_current()</pre>
    </div>
    <div class="autodoc_comment">This method returns the current time of the day.    </div>
    <div class="autodoc_source">
<pre>function time:get_current()
  local now = os.date(&quot;*t&quot;)
  return time{ hour = now.hour, minute = now.min, second = now.sec }
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_90').style.display = document.getElementById('autodoc_details_90').style.display ? '' : 'none';">
    atom.time:load( string )
  </div>
  <div id="autodoc_details_90" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>t =              <span class="autodoc_comment_tail">-- time represented by the string</span>
atom.time:load(
  string         <span class="autodoc_comment_tail">-- string representing a time of day</span>
)</pre>
    </div>
    <div class="autodoc_comment">This method returns a time represented by the given string.    </div>
    <div class="autodoc_source">
<pre>function time:load(str)
  if str == nil or str == &quot;&quot; then
    return nil
  elseif type(str) ~= &quot;string&quot; then
    error(&quot;String expected&quot;)
  else
    local hour, minute, second = string.match(
      str,
      &quot;^([0-9][0-9]):([0-9][0-9]):([0-9][0-9])$&quot;
    )
    if hour then
      return time{
        hour   = tonumber(hour),
        minute = tonumber(minute),
        second = tonumber(second)
      }
    else
      return time.invalid
    end
  end
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_91').style.display = document.getElementById('autodoc_details_91').style.display ? '' : 'none';">
    atom.time:new{ ... }
  </div>
  <div id="autodoc_details_91" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>t =                 <span class="autodoc_comment_tail">-- time based on given data</span>
atom.time:new{
  dsec = dsec,      <span class="autodoc_comment_tail">-- seconds since 00:00:00</span>
  hour = hour,      <span class="autodoc_comment_tail">-- hour from 0 to 23</span>
  minute = minute,  <span class="autodoc_comment_tail">-- minute from 0 to 59</span>
  second = second   <span class="autodoc_comment_tail">-- second from 0 to 59</span>
}</pre>
    </div>
    <div class="autodoc_comment">This method returns a new time value, based on given data.    </div>
    <div class="autodoc_source">
<pre>function time:new(args)
  local args = args
  if type(args) == &quot;number&quot; then args = { dsec = args } end
  if type(args) == &quot;table&quot; then
    if not args.second then
      args.second = 0
      if not args.minute then
        args.minute = 0
      end
    end
    if
      type(args.hour)   == &quot;number&quot; and
      type(args.minute) == &quot;number&quot; and
      type(args.second) == &quot;number&quot;
    then
      if
        is_integer(args.hour) and
        args.hour &gt;= 0 and args.hour &lt;= 23 and
        is_integer(args.minute) and
        args.minute &gt;= 0 and args.minute &lt;= 59 and
        is_integer(args.second) and
        args.second &gt;= 0 and args.second &lt;= 59
      then
        return time:_create{
          dsec = time.hms_to_dsec(args.hour, args.minute, args.second),
          hour   = args.hour,
          minute = args.minute,
          second = args.second
        }
      else
        return time.invalid
      end
    elseif type(args.dsec) == &quot;number&quot; then
      if
        is_integer(args.dsec) and
        args.dsec &gt;= 0 and args.dsec &lt;= 86399
      then
        local hour, minute, second =
          time.dsec_to_hms(args.dsec)
        return time:_create{
          dsec = args.dsec,
          hour = hour, minute = minute, second = second
        }
      else
        return time.invalid
      end
    end
  end
  error(&quot;Invalid arguments passed to time constructor.&quot;)
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_92').style.display = document.getElementById('autodoc_details_92').style.display ? '' : 'none';">
    atom.timestamp.tsec_to_ymdhms( tsec )
  </div>
  <div id="autodoc_details_92" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>year,                      <span class="autodoc_comment_tail">-- year</span>
month,                     <span class="autodoc_comment_tail">-- month from 1 to 12</span>
day,                       <span class="autodoc_comment_tail">-- day from 1 to 31</span>
hour,                      <span class="autodoc_comment_tail">-- hour from 0 to 23</span>
minute,                    <span class="autodoc_comment_tail">-- minute from 0 to 59</span>
second =                   <span class="autodoc_comment_tail">-- second from 0 to 59</span>
atom.timestamp.tsec_to_ymdhms(
  tsec                     <span class="autodoc_comment_tail">-- seconds since January 1st 1970 00:00</span>
)</pre>
    </div>
    <div class="autodoc_comment">Given the seconds since January 1st 1970 00:00, this function returns the year, month, day, hour, minute and second.    </div>
    <div class="autodoc_source">
<pre>function timestamp.tsec_to_ymdhms(tsec)
  local jd   = math.floor(tsec / 86400)
  local dsec = tsec % 86400
  local year, month, day = date.jd_to_ymd(jd)
  local hour   = math.floor(dsec / 3600)
  local minute = math.floor((dsec % 3600) / 60)
  local second = dsec % 60
  return year, month, day, hour, minute, second
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_93').style.display = document.getElementById('autodoc_details_93').style.display ? '' : 'none';">
    atom.timestamp.ymdhms_to_tsec{ ... }
  </div>
  <div id="autodoc_details_93" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>tsec =                          <span class="autodoc_comment_tail">-- seconds since January 1st 1970 00:00</span>
atom.timestamp.ymdhms_to_tsec(
  year,                         <span class="autodoc_comment_tail">-- year</span>
  month,                        <span class="autodoc_comment_tail">-- month from 1 to 12</span>
  day,                          <span class="autodoc_comment_tail">-- day from 1 to 31</span>
  hour,                         <span class="autodoc_comment_tail">-- hour from 0 to 23</span>
  minute,                       <span class="autodoc_comment_tail">-- minute from 0 to 59</span>
  second                        <span class="autodoc_comment_tail">-- second from 0 to 59</span>
)</pre>
    </div>
    <div class="autodoc_comment">Given the year, month, day, hour, minute and second, this function returns the number of seconds since January 1st 1970 00:00.    </div>
    <div class="autodoc_source">
<pre>function timestamp.ymdhms_to_tsec(year, month, day, hour, minute, second)
  return
    86400 * date.ymd_to_jd(year, month, day) +
    3600 * hour + 60 * minute + second
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_94').style.display = document.getElementById('autodoc_details_94').style.display ? '' : 'none';">
    atom.timestamp:get_current()
  </div>
  <div id="autodoc_details_94" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>ts =                          <span class="autodoc_comment_tail">-- current date/time as timestamp</span>
atom.timestamp:get_current()</pre>
    </div>
    <div class="autodoc_comment">This function returns the current date and time as timestamp.    </div>
    <div class="autodoc_source">
<pre>function timestamp:get_current()
  local now = os.date(&quot;*t&quot;)
  return timestamp{
    year = now.year, month = now.month, day = now.day,
    hour = now.hour, minute = now.min, second = now.sec
  }
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_95').style.display = document.getElementById('autodoc_details_95').style.display ? '' : 'none';">
    atom.timestamp:load( string )
  </div>
  <div id="autodoc_details_95" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>ts =             <span class="autodoc_comment_tail">-- timestamp represented by the string</span>
atom.timestamp:load(
  string         <span class="autodoc_comment_tail">-- string representing a timestamp</span>
)</pre>
    </div>
    <div class="autodoc_comment">This method returns a timestamp represented by the given string.    </div>
    <div class="autodoc_source">
<pre>function timestamp:load(str)
  if str == nil or str == &quot;&quot; then
    return nil
  elseif type(str) ~= &quot;string&quot; then
    error(&quot;String expected&quot;)
  else
    local year, month, day, hour, minute, second = string.match(
      str,
      &quot;^([0-9][0-9][0-9][0-9])%-([0-9][0-9])%-([0-9][0-9]) ([0-9][0-9]):([0-9][0-9]):([0-9][0-9])$&quot;
    )
    if year then
      return timestamp{
        year   = tonumber(year),
        month  = tonumber(month),
        day    = tonumber(day),
        hour   = tonumber(hour),
        minute = tonumber(minute),
        second = tonumber(second)
      }
    else
      return timestamp.invalid
    end
  end
end

function timestamp:__tostring()
  if self.invalid then
    return &quot;invalid_timestamp&quot;
  else
    return string.format(
      &quot;%04i-%02i-%02i %02i:%02i:%02i&quot;,
      self.year, self.month, self.day, self.hour, self.minute, self.second
    )
  end
end

function timestamp.getters:date()
  return date{ year = self.year, month = self.month, day = self.day }
end

function timestamp.getters:time()
  return time{
    hour = self.hour,
    minute = self.minute,
    second = self.second
  }
end

function timestamp.__eq(value1, value2)
  if value1.invalid or value2.invalid then
    return false
  else
    return value1.tsec == value2.tsec
  end
end

function timestamp.__lt(value1, value2)
  if value1.invalid or value2.invalid then
    return false
  else
    return value1.tsec &lt; value2.tsec
  end
end

function timestamp.__le(value1, value2)
  if value1.invalid or value2.invalid then
    return false
  else
    return value1.tsec &lt;= value2.tsec
  end
end

function timestamp.__add(value1, value2)
  if getmetatable(value1) == timestamp then
    if getmetatable(value2) == timestamp then
      error(&quot;Can not add two timestamps.&quot;)
    elseif type(value2) == &quot;number&quot; then
      return timestamp(value1.tsec + value2)
    else
      error(&quot;Right operand of '+' operator has wrong type.&quot;)
    end
  elseif type(value1) == &quot;number&quot; then
    if getmetatable(value2) == timestamp then
      return timestamp(value1 + value2.tsec)
    else
      error(&quot;Assertion failed&quot;)
    end
  else
    error(&quot;Left operand of '+' operator has wrong type.&quot;)
  end
end

function timestamp.__sub(value1, value2)
  if not getmetatable(value1) == timestamp then
    error(&quot;Left operand of '-' operator has wrong type.&quot;)
  end
  if getmetatable(value2) == timestamp then
    return value1.tsec - value2.tsec  <span class="autodoc_comment_tail">-- TODO: transform to interval</span>
  elseif type(value2) == &quot;number&quot; then
    return timestamp(value1.tsec - value2)
  else
    error(&quot;Right operand of '-' operator has wrong type.&quot;)
  end
end



<span class="autodoc_comment_tail">----------</span>
<span class="autodoc_comment_tail">-- time --</span>
<span class="autodoc_comment_tail">----------</span>

time = create_new_type(&quot;time&quot;)

function time.hms_to_dsec(hour, minute, second)
  return 3600 * hour + 60 * minute + second
end

function time.dsec_to_hms(dsec)
  local hour   = math.floor(dsec / 3600)
  local minute = math.floor((dsec % 3600) / 60)
  local second = dsec % 60
  return hour, minute, second
end

<span class="autodoc_comment_tail">--[[--</span>
atom.time.invalid

Value representing an invalid time of day.

<span class="autodoc_comment_tail">--]]--</span>
time.invalid = time:_create{
  dsec = not_a_number,
  hour = not_a_number, minute = not_a_number, second = not_a_number,
  invalid = true
}</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_96').style.display = document.getElementById('autodoc_details_96').style.display ? '' : 'none';">
    atom.timestamp:new{ ... }
  </div>
  <div id="autodoc_details_96" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>ts =                 <span class="autodoc_comment_tail">-- timestamp based on given data</span>
atom.timestamp:new{
  tsec   = tsec,     <span class="autodoc_comment_tail">-- seconds since January 1st 1970 00:00</span>
  year   = year,     <span class="autodoc_comment_tail">-- year</span>
  month  = month,    <span class="autodoc_comment_tail">-- month from 1 to 12</span>
  day    = day,      <span class="autodoc_comment_tail">-- day from 1 to 31</span>
  hour   = hour,     <span class="autodoc_comment_tail">-- hour from 0 to 23</span>
  minute = minute,   <span class="autodoc_comment_tail">-- minute from 0 to 59</span>
  second = second    <span class="autodoc_comment_tail">-- second from 0 to 59</span>
}</pre>
    </div>
    <div class="autodoc_comment">This method returns a new timestamp value, based on given data.    </div>
    <div class="autodoc_source">
<pre>function timestamp:new(args)
  local args = args
  if type(args) == &quot;number&quot; then args = { tsec = args } end
  if type(args) == &quot;table&quot; then
    if not args.second then
      args.second = 0
      if not args.minute then
        args.minute = 0
        if not args.hour then
          args.hour = 0
        end
      end
    end
    if
      type(args.year)   == &quot;number&quot; and
      type(args.month)  == &quot;number&quot; and
      type(args.day)    == &quot;number&quot; and
      type(args.hour)   == &quot;number&quot; and
      type(args.minute) == &quot;number&quot; and
      type(args.second) == &quot;number&quot;
    then
      if
        is_integer(args.year) and
        args.year &gt;= 1 and args.year &lt;= 9999 and
        is_integer(args.month) and
        args.month &gt;= 1 and args.month &lt;= 12 and
        is_integer(args.day) and
        args.day &gt;= 1 and args.day &lt;= 31 and
        is_integer(args.hour) and
        args.hour &gt;= 0 and args.hour &lt;= 23 and
        is_integer(args.minute) and
        args.minute &gt;= 0 and args.minute &lt;= 59 and
        is_integer(args.second) and
        args.second &gt;= 0 and args.second &lt;= 59
      then
        return timestamp:_create{
          tsec = timestamp.ymdhms_to_tsec(
            args.year, args.month, args.day,
            args.hour, args.minute, args.second
          ),
          year   = args.year,
          month  = args.month,
          day    = args.day,
          hour   = args.hour,
          minute = args.minute,
          second = args.second
        }
      else
        return timestamp.invalid
      end
    elseif type(args.tsec) == &quot;number&quot; then
      if
        is_integer(args.tsec) and
        args.tsec &gt;= -62135596800 and args.tsec &lt;= 253402300799
      then
        local year, month, day, hour, minute, second =
          timestamp.tsec_to_ymdhms(args.tsec)
        return timestamp:_create{
          tsec = args.tsec,
          year = year, month = month, day = day,
          hour = hour, minute = minute, second = second
        }
      else
        return timestamp.invalid
      end
    end
  end
  error(&quot;Invalid arguments passed to timestamp constructor.&quot;)
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_97').style.display = document.getElementById('autodoc_details_97').style.display ? '' : 'none';">
    auth.openid.discover{ user_supplied_identifier = user_supplied_identifier, https_as_default = https_as_default, curl_options = curl_options }
  </div>
  <div id="autodoc_details_97" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>discovery_data,                                         <span class="autodoc_comment_tail">-- table containing &quot;claimed_identifier&quot;, &quot;op_endpoint&quot; and &quot;op_local_identifier&quot;</span>
errmsg,                                                 <span class="autodoc_comment_tail">-- error message in case of failure</span>
errcode =                                               <span class="autodoc_comment_tail">-- error code in case of failure (TODO: not implemented yet)</span>
auth.openid.discover{
  user_supplied_identifier = user_supplied_identifier,  <span class="autodoc_comment_tail">-- string given by user</span>
  https_as_default         = https_as_default,          <span class="autodoc_comment_tail">-- default to https</span>
  curl_options             = curl_options               <span class="autodoc_comment_tail">-- options passed to &quot;curl&quot; binary, when performing discovery</span>
}</pre>
    </div>
    <div class="autodoc_comment">    </div>
    <div class="autodoc_source">
<pre><span class="autodoc_comment_tail">-- helper function</span>
local function decode_entities(str)
  local str = str
  str = string.gsub(value, &quot;&amp;lt;&quot;, '&lt;')
  str = string.gsub(value, &quot;&amp;gt;&quot;, '&gt;')
  str = string.gsub(value, &quot;&amp;quot;&quot;, '&quot;')
  str = string.gsub(value, &quot;&amp;amp;&quot;, '&amp;amp;')
  return str
end

<span class="autodoc_comment_tail">-- helper function</span>
local function get_tag_value(
  str,          <span class="autodoc_comment_tail">-- HTML document or document snippet</span>
  match_tag,    <span class="autodoc_comment_tail">-- tag name</span>
  match_key,    <span class="autodoc_comment_tail">-- attribute key to match</span>
  match_value,  <span class="autodoc_comment_tail">-- attribute value to match</span>
  result_key    <span class="autodoc_comment_tail">-- attribute key of value to return</span>
)
  <span class="autodoc_comment_tail">-- NOTE: The following parameters are case insensitive</span>
  local match_tag   = string.lower(match_tag)
  local match_key   = string.lower(match_key)
  local match_value = string.lower(match_value)
  local result_key  = string.lower(result_key)
  for tag, attributes in
    string.gmatch(str, &quot;&lt;([0-9A-Za-z_-]+) ([^&gt;]*)&gt;&quot;)
  do
    local tag = string.lower(tag)
    if tag == match_tag then
      local matching = false
      for key, value in
        string.gmatch(attributes, '([0-9A-Za-z_-]+)=&quot;([^&quot;&lt;&gt;]*)&quot;')
      do
        local key = string.lower(key)
        local value = decode_entities(value)
        if key == match_key then
          <span class="autodoc_comment_tail">-- NOTE: match_key must only match one key of space seperated list</span>
          for value in string.gmatch(value, &quot;[^ ]+&quot;) do
            if string.lower(value) == match_value then
              matching = true
              break
            end
          end
        end
        if key == result_key then
          result_value = value
        end
      end
      if matching then
        return result_value
      end
    end
  end
  return nil
end

<span class="autodoc_comment_tail">-- helper function</span>
local function tag_contents(str, match_tag)
  local pos = 0
  local tagpos, closing, tag
  local function next_tag()
    local prefix
    tagpos, prefix, tag, pos = string.match(
      str,
      &quot;()&lt;(/?)([0-9A-Za-z:_-]+)[^&gt;]*&gt;()&quot;,
      pos
    )
    closing = (prefix == &quot;/&quot;)
  end
  return function()
    repeat
      next_tag()
      if not tagpos then return nil end
      local stripped_tag
      if string.find(tag, &quot;:&quot;) then
        stripped_tag = string.match(tag, &quot;:([^:]*)$&quot;)
      else
        stripped_tag = tag
      end
    until stripped_tag == match_tag and not closing
    local content_start = pos
    local used_tag = tag
    local counter = 0
    while true do
      repeat
        next_tag()
        if not tagpos then return nil end
      until tag == used_tag
      if closing then
        if counter &gt; 0 then
          counter = counter - 1
        else
          return string.sub(str, content_start, tagpos-1)
        end
      else
        counter = counter + 1
      end
    end
    local content = string.sub(rest, 1, startpos-1)
    str = string.sub(rest, endpos+1)
    return content
  end
end

local function strip(str)
  local str = str
  string.gsub(str, &quot;^[ \t\r\n]+&quot;, &quot;&quot;)
  string.gsub(str, &quot;[ \t\r\n]+$&quot;, &quot;&quot;)
  return str
end

function auth.openid.discover(args)
  local url = string.match(args.user_supplied_identifier, &quot;[^#]*&quot;)
  <span class="autodoc_comment_tail">-- NOTE: XRIs are not supported</span>
  if
    string.find(url, &quot;^[Xx][Rr][Ii]://&quot;) or
    string.find(url, &quot;^[=@+$!(]&quot;)
  then
    return nil, &quot;XRI identifiers are not supported.&quot;
  end
  <span class="autodoc_comment_tail">-- Prepend http:// or https://, if neccessary:</span>
  if not string.find(url, &quot;://&quot;) then
    if args.default_to_https then
      url = &quot;https://&quot; .. url
    else
      url = &quot;http://&quot; .. url
    end
  end
  <span class="autodoc_comment_tail">-- Either an xrds_document or an html_document will be fetched</span>
  local xrds_document, html_document
  <span class="autodoc_comment_tail">-- Repeat max 10 times to avoid endless redirection loops</span>
  local redirects = 0
  while true do
    local status, headers, body = auth.openid._curl(url, args.curl_options)
    if not status then
      return nil, &quot;Error while locating XRDS or HTML file for discovery.&quot;
    end
    <span class="autodoc_comment_tail">-- Check, if we are redirected:</span>
    local location = string.match(
      headers,
      &quot;\r?\n[Ll][Oo][Cc][Aa][Tt][Ii][Oo][Nn]:[ \t]*([^\r\n]+)&quot;
    )
    if location then
      <span class="autodoc_comment_tail">-- If we are redirected too often, then return an error.</span>
      if redirects &gt;= 10 then
        return nil, &quot;Too many redirects.&quot;
      end
      <span class="autodoc_comment_tail">-- Otherwise follow the redirection by changing the variable &quot;url&quot;</span>
      <span class="autodoc_comment_tail">-- and by incrementing the redirect counter.</span>
      url = location
      redirects = redirects + 1
    else
      <span class="autodoc_comment_tail">-- Check, if there is an X-XRDS-Location header</span>
      <span class="autodoc_comment_tail">-- pointing to an XRDS document:</span>
      local xrds_location = string.match(
        headers,
        &quot;\r?\n[Xx]%-[Xx][Rr][Dd][Ss]%-[Ll][Oo][Cc][Aa][Tt][Ii][Oo][Nn]:[ \t]*([^\r\n]+)&quot;
      )
      <span class="autodoc_comment_tail">-- If there is no X-XRDS-Location header, there might be an</span>
      <span class="autodoc_comment_tail">-- http-equiv meta tag serving the same purpose:</span>
      if not xrds_location and status == 200 then
        xrds_location = get_tag_value(body, &quot;meta&quot;, &quot;http-equiv&quot;, &quot;X-XRDS-Location&quot;, &quot;content&quot;)
      end
      if xrds_location then
        <span class="autodoc_comment_tail">-- If we know the XRDS-Location, we can fetch the XRDS document</span>
        <span class="autodoc_comment_tail">-- from that location:</span>
        local status, headers, body = auth.openid._curl(xrds_location, args.curl_options)
        if not status then
          return nil, &quot;XRDS document could not be loaded.&quot;
        end
        if status ~= 200 then
          return nil, &quot;XRDS document not found where expected.&quot;
        end
        xrds_document = body
        break
      elseif
        <span class="autodoc_comment_tail">-- If the Content-Type header is set accordingly, then we already</span>
        <span class="autodoc_comment_tail">-- should have received an XRDS document:</span>
        string.find(
          headers,
          &quot;\r?\n[Cc][Oo][Nn][Tt][Ee][Nn][Tt]%-[Tt][Yy][Pp][Ee]:[ \t]*application/xrds%+xml\r?\n&quot;
        )
      then
        if status ~= 200 then
          return nil, &quot;XRDS document announced but not found.&quot;
        end
        xrds_document = body
        break
      else
        <span class="autodoc_comment_tail">-- Otherwise we should have received an HTML document:</span>
        if status ~= 200 then
          return nil, &quot;No XRDS or HTML document found for discovery.&quot;
        end
        html_document = body
        break;
      end
    end
  end
  local claimed_identifier   <span class="autodoc_comment_tail">-- OpenID identifier the user claims to own</span>
  local op_endpoint          <span class="autodoc_comment_tail">-- OpenID provider endpoint URL</span>
  local op_local_identifier  <span class="autodoc_comment_tail">-- optional user identifier, local to the OpenID provider</span>
  if xrds_document then
    <span class="autodoc_comment_tail">-- If we got an XRDS document, we look for a matching &lt;Service&gt; entry:</span>
    for content in tag_contents(xrds_document, &quot;Service&quot;) do
      local service_uri, service_localid
      for content in tag_contents(content, &quot;URI&quot;) do
        if not string.find(content, &quot;[&lt;&gt;]&quot;) then
          service_uri = strip(content)
          break
        end
      end
      for content in tag_contents(content, &quot;LocalID&quot;) do
        if not string.find(content, &quot;[&lt;&gt;]&quot;) then
          service_localid = strip(content)
          break
        end
      end
      for content in tag_contents(content, &quot;Type&quot;) do
        if not string.find(content, &quot;[&lt;&gt;]&quot;) then
          local content = strip(content)
          if content == &quot;http://specs.openid.net/auth/2.0/server&quot; then
            <span class="autodoc_comment_tail">-- The user entered a provider identifier, thus claimed_identifier</span>
            <span class="autodoc_comment_tail">-- and op_local_identifier will be set to nil.</span>
            op_endpoint = service_uri
            break
          elseif content == &quot;http://specs.openid.net/auth/2.0/signon&quot; then
            <span class="autodoc_comment_tail">-- The user entered his/her own identifier.</span>
            claimed_identifier  = url
            op_endpoint         = service_uri
            op_local_identifier = service_localid
            break
          end
        end
      end
    end
  elseif html_document then
    <span class="autodoc_comment_tail">-- If we got an HTML document, we look for matching &lt;link .../&gt; tags:</span>
    claimed_identifier = url
    op_endpoint = get_tag_value(
      html_document,
      &quot;link&quot;, &quot;rel&quot;, &quot;openid2.provider&quot;, &quot;href&quot;
    )
    op_local_identifier = get_tag_value(
      html_document,
      &quot;link&quot;, &quot;rel&quot;, &quot;openid2.local_id&quot;, &quot;href&quot;
    )
  else
    error(&quot;Assertion failed&quot;)  <span class="autodoc_comment_tail">-- should not happen</span>
  end
  if not op_endpoint then
    return nil, &quot;No OpenID endpoint found.&quot;
  end
  if claimed_identifier then
    claimed_identifier = auth.openid._normalize_url(claimed_identifier)
    if not claimed_identifier then
      return nil, &quot;Claimed identifier could not be normalized.&quot;
    end
  end
  return {
    claimed_identifier  = claimed_identifier,
    op_endpoint         = op_endpoint,
    op_local_identifier = op_local_identifier
  }
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_98').style.display = document.getElementById('autodoc_details_98').style.display ? '' : 'none';">
    auth.openid.initiate{ ... }
  </div>
  <div id="autodoc_details_98" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>success,                                                <span class="autodoc_comment_tail">-- boolean indicating success or failure</span>
errmsg,                                                 <span class="autodoc_comment_tail">-- error message in case of failure</span>
errcode =                                               <span class="autodoc_comment_tail">-- error code in case of failure (TODO: not implemented yet)</span>
auth.openid.initiate{
  user_supplied_identifier = user_supplied_identifier,  <span class="autodoc_comment_tail">-- string given by user</span>
  https_as_default         = https_as_default,          <span class="autodoc_comment_tail">-- default to https</span>
  curl_options             = curl_options,              <span class="autodoc_comment_tail">-- additional options passed to &quot;curl&quot; binary, when performing discovery</span>
  return_to_module         = return_to_module,          <span class="autodoc_comment_tail">-- module of the verifying view, the user shall return to after authentication</span>
  return_to_view           = return_to_view,            <span class="autodoc_comment_tail">-- verifying view, the user shall return to after authentication</span>
  realm                    = realm                      <span class="autodoc_comment_tail">-- URL the user should authenticate for, defaults to application base</span>
}</pre>
    </div>
    <div class="autodoc_comment">In order to authenticate using OpenID the user should enter an identifier.<br/>It is recommended that the form field element for this identifier is named<br/>&quot;openid_identifier&quot;, so that User-Agents can automatically determine the<br/>given field should contain an OpenID identifier. The entered identifier is<br/>then passed as &quot;user_supplied_identifier&quot; argument to this function. It<br/>returns false on error and currently never returns on success. However in<br/>future this function shall return true on success. After the user has<br/>authenticated successfully, he/she is forwarded to the URL given by the<br/>&quot;return_to&quot; argument. Under this URL the application has to verify the<br/>result by calling auth.openid.verify{...}.    </div>
    <div class="autodoc_source">
<pre>function auth.openid.initiate(args)
  local dd, errmsg, errcode = auth.openid.discover(args)
  if not dd then
    return nil, errmsg, errcode
  end
  <span class="autodoc_comment_tail">-- TODO: Use request.redirect once it supports external URLs</span>
  cgi.set_status(&quot;303 See Other&quot;)
  cgi.add_header(
    &quot;Location: &quot; ..
    encode.url{
      external = dd.op_endpoint,
      params = {
        [&quot;openid.ns&quot;]         = &quot;http://specs.openid.net/auth/2.0&quot;,
        [&quot;openid.mode&quot;]       = &quot;checkid_setup&quot;,
        [&quot;openid.claimed_id&quot;] = dd.claimed_identifier or
                                &quot;http://specs.openid.net/auth/2.0/identifier_select&quot;,
        [&quot;openid.identity&quot;]   = dd.op_local_identifier or dd.claimed_identifier or
                                &quot;http://specs.openid.net/auth/2.0/identifier_select&quot;,
        [&quot;openid.return_to&quot;]  = encode.url{
                                  base   = request.get_absolute_baseurl(),
                                  module = args.return_to_module,
                                  view   = args.return_to_view
                                },
        [&quot;openid.realm&quot;]      = args.realm or request.get_absolute_baseurl()
      }
    }
  )
  cgi.send_data()
  exit()
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_99').style.display = document.getElementById('autodoc_details_99').style.display ? '' : 'none';">
    auth.openid.verify( force_https = force_https, curl_options = curl_options )
  </div>
  <div id="autodoc_details_99" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>claimed_identifier,                        <span class="autodoc_comment_tail">-- identifier owned by the user</span>
errmsg,                                    <span class="autodoc_comment_tail">-- error message in case of failure</span>
errcode =                                  <span class="autodoc_comment_tail">-- error code in case of failure (TODO: not implemented yet)</span>
auth.openid.verify(
  force_https              = force_https,  <span class="autodoc_comment_tail">-- only allow https</span>
  curl_options             = curl_options  <span class="autodoc_comment_tail">-- options passed to &quot;curl&quot; binary, when performing discovery</span>
)</pre>
    </div>
    <div class="autodoc_comment">    </div>
    <div class="autodoc_source">
<pre>function auth.openid.verify(args)
  local args = args or {}
  if cgi.params[&quot;openid.ns&quot;] ~= &quot;http://specs.openid.net/auth/2.0&quot; then
    return nil, &quot;No indirect OpenID 2.0 message received.&quot;
  end
  local mode = cgi.params[&quot;openid.mode&quot;]
  if mode == &quot;id_res&quot; then
    local return_to_url = cgi.params[&quot;openid.return_to&quot;]
    if not return_to_url then
      return nil, &quot;No return_to URL received in answer.&quot;
    end
    if return_to_url ~= encode.url{
      base   = request.get_absolute_baseurl(),
      module = request.get_module(),
      view   = request.get_view()
    } then
      return nil, &quot;return_to URL not matching.&quot;
    end
    local discovery_args = table.new(args)
    local claimed_identifier = cgi.params[&quot;openid.claimed_id&quot;]
    if not claimed_identifier then
      return nil, &quot;No claimed identifier received.&quot;
    end
    local cropped_identifier = string.match(claimed_identifier, &quot;[^#]*&quot;)
    local normalized_identifier = auth.openid._normalize_url(
      cropped_identifier
    )
    if not normalized_identifier then
      return nil, &quot;Claimed identifier could not be normalized.&quot;
    end
    if normalized_identifier ~= cropped_identifier then
      return nil, &quot;Claimed identifier was not normalized.&quot;
    end
    discovery_args.user_supplied_identifier = cropped_identifier
    local dd, errmsg, errcode = auth.openid.discover(discovery_args)
    if not dd then
      return nil, errmsg, errcode
    end
    if not dd.claimed_identifier then
      return nil, &quot;Identifier is an OpenID Provider.&quot;
    end
    if dd.claimed_identifier ~= cropped_identifier then
      return nil, &quot;Claimed identifier does not match.&quot;
    end
    local nonce = cgi.params[&quot;openid.response_nonce&quot;]
    if not nonce then
      return nil, &quot;Did not receive a response nonce.&quot;
    end
    local year, month, day, hour, minute, second = string.match(
      nonce,
      &quot;^([0-9][0-9][0-9][0-9])%-([0-9][0-9])%-([0-9][0-9])T([0-9][0-9]):([0-9][0-9]):([0-9][0-9])Z&quot;
    )
    if not year then
      return nil, &quot;Response nonce did not contain a parsable date/time.&quot;
    end
    local ts = atom.timestamp{
      year   = tonumber(year),
      month  = tonumber(month),
      day    = tonumber(day),
      hour   = tonumber(hour),
      minute = tonumber(minute),
      second = tonumber(second)
    }
    <span class="autodoc_comment_tail">-- NOTE: 50 hours margin allows us to ignore time zone issues here:</span>
    if math.abs(ts - atom.timestamp:get_current()) &gt; 3600 * 50 then
      return nil, &quot;Response nonce contains wrong time or local time is wrong.&quot;
    end
    local params = {}
    for key, value in pairs(cgi.params) do
      local trimmed_key = string.match(key, &quot;^openid%.(.+)&quot;)
      if trimmed_key then
        params[key] = value
      end
    end
    params[&quot;openid.mode&quot;] = &quot;check_authentication&quot;
    local options = table.new(args.curl_options)
    for key, value in pairs(params) do
      options[#options+1] = &quot;<span class="autodoc_comment_tail">--data-urlencode&quot;</span>
      options[#options+1] = key .. &quot;=&quot; .. value
    end
    local status, headers, body = auth.openid._curl(dd.op_endpoint, options)
    if status ~= 200 then
      return nil, &quot;Authorization could not be verified.&quot;
    end
    local result = {}
    for key, value in string.gmatch(body, &quot;([^\n:]+):([^\n]*)&quot;) do
      result[key] = value
    end
    if result.ns ~= &quot;http://specs.openid.net/auth/2.0&quot; then
      return nil, &quot;No OpenID 2.0 message replied.&quot;
    end
    if result.is_valid == &quot;true&quot; then
      return claimed_identifier
    else
      return nil, &quot;Signature invalid.&quot;
    end
  elseif mode == &quot;cancel&quot; then
    return nil, &quot;Authorization failed according to OpenID provider.&quot;
  else
    return nil, &quot;Unexpected OpenID mode.&quot;
  end
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_100').style.display = document.getElementById('autodoc_details_100').style.display ? '' : 'none';">
    auth.openid.xrds_document{ return_to_module = return_to_module, return_to_view = return_to_view }
  </div>
  <div id="autodoc_details_100" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>auth.openid.xrds_document{
  return_to_module = return_to_module,
  return_to_view   = return_to_view
}</pre>
    </div>
    <div class="autodoc_comment">This function returns an XRDS document with Content-Type<br/>application/xrds+xml. For more information see documentation on<br/>auth.openid.xrds_document{...}.    </div>
    <div class="autodoc_source">
<pre>function auth.openid.xrds_document(args)
  slot.set_layout(nil, &quot;application/xrds+xml&quot;)
  slot.put_into(&quot;data&quot;,
    '&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n',
    '&lt;xrds:XRDS xmlns:xrds=&quot;xri://$xrds&quot; xmlns=&quot;xri://$xrd*($v*2.0)&quot;&gt;\n',
    '  &lt;XRD&gt;\n',
    '    &lt;Service&gt;\n',
    '      &lt;Type&gt;http://specs.openid.net/auth/2.0/return_to&lt;/Type&gt;\n',
    '      &lt;URI&gt;',
    encode.url{
      base   = request.get_absolute_baseurl(),
      module = args.return_to_module,
      view   = args.return_to_view
    },
    '&lt;/URI&gt;\n',
    '    &lt;/Service&gt;\n',
    '  &lt;/XRD&gt;\n',
    '&lt;/xrds:XRDS&gt;\n'
  )
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_101').style.display = document.getElementById('autodoc_details_101').style.display ? '' : 'none';">
    auth.openid.xrds_header{ ... }
  </div>
  <div id="autodoc_details_101" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>auth.openid.xrds_header{
  ...                     <span class="autodoc_comment_tail">-- arguments as used for encode.url{...}, pointing to an XRDS document as explained below</span>
}</pre>
    </div>
    <div class="autodoc_comment">According to the OpenID specification, providers should verify, that<br/>return_to URLs are an OpenID relying party endpoint. To use OpenID<br/>providers following this recommendation, the relying parties can send a<br/>X-XRDS-Location header by calling this function. Its arguments must refer<br/>to an URL returning a document as follows:<br/><br/>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br/>&lt;xrds:XRDS xmlns:xrds=&quot;xri://$xrds&quot; xmlns=&quot;xri://$xrd*($v*2.0)&quot;&gt;<br/>  &lt;XRD&gt;<br/>    &lt;Service&gt;<br/>      &lt;Type&gt;http://specs.openid.net/auth/2.0/return_to&lt;/Type&gt;<br/>      &lt;URI&gt;RETURN_TO_URL&lt;/URI&gt;<br/>    &lt;/Service&gt;<br/>  &lt;/XRD&gt;<br/>&lt;/xrds:XRDS&gt;<br/><br/>The placeholder RETURN_TO_URL has to be replaced by the absolute URL of the<br/>given return_to_module and return_to_view.<br/><br/><br/>Example application-wide filter, assuming the document above is saved in<br/>&quot;static/openid.xrds&quot;:<br/><br/>auth.openid.xrds_header{ static = &quot;openid.xrds&quot; }<br/>execute.inner()<br/><br/><br/>Example applications-wide filter, assuming<br/>- the return_to_module is &quot;openid&quot;<br/>- the return_to_view is &quot;return&quot;<br/>- the module for returning the xrds document is &quot;openid&quot;<br/>- the view for returning the xrds document is &quot;xrds&quot;<br/><br/>auth.openid.xrds_header{ module = &quot;openid&quot;, view = &quot;xrds&quot; }<br/>execute.inner()<br/><br/><br/>In the last example the &quot;xrds&quot; view in module &quot;openid&quot; has to make the<br/>following call:<br/><br/>auth.openid.xrds_document{<br/>  return_to_module = &quot;openid&quot;,<br/>  return_to_view   = &quot;return&quot;<br/>}    </div>
    <div class="autodoc_source">
<pre>function auth.openid.xrds_header(args)
  cgi.add_header(&quot;X-XRDS-Location: &quot; .. encode.url(args))
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_102').style.display = document.getElementById('autodoc_details_102').style.display ? '' : 'none';">
    charset.get()
  </div>
  <div id="autodoc_details_102" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>current_charset =  <span class="autodoc_comment_tail">-- currently selected character set to be used</span>
charset.get()</pre>
    </div>
    <div class="autodoc_comment">Returns the currently selected character set, which is used by the application. Defaults to &quot;UTF-8&quot; unless being changed.    </div>
    <div class="autodoc_source">
<pre>function charset.get()
  return charset._current
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_103').style.display = document.getElementById('autodoc_details_103').style.display ? '' : 'none';">
    charset.get_data()
  </div>
  <div id="autodoc_details_103" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>charset_data =  <span class="autodoc_comment_tail">-- table containing information about the current charset</span>
charset.get_data()</pre>
    </div>
    <div class="autodoc_comment">Returns a table with information about the currently selected charset. See framework/env/charset/data/ for more information.    </div>
    <div class="autodoc_source">
<pre>function charset.get_data()
  return charset.data[
    string.gsub(string.lower(charset._current), &quot;%-&quot;, &quot;_&quot;)
  ]
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_104').style.display = document.getElementById('autodoc_details_104').style.display ? '' : 'none';">
    charset.set( charset_ident )
  </div>
  <div id="autodoc_details_104" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>charset.set(
  charset_ident  <span class="autodoc_comment_tail">-- identifier of a charset, i.e. &quot;UTF-8&quot;</span>
)</pre>
    </div>
    <div class="autodoc_comment">Changes the currently used charset. Only &quot;UTF-8&quot; is supported, which is already set as a default, so calling this function is not really useful yet.    </div>
    <div class="autodoc_source">
<pre>function charset.set(charset_ident)
  charset._current = charset_ident
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_105').style.display = document.getElementById('autodoc_details_105').style.display ? '' : 'none';">
    config
  </div>
  <div id="autodoc_details_105" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>config  <span class="autodoc_comment_tail">-- table to store application configuration</span></pre>
    </div>
    <div class="autodoc_comment">'config' is a global table, which can be modified by a config file of an application to modify the behaviour of that application.    </div>
    <div class="autodoc_source">
<pre>config = {}</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_106').style.display = document.getElementById('autodoc_details_106').style.display ? '' : 'none';">
    db_error, result1, result2, ... = &lt;db_handle&gt;:try_query{ ... }
  </div>
  <div id="autodoc_details_106" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>db_error,               <span class="autodoc_comment_tail">-- error object, or nil in case of success</span>
result1,                <span class="autodoc_comment_tail">-- result of first command</span>
result2,                <span class="autodoc_comment_tail">-- result of second command</span>
... =
&lt;db_handle&gt;:try_query(
  command1,             <span class="autodoc_comment_tail">-- first command (to be processed by &quot;assemble_command&quot; method)</span>
  mode1,                <span class="autodoc_comment_tail">-- mode for first command: &quot;list&quot;, &quot;object&quot; or &quot;opt_object&quot;</span>
  command2,             <span class="autodoc_comment_tail">-- second command (to be processed by &quot;assemble_command&quot; method)</span>
  mode2,                <span class="autodoc_comment_tail">-- mode for second command: &quot;list&quot;, &quot;object&quot; or &quot;opt_object&quot;</span>
  ..
)</pre>
    </div>
    <div class="autodoc_comment">This method executes one or multiple SQL commands and returns its results. Each command is pre-processed by the &quot;assemble_command&quot; method of the database handle. A mode can be selected for each command: &quot;list&quot; for normal queries, &quot;object&quot; for queries which have exactly one result row, or &quot;opt_object&quot; which have one or zero result rows. If an error occurs, an error object is returned as first result value.<br/><br/>The mode of the last command may be ommitted and default to &quot;list&quot;.    </div>
    <div class="autodoc_source">
<pre><span class="autodoc_comment_tail">-- implemented in mondelefant_native.c as</span>
<span class="autodoc_comment_tail">-- static int mondelefant_conn_try_query(lua_State *L)</span></pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_107').style.display = document.getElementById('autodoc_details_107').style.display ? '' : 'none';">
    encode.action_file_path{ module = module, action = action }
  </div>
  <div id="autodoc_details_107" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>path =                    <span class="autodoc_comment_tail">-- string containing a path to an action</span>
encode.action_file_path{
  module = module,        <span class="autodoc_comment_tail">-- module name</span>
  action = action         <span class="autodoc_comment_tail">-- action name</span>
}</pre>
    </div>
    <div class="autodoc_comment">This function returns the file path of an action with a given module name and action name. Both module name and action name are mandatory arguments.    </div>
    <div class="autodoc_source">
<pre>function encode.action_file_path(args)
  return (encode.file_path(
    request.get_app_basepath(),
    'app',
    request.get_app_name(),
    args.module,
    '_action',
    args.action .. '.lua'
  ))
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_108').style.display = document.getElementById('autodoc_details_108').style.display ? '' : 'none';">
    encode.concat_file_path( element1, element2, ... )
  </div>
  <div id="autodoc_details_108" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>path =                    <span class="autodoc_comment_tail">-- string containing a (file) path</span>
encode.concat_file_path(
  element1,               <span class="autodoc_comment_tail">-- first part of the path</span>
  element2,               <span class="autodoc_comment_tail">-- second part of the path</span>
  ...                     <span class="autodoc_comment_tail">-- more parts of the path</span>
)</pre>
    </div>
    <div class="autodoc_comment">This function takes a variable amount of strings as arguments and returns a concatenation with slashes as seperators. Multiple slashes following each other directly are transformed into a single slash.    </div>
    <div class="autodoc_source">
<pre>function encode.concat_file_path(...)
  return (
    string.gsub(
      table.concat({...}, &quot;/&quot;), &quot;/+&quot;, &quot;/&quot;
    )
  )
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_109').style.display = document.getElementById('autodoc_details_109').style.display ? '' : 'none';">
    encode.encode_file_path{ ... }
  </div>
  <div id="autodoc_details_109" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>path =                    <span class="autodoc_comment_tail">-- string containing a (file) path</span>
encode.encode_file_path(
  base_path,
  element1,               <span class="autodoc_comment_tail">-- next part of the path</span>
  element2,               <span class="autodoc_comment_tail">-- next part of the path</span>
  ...
)</pre>
    </div>
    <div class="autodoc_comment">This function does the same as encode.concat_file_path, except that all arguments but the first are encoded using the encode.file_path_element function.    </div>
    <div class="autodoc_source">
<pre>function encode.file_path(base, ...)  <span class="autodoc_comment_tail">-- base argument is not encoded</span>
  local raw_elements = {...}
  local encoded_elements = {}
  for i = 1, #raw_elements do
    encoded_elements[i] = encode.file_path_element(raw_elements[i])
  end
  return encode.concat_file_path(base, table.unpack(encoded_elements))
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_110').style.display = document.getElementById('autodoc_details_110').style.display ? '' : 'none';">
    encode.file_path_element( path_element )
  </div>
  <div id="autodoc_details_110" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>encoded_path_element =     <span class="autodoc_comment_tail">-- string which can't contain evil stuff like &quot;/&quot;</span>
encode.file_path_element(
  path_element             <span class="autodoc_comment_tail">-- string to be encoded</span>
)</pre>
    </div>
    <div class="autodoc_comment">This function is encoding a string in a way that it can be used as a file or directory name, without security risks. See the source for details.    </div>
    <div class="autodoc_source">
<pre>function encode.file_path_element(path_element)
  return (
    string.gsub(
      string.gsub(
        path_element, &quot;[^0-9A-Za-z_%.-]&quot;,
        function(char)
          return string.format(&quot;%%%02x&quot;, string.byte(char))
        end
      ), &quot;^%.&quot;, string.format(&quot;%%%%%02x&quot;, string.byte(&quot;.&quot;))
    )
  )
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_111').style.display = document.getElementById('autodoc_details_111').style.display ? '' : 'none';">
    encode.format_info( format, params )
  </div>
  <div id="autodoc_details_111" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>string =             <span class="autodoc_comment_tail">-- string to be used as __format information</span>
encode.format_info(
  format,            <span class="autodoc_comment_tail">-- name of format function</span>
  params             <span class="autodoc_comment_tail">-- arguments for format function</span>
)</pre>
    </div>
    <div class="autodoc_comment">The string returned by the function can be used as value in a hidden form field with a &quot;__format&quot; suffix. It will be used by the param.* functions to parse a string.    </div>
    <div class="autodoc_source">
<pre>function encode.format_info(format, params)
  return format .. encode.format_options(params)
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_112').style.display = document.getElementById('autodoc_details_112').style.display ? '' : 'none';">
    encode.format_options( params )
  </div>
  <div id="autodoc_details_112" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>string =                <span class="autodoc_comment_tail">-- part of string to be used as __format information</span>
encode.format_options(
  params                <span class="autodoc_comment_tail">-- arguments for format function</span>
)</pre>
    </div>
    <div class="autodoc_comment">This function is used by encode.format_info(...).    </div>
    <div class="autodoc_source">
<pre>function encode.format_options(params)
  local params = params or {}
  local result_parts = {}
  for key, value in pairs(params) do
    if type(key) == &quot;string&quot; then
      if string.find(key, &quot;^[A-Za-z][A-Za-z0-9_]*$&quot;) then
        table.insert(result_parts, &quot;-&quot;)
        table.insert(result_parts, key)
        table.insert(result_parts, &quot;-&quot;)
        local t = type(value)
        if t == &quot;string&quot; then
          value = string.gsub(value, &quot;\\&quot;, &quot;\\\\&quot;)
          value = string.gsub(value, &quot;'&quot;, &quot;\\'&quot;)
          table.insert(result_parts, &quot;'&quot;)
          table.insert(result_parts, value)
          table.insert(result_parts, &quot;'&quot;)
        elseif t == &quot;number&quot; then
          table.insert(result_parts, tostring(value))
        elseif t == &quot;boolean&quot; then
          table.insert(result_parts, value and &quot;true&quot; or &quot;false&quot;)
        else
          error(&quot;Format parameter table contained value of unsupported type &quot; .. t .. &quot;.&quot;)
        end
      else
        error('Format parameter table contained invalid key &quot;' .. key .. '&quot;.')
      end
    end
  end
  return table.concat(result_parts)
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_113').style.display = document.getElementById('autodoc_details_113').style.display ? '' : 'none';">
    encode.html( str )
  </div>
  <div id="autodoc_details_113" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>result =      <span class="autodoc_comment_tail">-- encoded string</span>
encode.html(
  str         <span class="autodoc_comment_tail">-- original string</span>
)</pre>
    </div>
    <div class="autodoc_comment">This function replaces the special characters '&lt;', '&gt;', '&amp;' and '&quot;' by their HTML entities '&amp;lt;', '&amp;rt;', '&amp;amp;' and '&amp;quot;'.<br/><br/>NOTE: ACCELERATED FUNCTION<br/>Do not change unless also you also update webmcp_accelerator.c    </div>
    <div class="autodoc_source">
<pre>function encode.html(text)
  <span class="autodoc_comment_tail">-- TODO: perhaps filter evil control characters?</span>
  return (
    string.gsub(
      text, '[&lt;&gt;&amp;&quot;]',
      function(char)
        if char == '&lt;' then
          return &quot;&amp;lt;&quot;
        elseif char == '&gt;' then
          return &quot;&amp;gt;&quot;
        elseif char == '&amp;' then
          return &quot;&amp;amp;&quot;
        elseif char == '&quot;' then
          return &quot;&amp;quot;&quot;
        end
      end
    )
  )
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_114').style.display = document.getElementById('autodoc_details_114').style.display ? '' : 'none';">
    encode.html_newlines( text_with_lf_control_characters )
  </div>
  <div id="autodoc_details_114" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>text_with_br_tags =                <span class="autodoc_comment_tail">-- text with &lt;br/&gt; tags</span>
encode.html_newlines(
  text_with_lf_control_characters  <span class="autodoc_comment_tail">-- text with LF control characters</span>
)</pre>
    </div>
    <div class="autodoc_comment">This function transforms LF control characters (\n) into &lt;br/&gt; tags.    </div>
    <div class="autodoc_source">
<pre>function encode.html_newlines(text)
  return (string.gsub(text, '\n', '&lt;br/&gt;'))
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_115').style.display = document.getElementById('autodoc_details_115').style.display ? '' : 'none';">
    encode.json( obj )
  </div>
  <div id="autodoc_details_115" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>json_string =  <span class="autodoc_comment_tail">-- JavaScript code representing the given datum (with quotes, if needed)</span>
encode.json(
  obj          <span class="autodoc_comment_tail">-- true, false, nil or a number or string</span>
)</pre>
    </div>
    <div class="autodoc_comment">This function encodes any native datatype or atom in JavaScript object notation (JSON). It ensures that the returned string can be safely included in inline scripts both in HTML and XHTML (within CDATA section).<br/><br/>TODO: can't distinguish unambiguously between empty object and empty list!    </div>
    <div class="autodoc_source">
<pre><span class="autodoc_comment_tail">-- TODO: check if numeric representations are JSON compatible</span>

function encode.json(obj)
  if obj == nil then
    return &quot;null&quot;;
  elseif atom.has_type(obj, atom.boolean) then
    return tostring(obj)
  elseif atom.has_type(obj, atom.number) then
    return tostring(obj)
  elseif type(obj) == &quot;table&quot; then
    local parts = {}
    local first = true
    if #obj &gt; 0 then
      parts[#parts+1] = &quot;[&quot;
      for idx, value in ipairs(obj) do
        if first then
          first = false
        else
          parts[#parts+1] = &quot;,&quot;
        end
        parts[#parts+1] = tostring(value)
      end
      parts[#parts+1] = &quot;]&quot;
    else
      parts[#parts+1] = &quot;{&quot;
      for key, value in pairs(obj) do
        if first then
          first = false
        else
          parts[#parts+1] = &quot;,&quot;
        end
        parts[#parts+1] = encode.json(key)
        parts[#parts+1] = &quot;:&quot;
        parts[#parts+1] = encode.json(value)
      end
      parts[#parts+1] = &quot;}&quot;
    end
    return table.concat(parts)
  else
    local str = atom.dump(obj)
    str = string.gsub(str, &quot;.&quot;,
      function (char)
        if char == '\r' then return '\\r'  end
        if char == '\n' then return '\\n'  end
        if char == '\\' then return '\\\\' end
        if char == '&quot;'  then return '\\&quot;'  end
        local byte = string.byte(char)
        if byte &lt; 32 then return string.format(&quot;\\u%04x&quot;, byte) end
      end
    )
    str = string.gsub(str, &quot;&lt;/&quot;, &quot;&lt;\\/&quot;)
    str = string.gsub(str, &quot;&lt;!%[CDATA%[&quot;, &quot;\\u003c![CDATA[&quot;)
    str = string.gsub(str, &quot;]]&gt;&quot;, &quot;]]\\u003e&quot;)
    return '&quot;' .. str .. '&quot;'
  end
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_116').style.display = document.getElementById('autodoc_details_116').style.display ? '' : 'none';">
    encode.url_part( obj )
  </div>
  <div id="autodoc_details_116" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>url_encoded_string =  <span class="autodoc_comment_tail">-- URL-encoded string</span>
encode.url_part(
  obj                 <span class="autodoc_comment_tail">-- any native datatype or atom</span>
)</pre>
    </div>
    <div class="autodoc_comment">This function encodes any native datatype or atom in a way that it can be placed inside an URL. It is first dumped with atom.dump(...) and then url-encoded.    </div>
    <div class="autodoc_source">
<pre>function encode.url_part(obj)
  return (
    string.gsub(
      atom.dump(obj),
      &quot;[^0-9A-Za-z_%.~-]&quot;,
      function (char)
        return string.format(&quot;%%%02x&quot;, string.byte(char))
      end
    )
  )
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_117').style.display = document.getElementById('autodoc_details_117').style.display ? '' : 'none';">
    encode.url{ ... }
  </div>
  <div id="autodoc_details_117" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>url_string =              <span class="autodoc_comment_tail">-- a string containing an URL</span>
encode.url{
  external  = external,   <span class="autodoc_comment_tail">-- external URL (instead of specifying base, module, etc. below)</span>
  base      = base,       <span class="autodoc_comment_tail">-- optional string containing a base URL of a WebMCP application</span>
  static    = static,     <span class="autodoc_comment_tail">-- an URL relative to the static file directory</span>
  module    = module,     <span class="autodoc_comment_tail">-- a module name of the WebMCP application</span>
  view      = view,       <span class="autodoc_comment_tail">-- a view name of the WebMCP application</span>
  action    = action,     <span class="autodoc_comment_tail">-- an action name of the WebMCP application</span>
  id        = id,         <span class="autodoc_comment_tail">-- optional id to be passed to the view or action to select a particular data record</span>
  params    = params,     <span class="autodoc_comment_tail">-- optional parameters to be passed to the view or action</span>
  anchor    = anchor      <span class="autodoc_comment_tail">-- anchor in URL</span>
}</pre>
    </div>
    <div class="autodoc_comment">This function creates URLs to external locations, to static files within the WebMCP application or to a certain view or action inside a module.    </div>
    <div class="autodoc_source">
<pre>function encode.url(args)
  local external  = args.external
  local base      = args.base or request.get_relative_baseurl()
  local static    = args.static
  local module    = args.module
  local view      = args.view
  local action    = args.action
  local id        = args.id
  local params    = args.params or {}
  local anchor    = args.anchor
  local result    = {}
  local id_as_param = false
  local function add(...)
    for i = 1, math.huge do
      local v = select(i, ...)
      if v == nil then break end
      result[#result+1] = v
    end
  end
  if external then
    add(external)
  else
    add(base)
    if not string.find(base, &quot;/$&quot;) then
      add(&quot;/&quot;)
    end
    if static then
      add(&quot;static/&quot;)
      add(static)
    elseif module or view or action or id then
      assert(module, &quot;Module not specified.&quot;)
      add(encode.url_part(module), &quot;/&quot;)
      if view and not action then
        local view_base, view_suffix = string.match(
          view,
          &quot;^([^.]*)(.*)$&quot;
        )
        add(encode.url_part(view_base))
        if args.id then
          add(&quot;/&quot;, encode.url_part(id))
        end
        if view_suffix == &quot;&quot; then
          add(&quot;.html&quot;)
        else
          add(view_suffix)  <span class="autodoc_comment_tail">-- view_suffix includes dot as first character</span>
        end
      elseif action and not view then
        add(encode.url_part(action))
        id_as_param = true
      elseif view and action then
        error(&quot;Both a view and an action was specified.&quot;)
      end
    end
    do
      local new_params = request.get_perm_params()
      for key, value in pairs(params) do
        new_params[key] = value
      end
      params = new_params
    end
  end
  if next(params) ~= nil or (id and id_as_param) then
    add(&quot;?&quot;)
    if id and id_as_param then
      add(&quot;_webmcp_id=&quot;, encode.url_part(id), &quot;&amp;&quot;)
    end
    for key, value in pairs(params) do
      <span class="autodoc_comment_tail">-- TODO: better way to detect arrays?</span>
      if string.match(key, &quot;%[%]$&quot;) then
        for idx, entry in ipairs(value) do
          add(encode.url_part(key), &quot;=&quot;, encode.url_part(entry), &quot;&amp;&quot;)
        end
      else
        add(encode.url_part(key), &quot;=&quot;, encode.url_part(value), &quot;&amp;&quot;)
      end
    end
    result[#result] = nil  <span class="autodoc_comment_tail">-- remove last '&amp;' or '?'</span>
  end
  local string_result = table.concat(result)
  if anchor ~= nil then
    string_result = string.match(string_result, &quot;^[^#]*&quot;)
    if anchor then
      string_result = string_result .. &quot;#&quot; .. encode.url_part(anchor)
    end
  end
  return string_result
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_118').style.display = document.getElementById('autodoc_details_118').style.display ? '' : 'none';">
    encode.view_file_path{ module = module, view = view }
  </div>
  <div id="autodoc_details_118" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>path =                  <span class="autodoc_comment_tail">-- string containing a path to a view</span>
encode.view_file_path{
  module = module,      <span class="autodoc_comment_tail">-- module name</span>
  view   = view         <span class="autodoc_comment_tail">-- view name</span>
}</pre>
    </div>
    <div class="autodoc_comment">This function returns the file path of a view with a given module name and view name. Both module name and view name are mandatory arguments.    </div>
    <div class="autodoc_source">
<pre>function encode.view_file_path(args)
  return (encode.file_path(
    request.get_app_basepath(),
    'app', request.get_app_name(), args.module, args.view .. '.lua'
  ))
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_119').style.display = document.getElementById('autodoc_details_119').style.display ? '' : 'none';">
    execute.action{ ... }
  </div>
  <div id="autodoc_details_119" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>action_status =     <span class="autodoc_comment_tail">-- status code returned by the action (a string)</span>
execute.action{
  module = module,  <span class="autodoc_comment_tail">-- module name of the action to be executed</span>
  action = action,  <span class="autodoc_comment_tail">-- name of the action to be executed</span>
  id     = id,      <span class="autodoc_comment_tail">-- id to be returned by param.get_id(...) during execution</span>
  params = params   <span class="autodoc_comment_tail">-- parameters to be returned by param.get(...) during execution</span>
}</pre>
    </div>
    <div class="autodoc_comment">Executes an action without associated filters.<br/>This function is only used by execute.filtered_action{...}, which itself is only used by the webmcp.lua file in the cgi-bin/ directory.    </div>
    <div class="autodoc_source">
<pre>function execute.action(args)
  local module = args.module
  local action = args.action
  trace.enter_action{ module = module, action = action }
  local action_status = execute.file_path{
    file_path = encode.file_path(
      request.get_app_basepath(),
      'app', request.get_app_name(), module, '_action', action .. '.lua'
    ),
    id     = args.id,
    params = args.params
  }
  trace.execution_return{ status = action_status }
  return action_status
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_120').style.display = document.getElementById('autodoc_details_120').style.display ? '' : 'none';">
    execute.chunk{ ... }
  </div>
  <div id="autodoc_details_120" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>return_value =            <span class="autodoc_comment_tail">-- return value of executed chunk</span>
execute.chunk{
  file_path = file_path,  <span class="autodoc_comment_tail">-- path to a lua source or byte-code file</span>
  app       = app,        <span class="autodoc_comment_tail">-- app name to use or the current will be used</span>
  module    = module,     <span class="autodoc_comment_tail">-- module where chunk is located</span>
  chunk     = chunk       <span class="autodoc_comment_tail">-- name of chunk (filename without .lua extension)</span>
  id        = id,         <span class="autodoc_comment_tail">-- id to be returned by param.get_id(...) during execution</span>
  params    = params      <span class="autodoc_comment_tail">-- parameters to be returned by param.get(...) during execution</span>
}</pre>
    </div>
    <div class="autodoc_comment">This function loads and executes a lua file specified by a given path or constructs<br/>a path to load from the module and chunk name. A chunk name should always begin with an underscore. All return values of the loaded and executed chunk are returned by this function as well.    </div>
    <div class="autodoc_source">
<pre>function execute.chunk(args)
  local file_path = args.file_path
  local app       = args.app
  local module    = args.module
  local chunk     = args.chunk
  local id        = args.id
  local params    = args.params

  app = app or request.get_app_name()

  file_path = file_path or encode.file_path(
    request.get_app_basepath(),
    'app', app, module, chunk .. '.lua'
  )

  local func, load_errmsg = loadfile(file_path)
  if not func then
    error('Could not load file &quot;' .. file_path .. '&quot;: ' .. load_errmsg)
  end

  if id or params then
    param.exchange(id, params)
  end

  local result = {func()}

  if id or params then
    param.restore()
  end

  return table.unpack(result)
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_121').style.display = document.getElementById('autodoc_details_121').style.display ? '' : 'none';">
    execute.config( name )
  </div>
  <div id="autodoc_details_121" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>execute.config(
  name           <span class="autodoc_comment_tail">-- name of the configuration to be loaded</span>
)</pre>
    </div>
    <div class="autodoc_comment">Executes a configuration file of the application.<br/>This function is only used by by the webmcp.lua file in the cgi-bin/ directory.    </div>
    <div class="autodoc_source">
<pre>function execute.config(name)
  trace.enter_config{ name = name }
  execute.file_path{
    file_path = encode.file_path(
      request.get_app_basepath(), 'config', name .. '.lua'
    )
  }
  trace.execution_return()
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_122').style.display = document.getElementById('autodoc_details_122').style.display ? '' : 'none';">
    execute.file_path{ file_path = file_path, id = id, params = params }
  </div>
  <div id="autodoc_details_122" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>status_code =             <span class="autodoc_comment_tail">-- status code returned by the executed lua file (a string)</span>
execute.file_path{
  file_path = file_path,  <span class="autodoc_comment_tail">-- path to a lua source or byte-code file</span>
  id        = id,         <span class="autodoc_comment_tail">-- id to be returned by param.get_id(...) during execution</span>
  params    = params      <span class="autodoc_comment_tail">-- parameters to be returned by param.get(...) during execution</span>
}</pre>
    </div>
    <div class="autodoc_comment">This function loads and executes a lua file specified by a given path. If an &quot;id&quot; or &quot;params&quot; are provided, the param.get_id(...) and/or param.get(...) functions will return the provided values during execution. The lua routine must return true, false, nil or a string. In case of true or nil, this function returns the string &quot;ok&quot;, in case of false, this function returns &quot;error&quot;, otherwise the string returned by the lua routine will be returned by this function as well.    </div>
    <div class="autodoc_source">
<pre>function execute.file_path(args)
  local file_path = args.file_path
  local id        = args.id
  local params    = args.params
  local func, load_errmsg = loadfile(file_path)
  if not func then
    error('Could not load file &quot;' .. file_path .. '&quot;: ' .. load_errmsg)
  end
  if id or params then
    param.exchange(id, params)
  end
  local result = func()
  if result == nil or result == true then
    result = 'ok'
  elseif result == false then
    result = 'error'
  elseif type(result) ~= &quot;string&quot; then
    error(&quot;Unexpected type of result: &quot; .. type(result))
  end
  if id or params then
    param.restore()
  end
  return result
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_123').style.display = document.getElementById('autodoc_details_123').style.display ? '' : 'none';">
    execute.filtered_action{ ... }
  </div>
  <div id="autodoc_details_123" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>action_status =     <span class="autodoc_comment_tail">-- status code returned by the action (a string)</span>
execute.filtered_action{
  module = module,  <span class="autodoc_comment_tail">-- module name of the action to be executed</span>
  action = action,  <span class="autodoc_comment_tail">-- name of the action to be executed</span>
  id     = id,      <span class="autodoc_comment_tail">-- id to be returned by param.get_id(...) during execution</span>
  params = params   <span class="autodoc_comment_tail">-- parameters to be returned by param.get(...) during execution</span>
}</pre>
    </div>
    <div class="autodoc_comment">Executes an action with associated filters.<br/>This function is only used by by the webmcp.lua file in the cgi-bin/ directory.    </div>
    <div class="autodoc_source">
<pre>function execute.filtered_action(args)
  local filters = {}
  local function add_by_path(...)
    execute._add_filters_by_path(filters, ...)
  end
  add_by_path(&quot;_filter&quot;)
  add_by_path(&quot;_filter_action&quot;)
  add_by_path(request.get_app_name(), &quot;_filter&quot;)
  add_by_path(request.get_app_name(), &quot;_filter_action&quot;)
  add_by_path(request.get_app_name(), args.module, &quot;_filter&quot;)
  add_by_path(request.get_app_name(), args.module, &quot;_filter_action&quot;)
  table.sort(filters)
  for idx, filter_name in ipairs(filters) do
    filters[idx] = filters[filter_name]
    filters[filter_name] = nil
  end
  local result
  execute.multi_wrapped(
    filters,
    function()
      result = execute.action(args)
    end
  )
  return result
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_124').style.display = document.getElementById('autodoc_details_124').style.display ? '' : 'none';">
    execute.filtered_view{ module = module, view = view }
  </div>
  <div id="autodoc_details_124" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>execute.filtered_view{
  module = module,  <span class="autodoc_comment_tail">-- module name of the view to be executed</span>
  view   = view     <span class="autodoc_comment_tail">-- name of the view to be executed</span>
}</pre>
    </div>
    <div class="autodoc_comment">Executes a view with associated filters.<br/>This function is only used by by the webmcp.lua file in the cgi-bin/ directory.    </div>
    <div class="autodoc_source">
<pre>function execute.filtered_view(args)
  local filters = {}
  local function add_by_path(...)
    execute._add_filters_by_path(filters, ...)
  end
  add_by_path(&quot;_filter&quot;)
  add_by_path(&quot;_filter_view&quot;)
  add_by_path(request.get_app_name(), &quot;_filter&quot;)
  add_by_path(request.get_app_name(), &quot;_filter_view&quot;)
  add_by_path(request.get_app_name(), args.module, &quot;_filter&quot;)
  add_by_path(request.get_app_name(), args.module, &quot;_filter_view&quot;)
  table.sort(filters)
  for idx, filter_name in ipairs(filters) do
    filters[idx] = filters[filter_name]
    filters[filter_name] = nil
  end
  execute.multi_wrapped(
    filters,
    function()
      execute.view(args)
    end
  )
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_125').style.display = document.getElementById('autodoc_details_125').style.display ? '' : 'none';">
    execute.inner()
  </div>
  <div id="autodoc_details_125" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>execute.inner()</pre>
    </div>
    <div class="autodoc_comment">It is MANDATORY to call this function once in each filter of a WebMCP application. Calling execute.inner() calls the next filter in the filter chain, or the view or action, if there are no more filters following. Code executed BEFORE calling this function is executed BEFORE the view or action, while code executed AFTER calling this function is executed AFTER the view of action.    </div>
    <div class="autodoc_source">
<pre>function execute.inner()
  local stack = execute._wrap_stack
  local pos = #stack
  if pos == 0 then
    error(&quot;Unexpected call of execute.inner().&quot;)
  end
  local inner_func = stack[pos]
  if not inner_func then
    error(&quot;Repeated call of execute.inner().&quot;)
  end
  stack[pos] = false
  inner_func()
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_126').style.display = document.getElementById('autodoc_details_126').style.display ? '' : 'none';">
    execute.load_chunk{ ... }
  </div>
  <div id="autodoc_details_126" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>return_value =            <span class="autodoc_comment_tail">-- return value of executed chunk</span>
execute.load_chunk{
  file_path = file_path,  <span class="autodoc_comment_tail">-- path to a lua source or byte-code file</span>
  app       = app,        <span class="autodoc_comment_tail">-- app name to use or the current will be used</span>
  module    = module,     <span class="autodoc_comment_tail">-- module where chunk is located</span>
  chunk     = chunk       <span class="autodoc_comment_tail">-- filename of lua file to load (including filename extension)</span>
  id        = id,         <span class="autodoc_comment_tail">-- id to be returned by param.get_id(...) during execution</span>
  params    = params      <span class="autodoc_comment_tail">-- parameters to be returned by param.get(...) during execution</span>
}</pre>
    </div>
    <div class="autodoc_comment">NOTE: execute.load_chunk{...} is DEPRECATED and replaced by execute.chunk{...}. Both functions differ in interpretation of argument &quot;chunk&quot; regarding the filename extenstion '.lua'.<br/><br/>This function loads and executes a lua file specified by a given path or constructs<br/>a path to load from the module and chunk name.    </div>
    <div class="autodoc_source">
<pre>function execute.load_chunk(args)
  local chunk_name
  if args.chunk then
    chunk_name = string.match(args.chunk, &quot;^(.*)%.lua$&quot;)
    if not chunk_name then
      error('&quot;chunk_name&quot; does not end with \'.lua\'')
    end
  end
  return execute.chunk{
    file_path = args.file_path,
    app       = args.app,
    module    = args.module,
    chunk     = chunk_name,
    id        = args.id,
    params    = args.params
  }
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_127').style.display = document.getElementById('autodoc_details_127').style.display ? '' : 'none';">
    execute.multi_wrapped( wrapper_funcs, inner_func )
  </div>
  <div id="autodoc_details_127" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>execute.multi_wrapped(
  wrapper_funcs,   <span class="autodoc_comment_tail">-- multiple wrapper functions (i.e. filters)</span>
  inner_func       <span class="autodoc_comment_tail">-- inner function (i.e. an action or view)</span>
)</pre>
    </div>
    <div class="autodoc_comment">This function does the same as execute.wrapped(...), but with multiple wrapper functions, instead of just one wrapper function. It is used by execute.filtered_view{...} and execute.filtered_action{...} to wrap multiple filters around the view or action.    </div>
    <div class="autodoc_source">
<pre>function execute.multi_wrapped(wrapper_funcs, inner_func)
  local function wrapped_execution(pos)
    local wrapper_func = wrapper_funcs[pos]
    if wrapper_func then
      return execute.wrapped(
        wrapper_func,
        function()
          wrapped_execution(pos+1)
        end
      )
    else
      return inner_func()
    end
  end
  return wrapped_execution(1)
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_128').style.display = document.getElementById('autodoc_details_128').style.display ? '' : 'none';">
    execute.view{ ... }
  </div>
  <div id="autodoc_details_128" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>execute.view{
  module = module,  <span class="autodoc_comment_tail">-- module name of the view to be executed</span>
  view   = view,    <span class="autodoc_comment_tail">-- name of the view to be executed</span>
  id     = id,      <span class="autodoc_comment_tail">-- id to be returned by param.get_id(...) during execution</span>
  params = params   <span class="autodoc_comment_tail">-- parameters to be returned by param.get(...) during execution</span>
}</pre>
    </div>
    <div class="autodoc_comment">Executes a view directly (without associated filters).    </div>
    <div class="autodoc_source">
<pre>function execute.view(args)
  local module = args.module
  local view = args.view
  trace.enter_view{ module = module, view = view }
  execute.file_path{
    file_path = encode.file_path(
      request.get_app_basepath(),
      'app', request.get_app_name(), module, view .. '.lua'
    ),
    id     = args.id,
    params = args.params
  }
  trace.execution_return()
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_129').style.display = document.getElementById('autodoc_details_129').style.display ? '' : 'none';">
    execute.wrapped( wrapper_func, inner_func )
  </div>
  <div id="autodoc_details_129" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>execute.wrapped(
  wrapper_func,   <span class="autodoc_comment_tail">-- function with an execute.inner() call inside</span>
  inner_func      <span class="autodoc_comment_tail">-- function which is executed when execute.inner() is called</span>
)</pre>
    </div>
    <div class="autodoc_comment">This function takes two functions as argument. The first function is executed, and must contain one call of execute.inner() during its execution. When execute.inner() is called, the second function is executed. After the second function finished, program flow continues in the first function.    </div>
    <div class="autodoc_source">
<pre>function execute.wrapped(wrapper_func, inner_func)
  if
    type(wrapper_func) ~= &quot;function&quot; or
    type(inner_func) ~= &quot;function&quot;
  then
    error(&quot;Two functions need to be passed to execute.wrapped(...).&quot;)
  end
  local stack = execute._wrap_stack
  local pos = #stack + 1
  stack[pos] = inner_func
  wrapper_func()
  <span class="autodoc_comment_tail">-- if stack[pos] then</span>
  <span class="autodoc_comment_tail">--   error(&quot;Wrapper function did not call execute.inner().&quot;)</span>
  <span class="autodoc_comment_tail">-- end</span>
  stack[pos] = nil
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_130').style.display = document.getElementById('autodoc_details_130').style.display ? '' : 'none';">
    format.boolean{ ... }
  </div>
  <div id="autodoc_details_130" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>text =                      <span class="autodoc_comment_tail">-- human text representation of the boolean</span>
format.boolean(
  value,                    <span class="autodoc_comment_tail">-- true, false or nil</span>
  {
    true_as  = true_text,   <span class="autodoc_comment_tail">-- text representing true</span>
    false_as = false_text,  <span class="autodoc_comment_tail">-- text representing false</span>
    nil_as   = nil_text     <span class="autodoc_comment_tail">-- text representing nil</span>
  }
)</pre>
    </div>
    <div class="autodoc_comment">Returns a human readable text representation of a boolean value. Additional parameters should be given, unless you like the defaults for false and true, which are &quot;0&quot; and &quot;1&quot;.    </div>
    <div class="autodoc_source">
<pre>function format.boolean(value, options)
  local options = options or {}
  local true_text  = options.true_as or &quot;Yes&quot;  <span class="autodoc_comment_tail">-- TODO: localization?</span>
  local false_text = options.false_as or &quot;No&quot;  <span class="autodoc_comment_tail">-- TODO: localization?</span>
  local nil_text   = options.nil_as or &quot;&quot;
  if value == nil then
    return nil_text
  elseif value == false then
    return false_text
  elseif value == true then
    return true_text
  else
    error(&quot;Value passed to format.boolean(...) is neither a boolean nor nil.&quot;)
  end
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_131').style.display = document.getElementById('autodoc_details_131').style.display ? '' : 'none';">
    format.currency{ ... }
  </div>
  <div id="autodoc_details_131" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>text =
format.currency(
  value,
  {
    nil_as                 = nil_text,                <span class="autodoc_comment_tail">-- text to be returned for a nil value</span>
    digits                 = digits,                  <span class="autodoc_comment_tail">-- number of digits before the decimal point</span>
    currency_precision     = currency_precision,      <span class="autodoc_comment_tail">-- number of digits after decimal point</span>
    currency_prefix        = currency_prefix,         <span class="autodoc_comment_tail">-- prefix string, i.e. &quot;$ &quot;</span>
    currency_decimal_point = currency_decimal_point,  <span class="autodoc_comment_tail">-- string to be used as decimal point</span>
    currency_suffix        = currency_suffix,         <span class="autodoc_comment_tail">-- suffix string, i.e. &quot; EUR&quot;</span>
    hide_unit              = hide_unit,               <span class="autodoc_comment_tail">-- hide the currency unit, if true</span>
    decimal_point          = decimal_point            <span class="autodoc_comment_tail">-- used instead of 'currency_decimal_point', if 'hide_unit' is true</span>
  }
)</pre>
    </div>
    <div class="autodoc_comment">Formats a (floating point) number or a fraction as a decimal number. If a 'digits' option is set, the number of digits before the decimal point is increased up to the given count by preceding it with zeros. The digits after the decimal point are adjusted by the 'precision' parameter. The 'decimal_shift' parameter is useful, when fixed precision decimal numbers are stored as integers, as the given value will be divided by 10 to the power of the 'decimal_shift' value prior to formatting. Setting 'decimal_shift' to true will use the 'precision' value as 'decimal_shift'.    </div>
    <div class="autodoc_source">
<pre>function format.currency(value, options)
  local options = table.new(options)
  local prefix
  local suffix
  if options.hide_unit then
    prefix = &quot;&quot;
    suffix = &quot;&quot;
    options.decimal_point =
      options.decimal_point or locale.get(&quot;decimal_point&quot;)
    options.precision =
      options.currency_precision or locale.get(&quot;currency_precision&quot;) or 2
  elseif
    options.currency_prefix or options.currency_suffix or
    options.currency_precision or options.currency_decimal_point
  then
    prefix                = options.currency_prefix or ''
    suffix                = options.currency_suffix or ''
    options.decimal_point = options.currency_decimal_point
    options.precision     = options.currency_precision or 2
  else
    prefix                = locale.get(&quot;currency_prefix&quot;) or ''
    suffix                = locale.get(&quot;currency_suffix&quot;) or ''
    options.decimal_point = locale.get(&quot;currency_decimal_point&quot;)
    options.precision     = locale.get(&quot;currency_precision&quot;) or 2
  end
  if value == nil then
    return options.nil_as or ''
  end
  return prefix .. format.decimal(value, options) .. suffix
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_132').style.display = document.getElementById('autodoc_details_132').style.display ? '' : 'none';">
    format.date( value, { nil_as = nil_text } )
  </div>
  <div id="autodoc_details_132" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>text =                 <span class="autodoc_comment_tail">-- text with the value formatted as a date, according to the locale settings</span>
format.date(
  value,               <span class="autodoc_comment_tail">-- a date, a timestamp or nil</span>
  {
    nil_as = nil_text  <span class="autodoc_comment_tail">-- text to be returned for a nil value</span>
  }
)</pre>
    </div>
    <div class="autodoc_comment">Formats a date or timestamp as a date, according to the locale settings.    </div>
    <div class="autodoc_source">
<pre>function format.date(value, options)
  local options = options or {}
  if value == nil then
    return options.nil_as or &quot;&quot;
  end
  if not (
    atom.has_type(value, atom.date) or
    atom.has_type(value, atom.timestamp)
  ) then
    error(&quot;Value passed to format.date(...) is neither a date, a timestamp, nor nil.&quot;)
  end
  if value.invalid then
    return &quot;invalid&quot;
  end
  local result = locale.get(&quot;date_format&quot;) or &quot;YYYY-MM-DD&quot;
  result = string.gsub(result, &quot;YYYY&quot;, function()
    return format.decimal(value.year, { digits = 4 })
  end)
  result = string.gsub(result, &quot;YY&quot;, function()
    return format.decimal(value.year % 100, { digits = 2 })
  end)
  result = string.gsub(result, &quot;Y&quot;, function()
    return format.decimal(value.year)
  end)
  result = string.gsub(result, &quot;MM&quot;, function()
    return format.decimal(value.month, { digits = 2 })
  end)
  result = string.gsub(result, &quot;M&quot;, function()
    return format.decimal(value.month)
  end)
  result = string.gsub(result, &quot;DD&quot;, function()
    return format.decimal(value.day, { digits = 2 })
  end)
  result = string.gsub(result, &quot;D&quot;, function()
    return format.decimal(value.day)
  end)
  return result
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_133').style.display = document.getElementById('autodoc_details_133').style.display ? '' : 'none';">
    format.decimal{ ... }
  </div>
  <div id="autodoc_details_133" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>text =                             <span class="autodoc_comment_tail">-- text with the value formatted as decimal number</span>
format.decimal(
  value,                           <span class="autodoc_comment_tail">-- a number, a fraction or nil</span>
  {
    nil_as        = nil_text,      <span class="autodoc_comment_tail">-- text to be returned for a nil value</span>
    digits        = digits,        <span class="autodoc_comment_tail">-- digits before decimal point</span>
    precision     = precision,     <span class="autodoc_comment_tail">-- digits after decimal point</span>
    decimal_shift = decimal_shift  <span class="autodoc_comment_tail">-- divide the value by 10^decimal_shift (setting true uses precision)</span>
  }
)</pre>
    </div>
    <div class="autodoc_comment">Formats a (floating point) number or a fraction as a decimal number. If a 'digits' option is set, the number of digits before the decimal point is increased up to the given count by preceding it with zeros. The digits after the decimal point are adjusted by the 'precision' parameter. The 'decimal_shift' parameter is useful, when fixed precision decimal numbers are stored as integers, as the given value will be divided by 10 to the power of the 'decimal_shift' value prior to formatting. Setting 'decimal_shift' to true will copy the value for 'precision'.    </div>
    <div class="autodoc_source">
<pre>function format.decimal(value, options)
  <span class="autodoc_comment_tail">-- TODO: more features</span>
  local options = options or {}
  local special_chars = charset.get_data().special_chars
  local f
  if value == nil then
    return options.nil_as or &quot;&quot;
  elseif atom.has_type(value, atom.number) then
    f = value
  elseif atom.has_type(value, atom.fraction) then
    f = value.float
  else
    error(&quot;Value passed to format.decimal(...) is neither a number nor a fraction nor nil.&quot;)
  end
  local digits = options.digits
  local precision = options.precision or 0
  local decimal_shift = options.decimal_shift or 0
  if decimal_shift == true then
    decimal_shift = precision
  end
  f = f / 10 ^ decimal_shift
  local negative
  local absolute
  if f &lt; 0 then
    absolute = -f
    negative = true
  else
    absolute = f
    negative = false
  end
  absolute = absolute + 0.5 / 10 ^ precision
  local int = math.floor(absolute)
  if not atom.is_integer(int) then
    if f &gt; 0 then
      return &quot;+&quot; .. special_chars.inf_sign
    elseif f &lt; 0 then
      return minus_sign .. special_chars.inf_sign
    else
      return &quot;NaN&quot;
    end
  end
  local int_str = tostring(int)
  if digits then
    while #int_str &lt; digits do
      int_str = &quot;0&quot; .. int_str
    end
  end
  if precision &gt; 0 then
    local decimal_point =
      options.decimal_point or
      locale.get('decimal_point') or '.'
    local frac_str = tostring(math.floor((absolute - int) * 10 ^ precision))
    while #frac_str &lt; precision do
      frac_str = &quot;0&quot; .. frac_str
    end
    assert(#frac_str == precision, &quot;Assertion failed in format.float(...).&quot;)  <span class="autodoc_comment_tail">-- should not happen</span>
    if negative then
      return special_chars.minus_sign .. int_str .. decimal_point .. frac_str
    elseif options.show_plus then
      return &quot;+&quot; .. int_str .. decimal_point .. frac_str
    else
      return int_str .. decimal_point .. frac_str
    end
  else
    if negative then
      return special_chars.minus_sign .. int
    elseif options.show_plus then
      return &quot;+&quot; .. int_str
    else
      return int_str
    end
  end
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_134').style.display = document.getElementById('autodoc_details_134').style.display ? '' : 'none';">
    format.percentage{ ... }
  </div>
  <div id="autodoc_details_134" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>text =                             <span class="autodoc_comment_tail">-- text with the value formatted as a percentage</span>
format.percentage(
  value,                           <span class="autodoc_comment_tail">-- a number, a fraction or nil</span>
  {
    nil_as        = nil_text       <span class="autodoc_comment_tail">-- text to be returned for a nil value</span>
    digits        = digits,        <span class="autodoc_comment_tail">-- digits before decimal point (of the percentage value)</span>
    precision     = precision,     <span class="autodoc_comment_tail">-- digits after decimal point (of the percentage value)</span>
    decimal_shift = decimal_shift  <span class="autodoc_comment_tail">-- divide the value by 10^decimal_shift (setting true uses precision + 2)</span>
  }
)</pre>
    </div>
    <div class="autodoc_comment">Formats a number or fraction as a percentage.    </div>
    <div class="autodoc_source">
<pre>function format.percentage(value, options)
  local options = table.new(options)
  local f
  if value == nil then
    return options.nil_as or &quot;&quot;
  elseif atom.has_type(value, atom.number) then
    f = value
  elseif atom.has_type(value, atom.fraction) then
    f = value.float
  else
    error(&quot;Value passed to format.percentage(...) is neither a number nor a fraction nor nil.&quot;)
  end
  options.precision = options.precision or 0
  if options.decimal_shift == true then
    options.decimal_shift = options.precision + 2
  end
  local suffix = options.hide_unit and &quot;&quot; or &quot; %&quot;
  return format.decimal(f * 100, options) .. suffix
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_135').style.display = document.getElementById('autodoc_details_135').style.display ? '' : 'none';">
    format.string( value, { nil_as = nil_text } )
  </div>
  <div id="autodoc_details_135" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>text =                 <span class="autodoc_comment_tail">-- a string</span>
format.string(
  value,               <span class="autodoc_comment_tail">-- any value where tostring(value) gives a reasonable result</span>
  {
    nil_as = nil_text  <span class="autodoc_comment_tail">-- text to be returned for a nil value</span>
  }
)</pre>
    </div>
    <div class="autodoc_comment">Formats a value as a text by calling tostring(...), unless the value is nil, in which case the text returned is chosen by the 'nil_as' option.    </div>
    <div class="autodoc_source">
<pre>function format.string(str, options)
  local options = options or {}
  if str == nil then
    return options.nil_as or &quot;&quot;
  else
    return tostring(str)
  end
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_136').style.display = document.getElementById('autodoc_details_136').style.display ? '' : 'none';">
    format.time( value, { nil_as = nil_text } )
  </div>
  <div id="autodoc_details_136" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>text =                 <span class="autodoc_comment_tail">-- text with the value formatted as a time, according to the locale settings</span>
format.time(
  value,               <span class="autodoc_comment_tail">-- a time, a timestamp or nil</span>
  {
    nil_as = nil_text  <span class="autodoc_comment_tail">-- text to be returned for a nil value</span>
  }
)</pre>
    </div>
    <div class="autodoc_comment">Formats a time or timestamp as a time, according to the locale settings.    </div>
    <div class="autodoc_source">
<pre>function format.time(value, options)
  local options = options or {}
  if value == nil then
    return options.nil_as or &quot;&quot;
  end
  if not (
    atom.has_type(value, atom.time) or
    atom.has_type(value, atom.timestamp)
  ) then
    error(&quot;Value passed to format.time(...) is neither a time, a timestamp, nor nil.&quot;)
  end
  if value.invalid then
    return &quot;invalid&quot;
  end
  local result = locale.get(&quot;time_format&quot;) or &quot;HH:MM{:SS}&quot;
  if options.hide_seconds then
    result = string.gsub(result, &quot;{[^{|}]*}&quot;, &quot;&quot;)
  else
    result = string.gsub(result, &quot;{([^|]*)}&quot;, &quot;%1&quot;)
  end
  local am_pm
  local hour = value.hour
  result = string.gsub(result, &quot;{([^{}]*)|([^{}]*)}&quot;, function(am, pm)
    if hour &gt; 12 then
      am_pm = pm
    else
      am_pm = am
    end
    return &quot;{|}&quot;
  end)
  if am_pm and hour &gt; 12 then
    hour = hour - 12
  end
  result = string.gsub(result, &quot;HH&quot;, function()
    return format.decimal(hour, { digits = 2 })
  end)
  result = string.gsub(result, &quot;MM&quot;, function()
    return format.decimal(value.minute, { digits = 2 })
  end)
  result = string.gsub(result, &quot;SS&quot;, function()
    return format.decimal(value.second, { digits = 2 })
  end)
  if am_pm then
    result = string.gsub(result, &quot;{|}&quot;, am_pm)
  end
  return result
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_137').style.display = document.getElementById('autodoc_details_137').style.display ? '' : 'none';">
    format.timestamp( value, { nil_as = nil_text } )
  </div>
  <div id="autodoc_details_137" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>text =                 <span class="autodoc_comment_tail">-- text with the given timestamp value formatted according to the locale settings</span>
format.timestamp(
  value,               <span class="autodoc_comment_tail">-- a timestamp or nil</span>
  {
    nil_as = nil_text  <span class="autodoc_comment_tail">-- text to be returned for a nil value</span>
  }
)</pre>
    </div>
    <div class="autodoc_comment">Formats a timestamp according to the locale settings.    </div>
    <div class="autodoc_source">
<pre>function format.timestamp(value, options)
  if value == nil then
    return options.nil_as or &quot;&quot;
  end
  return format.date(value, options) .. &quot; &quot; .. format.time(value, options)
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_138').style.display = document.getElementById('autodoc_details_138').style.display ? '' : 'none';">
    locale.do_with( locale_options, function() ... end )
  </div>
  <div id="autodoc_details_138" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>locale.do_with(
  locale_options,  <span class="autodoc_comment_tail">-- table with locale information (as if passed to locale.set(...))</span>
  function()
    ...            <span class="autodoc_comment_tail">-- code to be executed with the given locale settings</span>
  end
)</pre>
    </div>
    <div class="autodoc_comment">This function executes code with temporarily changed locale settings. See locale.set(...) for correct usage of 'locale_options'.    </div>
    <div class="autodoc_source">
<pre>function locale.do_with(locale_options, block)
  local old_data = {}
  for key, value in pairs(locale._current_data) do
    old_data[key] = value
  end
  locale.set(locale_options)
  block()
  old_data.reset = true
  locale.set(old_data)
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_139').style.display = document.getElementById('autodoc_details_139').style.display ? '' : 'none';">
    locale.get( category )
  </div>
  <div id="autodoc_details_139" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>locale_setting =  <span class="autodoc_comment_tail">-- setting for the given localization category (could be of any type, depending on the category)</span>
locale.get(
  category        <span class="autodoc_comment_tail">-- string selecting a localization category, e.g. &quot;lang&quot; or &quot;time&quot;, etc...</span>
)</pre>
    </div>
    <div class="autodoc_comment">This function is used to read locale settings, which have been set with locale.set(...) or locale.do_with(...).    </div>
    <div class="autodoc_source">
<pre>function locale.get(category)
  return locale._current_data[category]
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_140').style.display = document.getElementById('autodoc_details_140').style.display ? '' : 'none';">
    locale.set( locale_options )
  </div>
  <div id="autodoc_details_140" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>locale.set(
  locale_options  <span class="autodoc_comment_tail">-- table with locale categories as keys and their settings as values</span>
)</pre>
    </div>
    <div class="autodoc_comment">This function is used to set locale settings. The table given as first and only argument contains locale categories (e.g. &quot;lang&quot; or &quot;time&quot;) as keys, and their settings as values. If there is a key 'reset' with a true value, then all non mentioned categories will be reset to nil.    </div>
    <div class="autodoc_source">
<pre>function locale.set(locale_options)
  if locale_options.reset then
    locale._current_data = {}
  end
  for key, value in pairs(locale_options) do
    if key ~= &quot;reset&quot; then
      locale._current_data[key] = value
    end
  end
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_141').style.display = document.getElementById('autodoc_details_141').style.display ? '' : 'none';">
    mondelefant.attach{ ... }
  </div>
  <div id="autodoc_details_141" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>mondelefant.attach(
  mode,              <span class="autodoc_comment_tail">-- attachment type: &quot;11&quot; one to one, &quot;1m&quot; one to many, &quot;m1&quot; many to one</span>
  data1,             <span class="autodoc_comment_tail">-- first database result list or object</span>
  data2,             <span class="autodoc_comment_tail">-- second database result list or object</span>
  key1,              <span class="autodoc_comment_tail">-- field name(s) in first result list or object used for attaching</span>
  key2,              <span class="autodoc_comment_tail">-- field name(s) in second result list or object used for attaching</span>
  ref1,              <span class="autodoc_comment_tail">-- name of reference field to be set in first database result list or object</span>
  ref2               <span class="autodoc_comment_tail">-- name of reference field to be set in second database result list or object</span>
)</pre>
    </div>
    <div class="autodoc_comment">This function attaches database result lists/objects with each other. It does not need to be called directly.    </div>
    <div class="autodoc_source">
<pre>function attach(mode, data1, data2, key1, key2, ref1, ref2)
  local many1, many2
  if mode == &quot;11&quot; then
    many1 = false
    many2 = false
  elseif mode == &quot;1m&quot; then
    many1 = false
    many2 = true
  elseif mode == &quot;m1&quot; then
    many1 = true
    many2 = false
  elseif mode == &quot;mm&quot; then
    many1 = true
    many2 = true
  else
    error(&quot;Unknown mode specified for 'mondelefant.attach'.&quot;)
  end
  local list1, list2
  if data1._type == &quot;object&quot; then
    list1 = { data1 }
  elseif data1._type == &quot;list&quot; then
    list1 = data1
  else
    error(&quot;First result data given to 'mondelefant.attach' is invalid.&quot;)
  end
  if data2._type == &quot;object&quot; then
    list2 = { data2 }
  elseif data2._type == &quot;list&quot; then
    list2 = data2
  else
    error(&quot;Second result data given to 'mondelefant.attach' is invalid.&quot;)
  end
  local hash1 = {}
  local hash2 = {}
  if ref2 then
    for i, row in ipairs(list1) do
      local key = attach_key(row, key1)
      local list = hash1[key]
      if not list then list = {}; hash1[key] = list end
      list[#list + 1] = row
    end
  end
  if ref1 then
    for i, row in ipairs(list2) do
      local key = attach_key(row, key2)
      local list = hash2[key]
      if not list then list = {}; hash2[key] = list end
      list[#list + 1] = row
    end
    for i, row in ipairs(list1) do
      local key = attach_key(row, key1)
      local matching_rows = hash2[key]
      if many2 then
        local list = data2._connection:create_list(matching_rows)
        list._class = data2._class
        row._ref[ref1] = list
      elseif matching_rows and #matching_rows == 1 then
        row._ref[ref1] = matching_rows[1]
      else
        row._ref[ref1] = false
      end
    end
  end
  if ref2 then
    for i, row in ipairs(list2) do
      local key = attach_key(row, key2)
      local matching_rows = hash1[key]
      if many1 then
        local list = data1._connection:create_list(matching_rows)
        list._class = data1._class
        row._ref[ref2] = list
      elseif matching_rows and #matching_rows == 1 then
        row._ref[ref2] = matching_rows[1]
      else
        row._ref[ref2] = false
      end
    end
  end
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_142').style.display = document.getElementById('autodoc_details_142').style.display ? '' : 'none';">
    mondelefant.connect{ ... }
  </div>
  <div id="autodoc_details_142" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>db_handle,                            <span class="autodoc_comment_tail">-- database handle, or nil in case of error</span>
errmsg,                               <span class="autodoc_comment_tail">-- error message</span>
errcode =                             <span class="autodoc_comment_tail">-- error code</span>
mondelefant.connect{
  engine          = &quot;postgresql&quot;,     <span class="autodoc_comment_tail">-- no other engine is supported</span>
  conninfo        = conninfo,         <span class="autodoc_comment_tail">-- string passed directly to PostgreSQL's libpq</span>
  host            = host,             <span class="autodoc_comment_tail">-- hostname or directory with leading slash where Unix-domain socket resides</span>
  hostaddr        = hostaddr,         <span class="autodoc_comment_tail">-- IPv4, or IPv6 address if supported</span>
  port            = port,             <span class="autodoc_comment_tail">-- TCP port or socket file name extension</span>
  dbname          = dbname,           <span class="autodoc_comment_tail">-- name of database to connect with</span>
  user            = user,             <span class="autodoc_comment_tail">-- login name</span>
  password        = password,         <span class="autodoc_comment_tail">-- password</span>
  connect_timeout = connect_timeout,  <span class="autodoc_comment_tail">-- seconds to wait for connection to be established. Zero or nil means infinite</span>
  ...
}</pre>
    </div>
    <div class="autodoc_comment">Opens a new database connection and returns a handle for that connection. You may chose to specify host, port, dbname, etc. as seperated arguments, or to use a &quot;conninfo&quot; string, which is directly passed to PostgreSQL's libpq.    </div>
    <div class="autodoc_source">
<pre><span class="autodoc_comment_tail">-- implemented in mondelefant_native.c as</span>
<span class="autodoc_comment_tail">-- static int mondelefant_connect(lua_State *L)</span></pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_143').style.display = document.getElementById('autodoc_details_143').style.display ? '' : 'none';">
    mondelefant.new_class()
  </div>
  <div id="autodoc_details_143" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>db_class =               <span class="autodoc_comment_tail">-- new database class (model)</span>
mondelefant.new_class()</pre>
    </div>
    <div class="autodoc_comment">This function creates a new class (model) used for database result lists or objects.    </div>
    <div class="autodoc_source">
<pre><span class="autodoc_comment_tail">-- implemented in mondelefant_native.c as</span>
<span class="autodoc_comment_tail">-- static int mondelefant_new_class(lua_State *L)</span></pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_144').style.display = document.getElementById('autodoc_details_144').style.display ? '' : 'none';">
    mondelefant.set_class( db_list_or_object, db_class )
  </div>
  <div id="autodoc_details_144" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>db_list_or_object =     <span class="autodoc_comment_tail">-- first argument is returned</span>
mondelefant.set_class(
  db_list_or_object,    <span class="autodoc_comment_tail">-- database result list or object</span>
  db_class              <span class="autodoc_comment_tail">-- database class (model)</span>
)</pre>
    </div>
    <div class="autodoc_comment">This function sets a class for a given database result list or object. If a result list is given as first argument, the class is also set for all elements of the list.    </div>
    <div class="autodoc_source">
<pre><span class="autodoc_comment_tail">-- implemented in mondelefant_native.c as</span>
<span class="autodoc_comment_tail">-- static int mondelefant_set_class(lua_State *L)</span></pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_145').style.display = document.getElementById('autodoc_details_145').style.display ? '' : 'none';">
    net.send_mail{ ... }
  </div>
  <div id="autodoc_details_145" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>success =                          <span class="autodoc_comment_tail">-- true, if mail has been sent successfully, otherwise false</span>
net.send_mail{
  envelope_from = envelope_from,   <span class="autodoc_comment_tail">-- envelope from address, not part of mail headers</span>
  from          = from,            <span class="autodoc_comment_tail">-- From     header address or table with 'name' and 'address' fields</span>
  sender        = sender,          <span class="autodoc_comment_tail">-- Sender   header address or table with 'name' and 'address' fields</span>
  reply_to      = reply_to,        <span class="autodoc_comment_tail">-- Reply-To header address or table with 'name' and 'address' fields</span>
  to            = to,              <span class="autodoc_comment_tail">-- To       header address or table with 'name' and 'address' fields</span>
  cc            = cc,              <span class="autodoc_comment_tail">-- Cc       header address or table with 'name' and 'address' fields</span>
  bcc           = bcc,             <span class="autodoc_comment_tail">-- Bcc      header address or table with 'name' and 'address' fields</span>
  subject       = subject,         <span class="autodoc_comment_tail">-- subject of e-mail</span>
  multipart     = multipart_type,  <span class="autodoc_comment_tail">-- &quot;alternative&quot;, &quot;mixed&quot;, &quot;related&quot;, or nil</span>
  content_type  = content_type,    <span class="autodoc_comment_tail">-- only for multipart == nil, defaults to &quot;text/plain&quot;</span>
  binary        = binary,          <span class="autodoc_comment_tail">-- allow full 8-bit content</span>
  content       = content or {     <span class="autodoc_comment_tail">-- content as lua-string, or table in case of multipart</span>
    {
      multipart = multipart_type,
      ...,
      content   = content or {
        {...}, ...
      }
    }, {
      ...
    },
    ...
  }
}</pre>
    </div>
    <div class="autodoc_comment">This function sends a mail using the /usr/sbin/sendmail command. It returns true on success, otherwise false.    </div>
    <div class="autodoc_source">
<pre>function net.send_mail(args)
  local mail
  if type(args) == &quot;string&quot; then
    mail = args
  else
    mail = encode.mime.mail(args)
  end
  local envelope_from = args.envelope_from
  local command = {&quot;/usr/sbin/sendmail&quot;, &quot;-t&quot;, &quot;-i&quot;}
  if
    envelope_from and
    string.find(envelope_from, &quot;^[0-9A-Za-z%.-_@0-9A-Za-z%.-_]+$&quot;)
  then
    command[#command+1] = &quot;-f&quot;
    command[#command+1] = envelope_from
  end
  local stdout, errmsg, status = extos.pfilter(mail, table.unpack(command))
  if not status then
    error(&quot;Error while calling sendmail: &quot; .. errmsg)
  end
  if status == 0 then
    return true
  else
    return false
  end
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_146').style.display = document.getElementById('autodoc_details_146').style.display ? '' : 'none';">
    param.exchange( id, params )
  </div>
  <div id="autodoc_details_146" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>param.exchange(
  id,
  params
)</pre>
    </div>
    <div class="autodoc_comment">This function exchanges the id and/or parameters which are returned by param.get_id(...), param.get(...), etc. It should not be called explicitly, but is used implicitly, if you pass an 'id' or 'params' option to execute.view{...} or execute.action{...}. The function param.restore() is used to revert the exchange.    </div>
    <div class="autodoc_source">
<pre>function param.exchange(id, params)
  table.insert(param._saved, param._exchanged)
  param._exchanged = { id = id, params = params }
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_147').style.display = document.getElementById('autodoc_details_147').style.display ? '' : 'none';">
    param.get( key, param_type )
  </div>
  <div id="autodoc_details_147" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>value =       <span class="autodoc_comment_tail">-- value of the parameter casted to the chosen param_type</span>
param.get(
  key,        <span class="autodoc_comment_tail">-- name of the parameter</span>
  param_type  <span class="autodoc_comment_tail">-- desired type of the returned value</span>
)</pre>
    </div>
    <div class="autodoc_comment">Either a GET or POST request parameter is returned by this function, or if param.exchange(...) was called before, one of the exchanged parameters is returned. You can specify which type the returned value shall have. If an external request parameter was used and there is another GET or POST parameter with the same name but a &quot;__format&quot; suffix, the parser with the name of the specified format will be automatically used to parse and convert the input value.    </div>
    <div class="autodoc_source">
<pre>function param.get(key, param_type)
  local param_type = param_type or atom.string
  if param._exchanged then
    local value = param._exchanged.params[key]
    if value ~= nil and not atom.has_type(value, param_type) then
      error(&quot;Parameter has unexpected type.&quot;)
    end
    return value
  else
    local str         = cgi.params[key]
    local format_info = cgi.params[key .. &quot;__format&quot;]
    if not str then
      if not format_info then
        return nil
      end
      str = &quot;&quot;
    end
    return param._get_parser(format_info, param_type)(str)
  end
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_148').style.display = document.getElementById('autodoc_details_148').style.display ? '' : 'none';">
    param.get_all_cgi()
  </div>
  <div id="autodoc_details_148" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>params =
param.get_all_cgi()</pre>
    </div>
    <div class="autodoc_comment">Deprecated. Alias for request.get_param_strings().    </div>
    <div class="autodoc_source">
<pre><span class="autodoc_comment_tail">-- TODO: Remove this function.</span>

function param.get_all_cgi()
  return request.get_param_strings()
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_149').style.display = document.getElementById('autodoc_details_149').style.display ? '' : 'none';">
    param.get_id( param_type )
  </div>
  <div id="autodoc_details_149" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>value =        <span class="autodoc_comment_tail">-- value of the id casted to the chosen param_type</span>
param.get_id(
  param_type   <span class="autodoc_comment_tail">-- desired type of the returned value</span>
)</pre>
    </div>
    <div class="autodoc_comment">Same as param.get(...), but operates on a special id parameter. An id is set via a __webmcp_id GET or POST parameter or an 'id' option to execute.view{...} or execute.action{...}. In a normal setup a beauty URL of the form http://www.example.com/example-application/example-module/example-view/&lt;id&gt;.html will cause the id to be set.    </div>
    <div class="autodoc_source">
<pre>function param.get_id(param_type)
  local param_type = param_type or atom.integer
  if param._exchanged then
    local value = param._exchanged.id
    if value ~= nil and not atom.has_type(value, param_type) then
      error(&quot;Parameter has unexpected type.&quot;)
    end
    return value
  else
    local str = request.get_id_string()
    if str then
      return param._get_parser(nil, param_type)(str)
    else
      return nil
    end
  end
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_150').style.display = document.getElementById('autodoc_details_150').style.display ? '' : 'none';">
    param.get_id_cgi()
  </div>
  <div id="autodoc_details_150" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>value =             <span class="autodoc_comment_tail">-- id as string (or other type after if params.exchange(...) has been used), or nil</span>
param.get_id_cgi()</pre>
    </div>
    <div class="autodoc_comment">Deprecated. Alias for request.get_id_string().    </div>
    <div class="autodoc_source">
<pre><span class="autodoc_comment_tail">-- TODO: Remove this function.</span>

function param.get_id_cgi()
  return request.get_id_string()
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_151').style.display = document.getElementById('autodoc_details_151').style.display ? '' : 'none';">
    param.get_list( key, param_type, )
  </div>
  <div id="autodoc_details_151" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>values =         <span class="autodoc_comment_tail">-- list of values casted to the chosen param_type</span>
param.get_list(
  key,           <span class="autodoc_comment_tail">-- name of the parameter without &quot;[]&quot; suffix</span>
  param_type,    <span class="autodoc_comment_tail">-- desired type of the returned values</span>
)</pre>
    </div>
    <div class="autodoc_comment">Same as param.get(...), but used for parameters which contain a list of values. For external GET/POST parameters the parameter name gets suffixed with &quot;[]&quot;.    </div>
    <div class="autodoc_source">
<pre>function param.get_list(key, param_type)
  local param_type = param_type or atom.string
  if param._exchanged then
    local values = param._exchanged.params[key] or {}
    if type(values) ~= &quot;table&quot; then
      error(&quot;Parameter has unexpected type.&quot;)
    end
    for idx, value in ipairs(values) do
      if not atom.has_type(value, param_type) then
        error(&quot;Element of parameter list has unexpected type.&quot;)
      end
    end
    return values
  else
    local format_info = cgi.params[key .. &quot;__format&quot;]
    local parser = param._get_parser(format_info, param_type)
    local raw_values = cgi.params[key .. &quot;[]&quot;]
    local values = {}
    if raw_values then
      for idx, value in ipairs(raw_values) do
        values[idx] = parser(raw_values[idx])
      end
    end
    return values
  end
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_152').style.display = document.getElementById('autodoc_details_152').style.display ? '' : 'none';">
    param.get_param_strings()
  </div>
  <div id="autodoc_details_152" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>params =
param.get_param_strings()</pre>
    </div>
    <div class="autodoc_comment">This function returns a table with all raw GET/POST parameters as strings or list of strings (except internal parameters like &quot;_webmcp_path&quot; or &quot;_webmcp_id&quot;). Modifications of the returned table have no side effects.    </div>
    <div class="autodoc_source">
<pre>function request.get_param_strings()
  local t = {}
  for key, value in pairs(request._params) do
    if type(value) == 'table' then
      t[key] = table.new(value)
    else
      t[key] = value
    end
  end
  return t
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_153').style.display = document.getElementById('autodoc_details_153').style.display ? '' : 'none';">
    param.iterate( prefix )
  </div>
  <div id="autodoc_details_153" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>for
  index,          <span class="autodoc_comment_tail">-- index variable counting up from 1</span>
  prefix          <span class="autodoc_comment_tail">-- prefix string with index in square brackets to be used as a prefix for a key passed to param.get or param.get_list</span>
in
  param.iterate(
    prefix        <span class="autodoc_comment_tail">-- prefix to be followed by an index in square brackets and another key</span>
  )
do
  ...
end</pre>
    </div>
    <div class="autodoc_comment">This function returns an interator function to be used in a for loop. The CGI GET/POST parameter (or internal parameter) with the name &quot;prefix[len]&quot; is read, where 'prefix' is the prefix passed as the argument and 'len' ist just the literal string &quot;len&quot;. For each index from 1 to the read length the returned iterator function returns the index and a string consisting of the given prefix followed by the index in square brackets to be used as a prefix for keys passed to param.get(...) or param.get_list(...).    </div>
    <div class="autodoc_source">
<pre>function param.iterate(prefix)
  local length = param.get(prefix .. &quot;[len]&quot;, atom.integer) or 0
  if not atom.is_integer(length) then
    error(&quot;List length is not a valid integer or nil.&quot;)
  end
  local index = 0
  return function()
    index = index + 1
    if index &lt;= length then
      return index, prefix .. &quot;[&quot; .. index .. &quot;]&quot;
    end
  end
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_154').style.display = document.getElementById('autodoc_details_154').style.display ? '' : 'none';">
    param.restore()
  </div>
  <div id="autodoc_details_154" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>param.restore()</pre>
    </div>
    <div class="autodoc_comment">Calling this function reverts the changes of param.exchange(...). It should not be called explicitly, but is used implicitly, if you pass an 'id' or 'params' option to execute.view{...} or execute.action{...}.    </div>
    <div class="autodoc_source">
<pre>function param.restore()
  local saved = param._saved
  local previous = saved[#saved]
  saved[#saved] = nil
  if previous == nil then
    error(&quot;Tried to restore id and params without having exchanged it before.&quot;)
  end
  param._exchanged = previous
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_155').style.display = document.getElementById('autodoc_details_155').style.display ? '' : 'none';">
    param.update_relationship{ ... }
  </div>
  <div id="autodoc_details_155" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>param.update_relationship{
  param_name        = param_name,        <span class="autodoc_comment_tail">-- name of request GET/POST request parameters containing primary keys for model B</span>
  id                = id,                <span class="autodoc_comment_tail">-- value of the primary key for model A</span>
  connecting_model  = connecting_model,  <span class="autodoc_comment_tail">-- model used for creating/deleting entries referencing both model A and B</span>
  own_reference     = own_reference,     <span class="autodoc_comment_tail">-- field name for foreign key in the connecting model referencing model A</span>
  foreign_reference = foreign_reference  <span class="autodoc_comment_tail">-- field name for foreign key in the connecting model referencing model B</span>
}</pre>
    </div>
    <div class="autodoc_comment">This function updates a many-to-many relationship using a specified 'connecting_model' referencing both models.    </div>
    <div class="autodoc_source">
<pre>function param.update_relationship(args)
  local param_name        = args.param_name
  local id                = args.id
  local connecting_model  = args.connecting_model
  local own_reference     = args.own_reference
  local foreign_reference = args.foreign_reference
  local selected_ids = param.get_list(param_name, atom.integer)  <span class="autodoc_comment_tail">-- TODO: support other types than integer too</span>
  local db    = connecting_model:get_db_conn()
  local table = connecting_model:get_qualified_table()
  if #selected_ids == 0 then
    db:query{
      'DELETE FROM ' .. table .. ' WHERE &quot;' .. own_reference .. '&quot; = ?',
      args.id
    }
  else
    local selected_ids_sql = { sep = &quot;, &quot; }
    for idx, value in ipairs(selected_ids) do
      selected_ids_sql[idx] = {&quot;?::int8&quot;, value}
    end
    db:query{
      'DELETE FROM ' .. table ..
      ' WHERE &quot;' .. own_reference .. '&quot; = ?' ..
      ' AND NOT &quot;' .. foreign_reference .. '&quot; IN ($)',
      args.id,
      selected_ids_sql
    }
    <span class="autodoc_comment_tail">-- TODO: use VALUES SQL command, instead of this dirty array trick</span>
    db:query{
      'INSERT INTO ' .. table ..
      ' (&quot;' .. own_reference .. '&quot;, &quot;' .. foreign_reference .. '&quot;)' ..
      ' SELECT ?, &quot;subquery&quot;.&quot;foreign&quot; FROM (' ..
        'SELECT (ARRAY[$])[i] AS &quot;foreign&quot;' ..
        ' FROM generate_series(1, ?) AS &quot;dummy&quot;(&quot;i&quot;)' ..
        ' EXCEPT SELECT &quot;' .. foreign_reference .. '&quot; AS &quot;foreign&quot;' ..
        ' FROM ' .. table ..
        ' WHERE &quot;' .. own_reference .. '&quot; = ?' ..
      ') AS &quot;subquery&quot;',
      args.id,
      selected_ids_sql,
      #selected_ids,
      args.id
    }
  end
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_156').style.display = document.getElementById('autodoc_details_156').style.display ? '' : 'none';">
    param.update{ ... }
  </div>
  <div id="autodoc_details_156" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>param.update(
  record,               <span class="autodoc_comment_tail">-- database record to be updated</span>
  key_and_field_name1,  <span class="autodoc_comment_tail">-- name of CGI parameter and record field</span>
  key_and_field_name2,  <span class="autodoc_comment_tail">-- another name of a CGI parameter and record field</span>
  {
    key3,               <span class="autodoc_comment_tail">-- name of CGI parameter</span>
    field_name3         <span class="autodoc_comment_tail">-- name of record field</span>
  }
)</pre>
    </div>
    <div class="autodoc_comment">This function can update several fields of a database record using GET/POST request parameters (or internal/exchanged parameters). The type of each parameter is automatically determined by the class of the record (_class:get_colums()[field].type).    </div>
    <div class="autodoc_source">
<pre>function param.update(record, mapping_info, ...)
  if not mapping_info then
    return
  end
  assert(record, &quot;No record given for param.update(...).&quot;)
  assert(record._class, &quot;Record passed to param.update(...) has no _class attribute.&quot;)
  local key, field_name
  if type(mapping_info) == &quot;string&quot; then
    key        = mapping_info
    field_name = mapping_info
  else
    key        = mapping_info[1]
    field_name = mapping_info[2]
  end
  assert(key, &quot;No key given in parameter of param.update(...).&quot;)
  assert(field_name, &quot;No field name given in parameter of param.update(...).&quot;)
  local column_info = record._class:get_columns()[field_name]
  if not column_info then
    error('Type of column &quot;' .. field_name .. '&quot; is unknown.')
  end
  local new_value = param.get(key, column_info.type)
  if new_value ~= record[field_name] then
    record[field_name] = new_value
  end
  return param.update(record, ...)  <span class="autodoc_comment_tail">-- recursivly process following arguments</span>
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_157').style.display = document.getElementById('autodoc_details_157').style.display ? '' : 'none';">
    request.force_absolute_baseurl()
  </div>
  <div id="autodoc_details_157" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>request.force_absolute_baseurl()</pre>
    </div>
    <div class="autodoc_comment">Calling this function causes subsequent calls of request.get_relative_baseurl() to return absolute URLs instead.    </div>
    <div class="autodoc_source">
<pre>function request.force_absolute_baseurl()
  request._force_absolute_baseurl = true
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_158').style.display = document.getElementById('autodoc_details_158').style.display ? '' : 'none';">
    request.forward{ module = module, view = view }
  </div>
  <div id="autodoc_details_158" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>request.forward{
  module = module,  <span class="autodoc_comment_tail">-- module name</span>
  view   = view     <span class="autodoc_comment_tail">-- view name</span>
}</pre>
    </div>
    <div class="autodoc_comment">This function is called automatically to forward to another view, after an action and all its filters have finished execution, if routing mode &quot;forward&quot; has been chosen. Calling request.forward{...} (or request.redirect{...}) explicitly inside an action will cause routing information from the browser to be ignored. Calling request.forward{...} causes all GET/POST parameters of the action to be preserved for the given view.    </div>
    <div class="autodoc_source">
<pre>function request.forward(args)
  if request.is_rerouted() then
    error(&quot;Tried to forward after another forward or redirect.&quot;)
  end
  request._forward = args
  trace.forward { module = args.module, view = args.view }
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_159').style.display = document.getElementById('autodoc_details_159').style.display ? '' : 'none';">
    request.get_404_route()
  </div>
  <div id="autodoc_details_159" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>route_info =             <span class="autodoc_comment_tail">-- table with 'module' and 'view' field</span>
request.get_404_route()</pre>
    </div>
    <div class="autodoc_comment">Returns the data passed to a previous call of request.set_404_route{...}, or nil.    </div>
    <div class="autodoc_source">
<pre>function request.get_404_route()
  return request._404_route
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_160').style.display = document.getElementById('autodoc_details_160').style.display ? '' : 'none';">
    request.get_absolute_baseurl()
  </div>
  <div id="autodoc_details_160" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>baseurl =
request.get_absolute_baseurl()</pre>
    </div>
    <div class="autodoc_comment">This function returns the absolute base URL of the application, as set by request.set_absolute_baseurl(...).    </div>
    <div class="autodoc_source">
<pre>function request.get_absolute_baseurl()
  if request._absolute_baseurl then
    return request._absolute_baseurl
  else
    error(&quot;Absolute base URL is unknown. It should be set in the configuration by calling request.set_absolute_baseurl(...).&quot;)
  end
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_161').style.display = document.getElementById('autodoc_details_161').style.display ? '' : 'none';">
    request.get_action()
  </div>
  <div id="autodoc_details_161" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>action_name =
request.get_action()</pre>
    </div>
    <div class="autodoc_comment">Returns the name of the currently requested action, or nil in case of a view.    </div>
    <div class="autodoc_source">
<pre>function request.get_action()
  if request._forward_processed then
    return nil
  else
    return request._action
  end
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_162').style.display = document.getElementById('autodoc_details_162').style.display ? '' : 'none';">
    request.get_app_basepath()
  </div>
  <div id="autodoc_details_162" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>path =                      <span class="autodoc_comment_tail">-- path to directory of application with trailing slash</span>
request.get_app_basepath()</pre>
    </div>
    <div class="autodoc_comment">This function returns the path to the base directory of the application. A trailing slash is always included.    </div>
    <div class="autodoc_source">
<pre>function request.get_app_basepath()
  return request._app_basepath
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_163').style.display = document.getElementById('autodoc_details_163').style.display ? '' : 'none';">
    request.get_app_name()
  </div>
  <div id="autodoc_details_163" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>app_name =
request.get_app_name()</pre>
    </div>
    <div class="autodoc_comment">Returns the application name set by the environment variable 'WEBMCP_APP_NAME', or &quot;main&quot; as default application name, if the environment variable is unset.    </div>
    <div class="autodoc_source">
<pre>function request.get_app_name()
  return os.getenv(&quot;WEBMCP_APP_NAME&quot;) or 'main'
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_164').style.display = document.getElementById('autodoc_details_164').style.display ? '' : 'none';">
    request.get_config_name()
  </div>
  <div id="autodoc_details_164" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>config_name =
request.get_config_name()</pre>
    </div>
    <div class="autodoc_comment">Returns the name of the configuration selected by the environment variable 'WEBMCP_CONFIG_NAME', or nil if the environment variable is not set.    </div>
    <div class="autodoc_source">
<pre>function request.get_config_name()
  return os.getenv(&quot;WEBMCP_CONFIG_NAME&quot;)
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_165').style.display = document.getElementById('autodoc_details_165').style.display ? '' : 'none';">
    request.get_csrf_secret()
  </div>
  <div id="autodoc_details_165" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>secret =                   <span class="autodoc_comment_tail">-- secret string, previously set with request.set_csrf_secret(...)</span>
request.get_csrf_secret()</pre>
    </div>
    <div class="autodoc_comment">Returns the secret string being previously set with request.set_csrf_secret(...) for inclusion in web forms (nil if none is set). This function is automatically used by the ui.form{...} helper.    </div>
    <div class="autodoc_source">
<pre>function request.get_csrf_secret(secret)
  return request._csrf_secret
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_166').style.display = document.getElementById('autodoc_details_166').style.display ? '' : 'none';">
    request.get_id_string()
  </div>
  <div id="autodoc_details_166" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>id_string =
request.get_id_string()</pre>
    </div>
    <div class="autodoc_comment">Returns the requested id for a view as a string (unprocessed). Use param.get_id(...) to get a processed version.    </div>
    <div class="autodoc_source">
<pre>function request.get_id_string()
  return request._id
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_167').style.display = document.getElementById('autodoc_details_167').style.display ? '' : 'none';">
    request.get_json_request_slots()
  </div>
  <div id="autodoc_details_167" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>slot_idents =                    <span class="autodoc_comment_tail">-- list of names of slots to be returned as JSON data</span>
request.get_json_request_slots()</pre>
    </div>
    <div class="autodoc_comment">If the current request is no JSON request, this function returns nil, otherwise a list of names of all slots to be returned in JSON format. This function also throws an error, if JSON data was requested, but request.set_allowed_json_request_slots(...) has not been called.    </div>
    <div class="autodoc_source">
<pre>function request.get_json_request_slots(slot_idents)
  if not cgi then return end
  local slot_idents = cgi.params[&quot;_webmcp_json_slots[]&quot;]
  if slot_idents and not request._json_requests_allowed then
    error(&quot;JSON requests have not been allowed using request.set_allowed_json_request_slots(...).&quot;)
  end
  return slot_idents
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_168').style.display = document.getElementById('autodoc_details_168').style.display ? '' : 'none';">
    request.get_module()
  </div>
  <div id="autodoc_details_168" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>module_name =
request.get_module()</pre>
    </div>
    <div class="autodoc_comment">Returns the name of the module of the currently requested view or action.    </div>
    <div class="autodoc_source">
<pre>function request.get_module()
  if request._forward_processed then
    return request._forward.module or request._module or 'index'
  else
    return request._module or 'index'
  end
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_169').style.display = document.getElementById('autodoc_details_169').style.display ? '' : 'none';">
    request.get_perm_params()
  </div>
  <div id="autodoc_details_169" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>perm_params =              <span class="autodoc_comment_tail">-- table containing permanent parameters</span>
request.get_perm_params()</pre>
    </div>
    <div class="autodoc_comment">This function returns a table containing all permanent paremeters set with request.set_perm_param(...). Modifications of the returned table have no side effects.    </div>
    <div class="autodoc_source">
<pre>function request.get_perm_params()
  <span class="autodoc_comment_tail">-- NOTICE: it's important to return a copy here</span>
  return table.new(request._perm_params)
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_170').style.display = document.getElementById('autodoc_details_170').style.display ? '' : 'none';">
    request.get_redirect_data()
  </div>
  <div id="autodoc_details_170" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>redirect_data =
request.get_redirect_data()</pre>
    </div>
    <div class="autodoc_comment">This function returns redirect information from a previous call of request.redirect{...}, or nil if no redirect was requested.    </div>
    <div class="autodoc_source">
<pre>function request.get_redirect_data()
  return request._redirect
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_171').style.display = document.getElementById('autodoc_details_171').style.display ? '' : 'none';">
    request.get_relative_baseurl()
  </div>
  <div id="autodoc_details_171" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>baseurl =
request.get_relative_baseurl()</pre>
    </div>
    <div class="autodoc_comment">This function returns a relative base URL of the application. If request.force_absolute_baseurl() has been called before, an absolute URL is returned.    </div>
    <div class="autodoc_source">
<pre>function request.get_relative_baseurl()
  if request._force_absolute_baseurl then
    return (request.get_absolute_baseurl())
  else
    return request._relative_baseurl
  end
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_172').style.display = document.getElementById('autodoc_details_172').style.display ? '' : 'none';">
    request.get_status()
  </div>
  <div id="autodoc_details_172" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>status_string =
request.get_status()</pre>
    </div>
    <div class="autodoc_comment">Returns a HTTP status previously set with request.set_status(...).    </div>
    <div class="autodoc_source">
<pre>function request.get_status()
  return request._status
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_173').style.display = document.getElementById('autodoc_details_173').style.display ? '' : 'none';">
    request.get_view()
  </div>
  <div id="autodoc_details_173" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>view_name =
request.get_view()</pre>
    </div>
    <div class="autodoc_comment">Returns the name of the currently requested view, or nil in case of an action.    </div>
    <div class="autodoc_source">
<pre>function request.get_view()
  if request._forward_processed then
    return request._forward.view or 'index'
  else
    if request._view then
      local suffix = request._suffix or &quot;html&quot;
      if suffix == &quot;html&quot; then
        return request._view
      else
        return request._view .. &quot;.&quot; .. suffix
      end
    elseif not request._action then
      return 'index'
    else
      return nil
    end
  end
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_174').style.display = document.getElementById('autodoc_details_174').style.display ? '' : 'none';">
    request.is_404()
  </div>
  <div id="autodoc_details_174" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>is_404 =          <span class="autodoc_comment_tail">-- boolean</span>
request.is_404()</pre>
    </div>
    <div class="autodoc_comment">Returns true, if this request results in a 404, else false.    </div>
    <div class="autodoc_source">
<pre>function request.is_404()
  return request._is_404
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_175').style.display = document.getElementById('autodoc_details_175').style.display ? '' : 'none';">
    request.is_post()
  </div>
  <div id="autodoc_details_175" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>bool =             <span class="autodoc_comment_tail">-- true, if the current request is a POST request</span>
request.is_post()</pre>
    </div>
    <div class="autodoc_comment">This function can be used to check, if the current request is a POST request.    </div>
    <div class="autodoc_source">
<pre>function request.is_post()
  if request._forward_processed then
    return false
  else
    return cgi.method == &quot;POST&quot;
  end
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_176').style.display = document.getElementById('autodoc_details_176').style.display ? '' : 'none';">
    request.process_forward()
  </div>
  <div id="autodoc_details_176" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>request.process_forward()</pre>
    </div>
    <div class="autodoc_comment">This function causes a previous call of request.forward{...} to be in effect. It is called automatically when neccessary, and must not be called explicitly by any application.    </div>
    <div class="autodoc_source">
<pre>function request.process_forward()
  if request._forward then
    request._forward_processed = true
    trace.request{
      module = request.get_module(),
      view   = request.get_view()
    }
  end
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_177').style.display = document.getElementById('autodoc_details_177').style.display ? '' : 'none';">
    request.redirect{ ... }
  </div>
  <div id="autodoc_details_177" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>request.redirect{
  module = module,  <span class="autodoc_comment_tail">-- module name</span>
  view   = view,    <span class="autodoc_comment_tail">-- view name</span>
  id     = id,      <span class="autodoc_comment_tail">-- optional id for view</span>
  params = params   <span class="autodoc_comment_tail">-- optional view parameters</span>
}</pre>
    </div>
    <div class="autodoc_comment">Calling this function causes the WebMCP to do a 303 HTTP redirect after the current view or action and all filters have finished execution. If routing mode &quot;redirect&quot; has been chosen, then this function is called automatically after an action and all its filters have finished execution. Calling request.redirect{...} (or request.forward{...}) explicitly inside an action will cause routing information from the browser to be ignored. To preserve GET/POST parameters of an action, use request.forward{...} instead. Currently no redirects to external (absolute) URLs are possible, there will be an implementation in future though.    </div>
    <div class="autodoc_source">
<pre>function request.redirect(args)
  <span class="autodoc_comment_tail">-- TODO: support redirects to external URLs too</span>
  <span class="autodoc_comment_tail">--       (needs fixes in the trace system as well)</span>
  local module = args.module
  local view   = args.view
  local id     = args.id
  local params = args.params or {}
  if type(module) ~= &quot;string&quot; then
    error(&quot;No module string passed to request.redirect{...}.&quot;)
  end
  if type(view) ~= &quot;string&quot; then
    error(&quot;No view string passed to request.redirect{...}.&quot;)
  end
  if type(params) ~= &quot;table&quot; then
    error(&quot;Params array passed to request.redirect{...} is not a table.&quot;)
  end
  if request.is_rerouted() then
    error(&quot;Tried to redirect after another forward or redirect.&quot;)
  end
  request._redirect = {
    module = module,
    view   = view,
    id     = id,
    params = params
  }
  trace.redirect{ module = args.module, view = args.view }
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_178').style.display = document.getElementById('autodoc_details_178').style.display ? '' : 'none';">
    request.set_404_route{ module = module, view = view }
  </div>
  <div id="autodoc_details_178" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>request.set_404_route{
  module = module,  <span class="autodoc_comment_tail">-- module name</span>
  view   = view     <span class="autodoc_comment_tail">-- view name</span>
}</pre>
    </div>
    <div class="autodoc_comment">In case a view or action is not found, the given module and view will be used to display an error page.    </div>
    <div class="autodoc_source">
<pre>function request.set_404_route(tbl)
  request._404_route = tbl
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_179').style.display = document.getElementById('autodoc_details_179').style.display ? '' : 'none';">
    request.set_absolute_baseurl( url )
  </div>
  <div id="autodoc_details_179" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>request.set_absolute_baseurl(
  url                          <span class="autodoc_comment_tail">-- Base URL of the application</span>
)</pre>
    </div>
    <div class="autodoc_comment">Calling this function is neccessary for every configuration, because an absolute URL is needed for HTTP redirects. If the URL of the application is volatile, and if you don't bother violating the HTTP standard, you might want to execute request.set_absolute_baseurl(request.get_relative_baseurl()) in your application configuration.    </div>
    <div class="autodoc_source">
<pre>function request.set_absolute_baseurl(url)
  if string.find(url, &quot;/$&quot;) then
    request._absolute_baseurl = url
  else
    request._absolute_baseurl = url .. &quot;/&quot;
  end
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_180').style.display = document.getElementById('autodoc_details_180').style.display ? '' : 'none';">
    request.set_allowed_json_request_slots( slot_idents )
  </div>
  <div id="autodoc_details_180" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>request.set_allowed_json_request_slots(
  slot_idents                            <span class="autodoc_comment_tail">-- list of names of slots which can be requested in JSON format</span>
)</pre>
    </div>
    <div class="autodoc_comment">This function enables JSON requests. The given list of names of slots selects, which slots may be requestd in JSON format (without layout).    </div>
    <div class="autodoc_source">
<pre>function request.set_allowed_json_request_slots(slot_idents)
  if cgi then  <span class="autodoc_comment_tail">-- do nothing, when being in interactive mode</span>
    local hash = {}
    for idx, slot_ident in ipairs(slot_idents) do
      hash[slot_ident] = true
    end
    if cgi.params[&quot;_webmcp_json_slots[]&quot;] then
      for idx, slot_ident in ipairs(cgi.params[&quot;_webmcp_json_slots[]&quot;]) do
        if not hash[slot_ident] then
          error('Requesting slot &quot;' .. slot_ident .. '&quot; is forbidden.')
        end
      end
    end
    request._json_requests_allowed = true
  end
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_181').style.display = document.getElementById('autodoc_details_181').style.display ? '' : 'none';">
    request.set_cookie{ ... }
  </div>
  <div id="autodoc_details_181" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>request.set_cookie{
  name   = name,     <span class="autodoc_comment_tail">-- name of cookie</span>
  value  = value,    <span class="autodoc_comment_tail">-- value of cookie</span>
  domain = domain,   <span class="autodoc_comment_tail">-- optional domain domain where cookie is transmitted</span>
  path   = path,     <span class="autodoc_comment_tail">-- optional path where cookie is transmitted, defaults to application base</span>
  secure = secure    <span class="autodoc_comment_tail">-- optional boolean, indicating if cookie should only be transmitted over HTTPS</span>
}</pre>
    </div>
    <div class="autodoc_comment">This function is similar to rocketwiki.set_cookie{...}, except that it automatically sets the path to the application base. It also sets secure=true, if the secure option is unset and the application base URL starts with &quot;https://&quot;.    </div>
    <div class="autodoc_source">
<pre>function request.set_cookie(args)
  local path = args.path
  if not path then
    path = string.match(
      request.get_absolute_baseurl(),
      &quot;://[^/]*(.*)&quot;
    )
    if path == nil or path == &quot;&quot; then
      path = &quot;/&quot;
    end
  end
  local secure = args.secure
  if secure == nil then
    if string.find(
      string.lower(request.get_absolute_baseurl()),
      &quot;^https://&quot;
    ) then
      secure = true
    else
      secure = false
    end
  end
  cgi.set_cookie{
    name   = args.name,
    value  = args.value,
    domain = args.domain,
    path   = path,
    secure = secure
  }
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_182').style.display = document.getElementById('autodoc_details_182').style.display ? '' : 'none';">
    request.set_csrf_secret( secret )
  </div>
  <div id="autodoc_details_182" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>request.set_csrf_secret(
  secret                 <span class="autodoc_comment_tail">-- secret random string</span>
)</pre>
    </div>
    <div class="autodoc_comment">Sets a secret string to be used as protection against cross-site request forgery attempts. This string will be transmitted to each action via a hidden form field named &quot;_webmcp_csrf_secret&quot;. If this function is called during an action, and there is no CGI GET/POST parameter &quot;_webmcp_csrf_secret&quot; already being set to the given secret, then an error will be thrown to prohibit execution of the action.    </div>
    <div class="autodoc_source">
<pre>function request.set_csrf_secret(secret)
  if
    request.get_action() and
    cgi.params._webmcp_csrf_secret ~= secret
  then
    error(&quot;Cross-Site Request Forgery attempt detected&quot;);
  end
  request._csrf_secret = secret
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_183').style.display = document.getElementById('autodoc_details_183').style.display ? '' : 'none';">
    request.set_perm_param( key, value )
  </div>
  <div id="autodoc_details_183" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>request.set_perm_param(
  key,                   <span class="autodoc_comment_tail">-- name of parameter</span>
  value                  <span class="autodoc_comment_tail">-- value of parameter</span>
)</pre>
    </div>
    <div class="autodoc_comment">Setting a so-called &quot;permanent parameter&quot; with this function will cause a key value pair to be included in every HTTP link inside the application. It is used as a cookie replacement, where cookies are not suitable, e.g. because you want multiple browser windows to not interfere with each other.    </div>
    <div class="autodoc_source">
<pre>function request.set_perm_param(key, value)
  request._perm_params[key] = value
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_184').style.display = document.getElementById('autodoc_details_184').style.display ? '' : 'none';">
    request.set_status( str )
  </div>
  <div id="autodoc_details_184" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>request.set_status(
  str                <span class="autodoc_comment_tail">-- string containing a HTTP status code, e.g. &quot;404 Not Found&quot;</span>
)</pre>
    </div>
    <div class="autodoc_comment">Calling this function causes a HTTP status different from 200 OK (or in case of error different from 500 Internal Server Error) to be sent to the browser.    </div>
    <div class="autodoc_source">
<pre>function request.set_status(str)
  if str then
    local t = type(str)
    if type(str) == &quot;number&quot; then
      str = tostring(str)
    elseif type(str) ~= &quot;string&quot; then
      error(&quot;request.set_status(...) must be called with a string as parameter.&quot;)
    end
    request._status = str
  else
    request._status = nil
  end
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_185').style.display = document.getElementById('autodoc_details_185').style.display ? '' : 'none';">
    request_is_rerouted()
  </div>
  <div id="autodoc_details_185" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>bool =                 <span class="autodoc_comment_tail">-- true, if request.forard{...} or request.redirect{...} has been called before.</span>
request_is_rerouted()</pre>
    </div>
    <div class="autodoc_comment">This function returns true, if request.forward{...} or request.redirect{...} has been called before. In a new request caused by a redirect the function returns false. After a forward has been processed, this function also returns false.    </div>
    <div class="autodoc_source">
<pre>function request.is_rerouted()
  if
    (request._forward and not request._forward_processed) or
    request._redirect
  then
    return true
  else
    return false
  end
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_186').style.display = document.getElementById('autodoc_details_186').style.display ? '' : 'none';">
    result1, result2, ... = &lt;db_handle&gt;:query{ ... }
  </div>
  <div id="autodoc_details_186" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>result1,            <span class="autodoc_comment_tail">-- result of first command</span>
result2,            <span class="autodoc_comment_tail">-- result of second command</span>
... =
&lt;db_handle&gt;:query(
  command1,         <span class="autodoc_comment_tail">-- first command (to be processed by &quot;assemble_command&quot; method)</span>
  mode1,            <span class="autodoc_comment_tail">-- mode for first command: &quot;list&quot;, &quot;object&quot; or &quot;opt_object&quot;</span>
  command2,         <span class="autodoc_comment_tail">-- second command (to be processed by &quot;assemble_command&quot; method)</span>
  mode2,            <span class="autodoc_comment_tail">-- mode for second command: &quot;list&quot;, &quot;object&quot; or &quot;opt_object&quot;</span>
  ..
)</pre>
    </div>
    <div class="autodoc_comment">Same as &quot;try_query&quot; but raises error, when occurring.    </div>
    <div class="autodoc_source">
<pre><span class="autodoc_comment_tail">-- implemented in mondelefant_native.c as</span>
<span class="autodoc_comment_tail">-- static int mondelefant_conn_query(lua_State *L)</span></pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_187').style.display = document.getElementById('autodoc_details_187').style.display ? '' : 'none';">
    rocketcgi.add_header( string_part1, string_part2, ... )
  </div>
  <div id="autodoc_details_187" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>rocketcgi.add_header(
  string_part1,        <span class="autodoc_comment_tail">-- string</span>
  string_part2,        <span class="autodoc_comment_tail">-- optional second part of string to be concatted</span>
  ...
)</pre>
    </div>
    <div class="autodoc_comment">Sends a header line to the browser. Multiple arguments are concatted to form a single string.    </div>
    <div class="autodoc_source">
<pre>function add_header(...)
  if data_sent then
    error(&quot;Can not add header after data has been sent.&quot;, 2)
  end
  io.stdout:write(...)
  io.stdout:write(&quot;\r\n&quot;)
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_188').style.display = document.getElementById('autodoc_details_188').style.display ? '' : 'none';">
    rocketcgi.redirect( status )
  </div>
  <div id="autodoc_details_188" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>rocketcgi.redirect(
  status             <span class="autodoc_comment_tail">-- Absolute URL to redirect the browser to</span>
)</pre>
    </div>
    <div class="autodoc_comment">Redirects the browser to the given absolute URL, using a 303 Redirect.    </div>
    <div class="autodoc_source">
<pre>function redirect(location)
  set_status(&quot;303 See Other&quot;)
  add_header(&quot;Location: &quot;, location)
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_189').style.display = document.getElementById('autodoc_details_189').style.display ? '' : 'none';">
    rocketcgi.send_data( string_part1, string_part2, ... )
  </div>
  <div id="autodoc_details_189" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>rocketcgi.send_data(
  string_part1,       <span class="autodoc_comment_tail">-- string</span>
  string_part2,       <span class="autodoc_comment_tail">-- optional second part of string to be concatted</span>
  ...
)</pre>
    </div>
    <div class="autodoc_comment">Sends document data to the browser. Multiple arguments are concatted to form a single string.    </div>
    <div class="autodoc_source">
<pre>function send_data(...)
  if not data_sent then
    io.stdout:write(&quot;\r\n&quot;)
    data_sent = true
  end
  io.stdout:write(...)
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_190').style.display = document.getElementById('autodoc_details_190').style.display ? '' : 'none';">
    rocketcgi.set_content_type( content_type )
  </div>
  <div id="autodoc_details_190" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>rocketcgi.set_content_type(
  content_type               <span class="autodoc_comment_tail">-- MIME content type</span>
)</pre>
    </div>
    <div class="autodoc_comment">Sends a header line specifying the content-type to the browser.    </div>
    <div class="autodoc_source">
<pre>function set_content_type(content_type)
  add_header(&quot;Content-Type: &quot;, content_type)
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_191').style.display = document.getElementById('autodoc_details_191').style.display ? '' : 'none';">
    rocketcgi.set_cookie{ ... }
  </div>
  <div id="autodoc_details_191" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>rocketcgi.set_cookie{
  name   = name,       <span class="autodoc_comment_tail">-- name of cookie</span>
  value  = value,      <span class="autodoc_comment_tail">-- value of cookie</span>
  domain = domain,     <span class="autodoc_comment_tail">-- domain where cookie is transmitted</span>
  path   = path,       <span class="autodoc_comment_tail">-- path where cookie is transmitted</span>
  secure = secure      <span class="autodoc_comment_tail">-- boolean, indicating if cookie should only be transmitted over HTTPS</span>
}</pre>
    </div>
    <div class="autodoc_comment">Sends a header line setting a cookie. NOTE: Currently only session cookies are supported.    </div>
    <div class="autodoc_source">
<pre>function set_cookie(args)
  assert(string.find(args.name, &quot;^[0-9A-Za-z%%._~-]+$&quot;), &quot;Illegal cookie name&quot;)
  assert(string.find(args.value, &quot;^[0-9A-Za-z%%._~-]+$&quot;), &quot;Illegal cookie value&quot;)
  local parts = {&quot;Set-Cookie: &quot; .. args.name .. &quot;=&quot; .. args.value}
  if args.domain then
    assert(
      string.find(args.path, &quot;^[0-9A-Za-z%%/._~-]+$&quot;),
      &quot;Illegal cookie domain&quot;
    )
    parts[#parts+1] = &quot;domain=&quot; .. args.domain
  end
  if args.path then
    assert(
      string.find(args.path, &quot;^[0-9A-Za-z%%/._~-]+$&quot;),
      &quot;Illegal cookie path&quot;
    )
    parts[#parts+1] = &quot;path=&quot; .. args.path
  end
  if args.secure then
    parts[#parts+1] = &quot;secure&quot;
  end
  add_header(table.concat(parts, &quot;; &quot;))
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_192').style.display = document.getElementById('autodoc_details_192').style.display ? '' : 'none';">
    rocketcgi.set_status( status )
  </div>
  <div id="autodoc_details_192" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>rocketcgi.set_status(
  status               <span class="autodoc_comment_tail">-- Status code and description, e.g. &quot;404 Not Found&quot;</span>
)</pre>
    </div>
    <div class="autodoc_comment">Sends a header line to the browser, indicating a given HTTP status.    </div>
    <div class="autodoc_source">
<pre>function set_status(status)
  add_header(&quot;Status: &quot;, status)
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_193').style.display = document.getElementById('autodoc_details_193').style.display ? '' : 'none';">
    slot.dump_all()
  </div>
  <div id="autodoc_details_193" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>blob =           <span class="autodoc_comment_tail">-- string for later usage with slot.restore_all(...)</span>
slot.dump_all()</pre>
    </div>
    <div class="autodoc_comment">Returns a single string, containing all slot contents. The result of this function can be used to restore all slots after a 303 redirect. This is done automatically by the WebMCP using slot.restore_all(...). If the result of this function is an empty string, then all slots are empty.    </div>
    <div class="autodoc_source">
<pre>local function encode(str)
  return (
    string.gsub(
      str,
      &quot;[=;%[%]]&quot;,
      function(char)
        if char == &quot;=&quot; then return &quot;[eq]&quot;
        elseif char == &quot;;&quot; then return &quot;[s]&quot;
        elseif char == &quot;[&quot; then return &quot;[o]&quot;
        elseif char == &quot;]&quot; then return &quot;[c]&quot;
        else end
      end
    )
  )
end

function slot.dump_all()
  local blob_parts = {}
  for key in pairs(slot._data) do
    if type(key) == &quot;string&quot; then
      local value = slot.get_content(key)
      if value ~= &quot;&quot; then
        blob_parts[#blob_parts + 1] = encode(key) .. &quot;=&quot; .. encode(value)
      end
    end
  end
  return table.concat(blob_parts, &quot;;&quot;)
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_194').style.display = document.getElementById('autodoc_details_194').style.display ? '' : 'none';">
    slot.get_content( slot_ident )
  </div>
  <div id="autodoc_details_194" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>content =
slot.get_content(
  slot_ident       <span class="autodoc_comment_tail">-- name of the slot</span>
)</pre>
    </div>
    <div class="autodoc_comment">This function returns the content of a chosen slot as a single string.    </div>
    <div class="autodoc_source">
<pre>function slot.get_content(slot_ident)
  local slot_data = slot._data[slot_ident]
  if #slot_data.string_fragments &gt; 1 then
    local str = table.concat(slot_data.string_fragments)
    slot_data.string_fragments = { str }
    return str
  else
    return slot_data.string_fragments[1] or &quot;&quot;
  end
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_195').style.display = document.getElementById('autodoc_details_195').style.display ? '' : 'none';">
    slot.get_content_type()
  </div>
  <div id="autodoc_details_195" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>content_type =           <span class="autodoc_comment_tail">-- content-type as selected with slot.set_layout(...)</span>
slot.get_content_type()</pre>
    </div>
    <div class="autodoc_comment">This function returns the content-type to be sent to the browser. It may be changed by calling slot.set_layout(...). The default content-type is &quot;text/html; charset=UTF-8&quot;.    </div>
    <div class="autodoc_source">
<pre>function slot.get_content_type()
  return slot._content_type or 'text/html; charset=UTF-8'
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_196').style.display = document.getElementById('autodoc_details_196').style.display ? '' : 'none';">
    slot.get_state_table()
  </div>
  <div id="autodoc_details_196" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>state_table =           <span class="autodoc_comment_tail">-- table for saving a slot's state</span>
slot.get_state_table()</pre>
    </div>
    <div class="autodoc_comment">This function returns a table, holding state information of the currently active slot. To change the state information the returned table may be modified.    </div>
    <div class="autodoc_source">
<pre>function slot.get_state_table()
  return slot.get_state_table_of(slot._active_slot)
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_197').style.display = document.getElementById('autodoc_details_197').style.display ? '' : 'none';">
    slot.get_state_table_of( slot_ident )
  </div>
  <div id="autodoc_details_197" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>state_table =             <span class="autodoc_comment_tail">-- table for saving the slot's state</span>
slot.get_state_table_of(
  slot_ident              <span class="autodoc_comment_tail">-- name of a slot</span>
)</pre>
    </div>
    <div class="autodoc_comment">This function returns a table, holding state information of the named slot. To change the state information the returned table may be modified.    </div>
    <div class="autodoc_source">
<pre>function slot.get_state_table_of(slot_ident)
  return slot._data[slot_ident].state_table
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_198').style.display = document.getElementById('autodoc_details_198').style.display ? '' : 'none';">
    slot.put( string1, string2, ... )
  </div>
  <div id="autodoc_details_198" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>slot.put(
  string1,  <span class="autodoc_comment_tail">-- string to be written into the active slot</span>
  string2,  <span class="autodoc_comment_tail">-- another string to be written into the active slot</span>
  ...
)</pre>
    </div>
    <div class="autodoc_comment">This function is used to write strings into the active slot.<br/><br/>-- NOTE: ACCELERATED FUNCTION<br/>-- Do not change unless also you also update webmcp_accelerator.c    </div>
    <div class="autodoc_source">
<pre>function slot.put(...)
  return slot.put_into(slot._active_slot, ...)
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_199').style.display = document.getElementById('autodoc_details_199').style.display ? '' : 'none';">
    slot.put_into( slot_ident string1, string2, ... )
  </div>
  <div id="autodoc_details_199" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>slot.put_into(
  slot_ident  <span class="autodoc_comment_tail">-- name of a slot</span>
  string1,    <span class="autodoc_comment_tail">-- string to be written into the named slot</span>
  string2,    <span class="autodoc_comment_tail">-- another string to be written into the named slot</span>
  ...
)</pre>
    </div>
    <div class="autodoc_comment">This function is used to write strings into a named slot.<br/><br/>-- NOTE: ACCELERATED FUNCTION<br/>-- Do not change unless also you also update webmcp_accelerator.c    </div>
    <div class="autodoc_source">
<pre>function slot.put_into(slot_ident, ...)
  local t = slot._data[slot_ident].string_fragments
  for i = 1, math.huge do
    local v = select(i, ...)
    if v == nil then break end
    t[#t + 1] = v
  end
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_200').style.display = document.getElementById('autodoc_details_200').style.display ? '' : 'none';">
    slot.render_layout()
  </div>
  <div id="autodoc_details_200" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>output =              <span class="autodoc_comment_tail">-- document/data to be sent to the web browser</span>
slot.render_layout()</pre>
    </div>
    <div class="autodoc_comment">This function returns the selected layout after replacing all slot placeholders with the respective slot contents. If slot.set_layout(...) was called with nil as first argument, then no layout will be used, but only the contents of the slot named &quot;data&quot; are returned.    </div>
    <div class="autodoc_source">
<pre>function slot.render_layout()
  if slot._current_layout then
    local layout_file = assert(io.open(
      encode.file_path(
        request.get_app_basepath(),
        'app',
        request.get_app_name(),
        '_layout',
        slot._current_layout .. '.html'
      ),
      'r'
    ))
    local layout = layout_file:read(&quot;*a&quot;)
    io.close(layout_file)

    <span class="autodoc_comment_tail">-- render layout</span>
    layout = string.gsub(layout, &quot;__BASEURL__/?&quot;, request.get_relative_baseurl())  <span class="autodoc_comment_tail">-- TODO: find a better placeholder than __BASEURL__ ?</span>
    layout = string.gsub(layout, '&lt;!%-%- *WEBMCP +SLOT +([^ ]+) *%-%-&gt;',
      function(slot_ident)
        if #slot.get_content(slot_ident) &gt; 0 then
          local add_class =''
          if slot_ident == 'default' then add_class = ' container-fluid' end
          if slot_ident == 'navbar' then add_class = ' container' end
          if slot_ident == 'notice' then add_class = ' span12 alert alert-info' end
          if slot_ident == 'warning' then add_class = ' span12 alert alert-warning' end
          if slot_ident == 'error' then add_class = ' span12 alert alert-error' end

          return '&lt;div class=&quot;slot_' .. slot_ident .. add_class .. '&quot; id=&quot;slot_' .. slot_ident .. '&quot;&gt;' .. slot.get_content(slot_ident).. '&lt;/div&gt;'
        else
          return ''
        end
      end
    )
    layout = string.gsub(layout, '&lt;!%-%- *WEBMCP +SLOTNODIV +([^ ]+) *%-%-&gt;',
      function(slot_ident)
        if #slot.get_content(slot_ident) &gt; 0 then
          return slot.get_content(slot_ident)
        else
          return ''
        end
      end
    )
    return layout
  else
    return slot.get_content(&quot;data&quot;)
  end
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_201').style.display = document.getElementById('autodoc_details_201').style.display ? '' : 'none';">
    slot.reset( slot_ident )
  </div>
  <div id="autodoc_details_201" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>slot.reset(
  slot_ident  <span class="autodoc_comment_tail">-- name of a slot to be emptied</span>
)</pre>
    </div>
    <div class="autodoc_comment">Calling this function reset the named slot to be empty.    </div>
    <div class="autodoc_source">
<pre>function slot.reset(slot_ident)
  slot._data[slot_ident] = nil
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_202').style.display = document.getElementById('autodoc_details_202').style.display ? '' : 'none';">
    slot.reset_all{ except = except }
  </div>
  <div id="autodoc_details_202" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>slot.reset_all{
  except =  except  <span class="autodoc_comment_tail">-- Reset all slots, except slots named in this list</span>
}</pre>
    </div>
    <div class="autodoc_comment">Calling this function resets all slots to be empty. An exclusion list may be passed to the function as named argument.    </div>
    <div class="autodoc_source">
<pre>function slot.reset_all(args)
  local saved = {}
  if args and args.except then
    for i, key in ipairs(args.except) do
      saved[key] = slot._data[key]
    end
  end
  slot._data = setmetatable({}, slot._data_metatable)
  if saved then
    for key, value in pairs(saved) do
      slot._data[key] = value
    end
  end
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_203').style.display = document.getElementById('autodoc_details_203').style.display ? '' : 'none';">
    slot.restore_all( blob )
  </div>
  <div id="autodoc_details_203" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>slot.restore_all(
  blob             <span class="autodoc_comment_tail">-- string as returned by slot.dump_all()</span>
)</pre>
    </div>
    <div class="autodoc_comment">Restores all slots using a string created by slot.dump_all().    </div>
    <div class="autodoc_source">
<pre>local function decode(str)
  return (
    string.gsub(
      str,
      &quot;%[[a-z]+%]&quot;,
      function(char)
        if char == &quot;[eq]&quot; then return &quot;=&quot;
        elseif char == &quot;[s]&quot; then return &quot;;&quot;
        elseif char == &quot;[o]&quot; then return &quot;[&quot;
        elseif char == &quot;[c]&quot; then return &quot;]&quot;
        else end
      end
    )
  )
end

function slot.restore_all(blob)
  slot.reset_all()
  for encoded_key, encoded_value in string.gmatch(blob, &quot;([^=;]*)=([^=;]*)&quot;) do
    local key, value = decode(encoded_key), decode(encoded_value)
    slot._data[key].string_fragments = { value }
  end
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_204').style.display = document.getElementById('autodoc_details_204').style.display ? '' : 'none';">
    slot.select( slot_ident, function() ... end )
  </div>
  <div id="autodoc_details_204" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>slot.select(
  slot_ident,  <span class="autodoc_comment_tail">-- name of a slot</span>
  function()
    ...        <span class="autodoc_comment_tail">-- code to be executed using the named slot</span>
  end
)</pre>
    </div>
    <div class="autodoc_comment">This function executes code in a way that slot.put(...) and other functions write into the slot with the given name. Calls of slot.select may be nested.    </div>
    <div class="autodoc_source">
<pre>function slot.select(slot_ident, block)
  local old_slot = slot._active_slot
  slot._active_slot = slot_ident
  block()
  slot._active_slot = old_slot
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_205').style.display = document.getElementById('autodoc_details_205').style.display ? '' : 'none';">
    slot.set_layout( layout_ident, content_type )
  </div>
  <div id="autodoc_details_205" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>slot.set_layout(
  layout_ident,   <span class="autodoc_comment_tail">-- name of layout or nil for binary data in slot named &quot;data&quot;</span>
  content_type    <span class="autodoc_comment_tail">-- content-type to be sent to the browser, or nil for default</span>
)</pre>
    </div>
    <div class="autodoc_comment">This function selects which layout should be used when calling slot.render_layout(). If no layout is selected by passing nil as first argument, then no layout will be used, and the slot named &quot;data&quot; is used plainly. The second argument to slot.set_layout is the content-type which is sent to the browser.    </div>
    <div class="autodoc_source">
<pre>function slot.set_layout(layout_ident, content_type)
  slot._current_layout = layout_ident
  slot._content_type = content_type
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_206').style.display = document.getElementById('autodoc_details_206').style.display ? '' : 'none';">
    slot.use_temporary( function() ... end )
  </div>
  <div id="autodoc_details_206" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>slot_content =
slot.use_temporary(
  function()
    ...
  end
)</pre>
    </div>
    <div class="autodoc_comment">This function creates a temporary slot and executes code in a way that slot.put(...) and other functions will write into the temporary slot. Afterwards the contents of the temporary slot are returned as a single string.    </div>
    <div class="autodoc_source">
<pre>function slot.use_temporary(block)
  local old_slot = slot._active_slot
  local temp_slot_reference = {}  <span class="autodoc_comment_tail">-- just a unique reference</span>
  slot._active_slot = temp_slot_reference
  block()
  slot._active_slot = old_slot
  local result = slot.get_content(temp_slot_reference)
  slot.reset(temp_slot_reference)
  return result
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_207').style.display = document.getElementById('autodoc_details_207').style.display ? '' : 'none';">
    table.new( table_or_nil )
  </div>
  <div id="autodoc_details_207" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>cloned_table =  <span class="autodoc_comment_tail">-- newly generated table</span>
table.new(
  table_or_nil  <span class="autodoc_comment_tail">-- keys of a given table will be copied to the new table</span>
)</pre>
    </div>
    <div class="autodoc_comment">If a table is given, then a cloned table is returned.<br/>If nil is given, then a new empty table is returned.    </div>
    <div class="autodoc_source">
<pre>function table.new(tbl)
  new_tbl = {}
  if tbl then
    for key, value in pairs(tbl) do
      new_tbl[key] = value
    end
  end
  return new_tbl
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_208').style.display = document.getElementById('autodoc_details_208').style.display ? '' : 'none';">
    tempstore.pop( key )
  </div>
  <div id="autodoc_details_208" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>blob =          <span class="autodoc_comment_tail">-- loaded string</span>
tempstore.pop(
  key           <span class="autodoc_comment_tail">-- key as returned by tempstore.save(...)</span>
)</pre>
    </div>
    <div class="autodoc_comment">This function restores data, which had been stored temporarily by tempstore.save(...). After loading the data, it is deleted from the tempstore automatically.    </div>
    <div class="autodoc_source">
<pre>function tempstore.pop(key)
  local filename = encode.file_path(
    request.get_app_basepath(), 'tmp', &quot;tempstore-&quot; .. key .. &quot;.tmp&quot;
  )
  local file = io.open(filename, &quot;r&quot;)
  if not file then return nil end
  local blob = file:read(&quot;*a&quot;)
  io.close(file)
  os.remove(filename)
  return blob
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_209').style.display = document.getElementById('autodoc_details_209').style.display ? '' : 'none';">
    tempstore.save( blob )
  </div>
  <div id="autodoc_details_209" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>key =            <span class="autodoc_comment_tail">-- key to be used with tempstore.pop(...) to regain the stored string</span>
tempstore.save(
  blob           <span class="autodoc_comment_tail">-- string to be stored</span>
)</pre>
    </div>
    <div class="autodoc_comment">This function stores data temporarily. It is used to restore slot information after a 303 HTTP redirect. It returns a key, which can be passed to tempstore.pop(...) to regain the stored data.    </div>
    <div class="autodoc_source">
<pre>function tempstore.save(blob)
  local key = multirand.string(26, &quot;123456789bcdfghjklmnpqrstvwxyz&quot;);
  local filename = encode.file_path(
    request.get_app_basepath(), 'tmp', &quot;tempstore-&quot; .. key .. &quot;.tmp&quot;
  )
  local file = assert(io.open(filename, &quot;w&quot;))
  file:write(blob)
  io.close(file)
  return key
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_210').style.display = document.getElementById('autodoc_details_210').style.display ? '' : 'none';">
    timestamp.invalid
  </div>
  <div id="autodoc_details_210" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>timestamp.invalid</pre>
    </div>
    <div class="autodoc_comment">Value representing an invalid timestamp.    </div>
    <div class="autodoc_source">
<pre>timestamp.invalid = timestamp:_create{
  tsec = not_a_number,
  year = not_a_number, month = not_a_number, day = not_a_number,
  hour = not_a_number, minute = not_a_number, second = not_a_number,
  invalid = true
}</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_211').style.display = document.getElementById('autodoc_details_211').style.display ? '' : 'none';">
    trace.debug(...) ...
  </div>
  <div id="autodoc_details_211" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>trace.debug(...)
  ...     <span class="autodoc_comment_tail">-- messages to be inserted into the trace log</span></pre>
    </div>
    <div class="autodoc_comment">This function can be used to include debug output in the trace log.    </div>
    <div class="autodoc_source">
<pre>function trace.debug(...)
  if not trace._disabled then
    local message = &quot;&quot;
    local arg = {...}
    for i= 1,#arg,1 do
      message = message..tostring(arg[i])..&quot; &quot;
    end
    trace._new_entry{ type = &quot;debug&quot;, message = message }
  end
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_212').style.display = document.getElementById('autodoc_details_212').style.display ? '' : 'none';">
    trace.debug_table( message )
  </div>
  <div id="autodoc_details_212" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>trace.debug_table(
  message     <span class="autodoc_comment_tail">-- message to be inserted into the trace log</span>
)</pre>
    </div>
    <div class="autodoc_comment">This function can be used to include debug output in the trace log.    </div>
    <div class="autodoc_source">
<pre>function trace.debug_table(table)
  trace._new_entry{ type = &quot;debug_table&quot;, message = table }
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_213').style.display = document.getElementById('autodoc_details_213').style.display ? '' : 'none';">
    trace.debug_trace( message )
  </div>
  <div id="autodoc_details_213" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>trace.debug_trace(
  message     <span class="autodoc_comment_tail">-- optional message to add</span>
)</pre>
    </div>
    <div class="autodoc_comment">This function includes a traceback into the debugging log    </div>
    <div class="autodoc_source">
<pre>function trace.debug_trace(message)
  trace._new_entry{ type = &quot;traceback&quot;, message = tostring(debug.traceback(message or &quot;&quot;, 2)) }
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_214').style.display = document.getElementById('autodoc_details_214').style.display ? '' : 'none';">
    trace.disable()
  </div>
  <div id="autodoc_details_214" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>trace.disable()</pre>
    </div>
    <div class="autodoc_comment">This function disables the trace system. Re-enabling the trace system is not possible.    </div>
    <div class="autodoc_source">
<pre>function trace.disable()
  trace._disabled = true
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_215').style.display = document.getElementById('autodoc_details_215').style.display ? '' : 'none';">
    trace.enter_action{ module = module, action = action }
  </div>
  <div id="autodoc_details_215" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>trace.enter_action{
  module = module,
  action = action
}</pre>
    </div>
    <div class="autodoc_comment">This function is used by execute.action and logs the call of an action.    </div>
    <div class="autodoc_source">
<pre>function trace.enter_action(args)
  if not trace._disabled then
    local module = args.module
    local action = args.action
    if type(module) ~= &quot;string&quot; then
      error(&quot;No module string passed to trace.enter_action{...}.&quot;)
    end
    if type(action) ~= &quot;string&quot; then
      error(&quot;No action string passed to trace.enter_action{...}.&quot;)
    end
    trace._open_section{ type = &quot;action&quot;, module = module, action = action }
  end
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_216').style.display = document.getElementById('autodoc_details_216').style.display ? '' : 'none';">
    trace.enter_config{ name = name }
  </div>
  <div id="autodoc_details_216" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>trace.enter_config{
  name = name
}</pre>
    </div>
    <div class="autodoc_comment">This function is used by execute.config and logs the inclusion of a configuration.    </div>
    <div class="autodoc_source">
<pre>function trace.enter_config(args)
  if not trace._disabled then
    local name = args.name
    if type(name) ~= &quot;string&quot; then
      error(&quot;No name string passed to trace.enter_config{...}.&quot;)
    end
    trace._open_section{ type = &quot;config&quot;, name = name }
  end
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_217').style.display = document.getElementById('autodoc_details_217').style.display ? '' : 'none';">
    trace.enter_filter{ path = path }
  </div>
  <div id="autodoc_details_217" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>trace.enter_filter{
  path = path
}</pre>
    </div>
    <div class="autodoc_comment">This function logs the call of a filter, when using execute.filtered_view{...} and execute.filtered_action{...}.    </div>
    <div class="autodoc_source">
<pre>function trace.enter_filter(args)
  if not trace._disabled then
    local path = args.path
    if type(path) ~= &quot;string&quot; then
      error(&quot;No path string passed to trace.enter_filter{...}.&quot;)
    end
    trace._open_section{ type = &quot;filter&quot;, path = path }
  end
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_218').style.display = document.getElementById('autodoc_details_218').style.display ? '' : 'none';">
    trace.enter_view{ module = module, view = view }
  </div>
  <div id="autodoc_details_218" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>trace.enter_view{
  module = module,
  view   = view
}</pre>
    </div>
    <div class="autodoc_comment">This function is used by execute.view and logs the call of a view.    </div>
    <div class="autodoc_source">
<pre>function trace.enter_view(args)
  if not trace._disabled then
    local module = args.module
    local view   = args.view
    if type(module) ~= &quot;string&quot; then
      error(&quot;No module passed to trace.enter_view{...}.&quot;)
    end
    if type(view) ~= &quot;string&quot; then
      error(&quot;No view passed to trace.enter_view{...}.&quot;)
    end
    trace._open_section{ type = &quot;view&quot;, module = module, view = view }
  end
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_219').style.display = document.getElementById('autodoc_details_219').style.display ? '' : 'none';">
    trace.error{ }
  </div>
  <div id="autodoc_details_219" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>trace.error{
}</pre>
    </div>
    <div class="autodoc_comment">This function is called automatically in case of errors to log them.    </div>
    <div class="autodoc_source">
<pre>function trace.error(args)
  if not trace._disabled then
    trace._new_entry { type = &quot;error&quot; }
    local closed_section = trace._close_section()
    closed_section.hard_error = true  <span class="autodoc_comment_tail">-- TODO: not used, maybe remove</span>
    trace._stack = { trace._tree }
  end
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_220').style.display = document.getElementById('autodoc_details_220').style.display ? '' : 'none';">
    trace.exectime{ real = real, cpu = cpu }
  </div>
  <div id="autodoc_details_220" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>trace.exectime{
  real = real,   <span class="autodoc_comment_tail">-- physical time in seconds</span>
  cpu  = cpu     <span class="autodoc_comment_tail">-- CPU time in seconds</span>
}</pre>
    </div>
    <div class="autodoc_comment">This function is called automatically to log the execution time of the handling of a request.    </div>
    <div class="autodoc_source">
<pre>function trace.exectime(args)
  if not trace._disabled then
    local real = args.real
    local cpu  = args.cpu
    if type(real) ~= &quot;number&quot; then
      error(&quot;Called trace.exectime{...} without numeric 'real' argument.&quot;)
    end
    if type(cpu) ~= &quot;number&quot; then
      error(&quot;Called trace.exectime{...} without numeric 'cpu' argument.&quot;)
    end
    trace._new_entry{ type = &quot;exectime&quot;, real = args.real, cpu = args.cpu }
  end
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_221').style.display = document.getElementById('autodoc_details_221').style.display ? '' : 'none';">
    trace.execution_return{ status = status }
  </div>
  <div id="autodoc_details_221" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>trace.execution_return{
  status = status        <span class="autodoc_comment_tail">-- optional status</span>
}</pre>
    </div>
    <div class="autodoc_comment">This function is called automatically when returning from a view, action, configuration or filter for logging purposes.    </div>
    <div class="autodoc_source">
<pre>function trace.execution_return(args)
  if not trace._disabled then
    local status
    if args then
      status = args.status
    end
    if status and type(status) ~= &quot;string&quot; then
      error(&quot;Status passed to trace.execution_return{...} is not a string.&quot;)
    end
    local closed_section = trace._close_section()
    closed_section.status = status
  end
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_222').style.display = document.getElementById('autodoc_details_222').style.display ? '' : 'none';">
    trace.forward{ module = module, view = view }
  </div>
  <div id="autodoc_details_222" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>trace.forward{
  module = module,
  view   = view
}</pre>
    </div>
    <div class="autodoc_comment">This function is called automatically by request.forward{...} for logging.    </div>
    <div class="autodoc_source">
<pre>function trace.forward(args)
  if not trace._disabled then
    local module = args.module
    local view   = args.view
    if type(module) ~= &quot;string&quot; then
      error(&quot;No module string passed to trace.forward{...}.&quot;)
    end
    if type(view) ~= &quot;string&quot; then
      error(&quot;No view string passed to trace.forward{...}.&quot;)
    end
    trace._new_entry{ type = &quot;forward&quot;, module = module, view = view }
  end
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_223').style.display = document.getElementById('autodoc_details_223').style.display ? '' : 'none';">
    trace.is_disabled()
  </div>
  <div id="autodoc_details_223" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>disabled =           <span class="autodoc_comment_tail">-- boolean indicating if trace system is disabled</span>
trace.is_disabled()</pre>
    </div>
    <div class="autodoc_comment">This function returns true, if the trace system has been disabled. Otherwise false is returned.    </div>
    <div class="autodoc_source">
<pre>function trace.is_disabled()
  return trace._disabled
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_224').style.display = document.getElementById('autodoc_details_224').style.display ? '' : 'none';">
    trace.redirect{ module = module, view = view }
  </div>
  <div id="autodoc_details_224" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>trace.redirect{
  module = module,
  view   = view
}</pre>
    </div>
    <div class="autodoc_comment">This function is called automatically by request.redirect{...} for logging.    </div>
    <div class="autodoc_source">
<pre>function trace.redirect(args)
  if not trace._disabled then
    local module = args.module
    local view   = args.view
    if type(module) ~= &quot;string&quot; then
      error(&quot;No module string passed to trace.redirect{...}.&quot;)
    end
    if type(view) ~= &quot;string&quot; then
      error(&quot;No view string passed to trace.redirect{...}.&quot;)
    end
    trace._new_entry{ type = &quot;redirect&quot;, module = module, view = view }
  end
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_225').style.display = document.getElementById('autodoc_details_225').style.display ? '' : 'none';">
    trace.render()
  </div>
  <div id="autodoc_details_225" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>trace.render()</pre>
    </div>
    <div class="autodoc_comment">This function renders a trace log and writes it into the active slot.    </div>
    <div class="autodoc_source">
<pre>function trace.render()
  if not trace._disabled then
    <span class="autodoc_comment_tail">-- TODO: check if all sections are closed?</span>
    trace._render_sub_tree(trace._tree)
  end
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_226').style.display = document.getElementById('autodoc_details_226').style.display ? '' : 'none';">
    trace.request{ module = module, view = view, action = action }
  </div>
  <div id="autodoc_details_226" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>trace.request{
  module = module,
  view   = view,
  action = action
}</pre>
    </div>
    <div class="autodoc_comment">This function is called automatically to log which view or action has been requested by the web browser.    </div>
    <div class="autodoc_source">
<pre>function trace.request(args)
  if not trace._disabled then
    local module       = args.module
    local view         = args.view
    local action       = args.action
    if type(module) ~= &quot;string&quot; then
      error(&quot;No module string passed to trace.request{...}.&quot;)
    end
    if view and action then
      error(&quot;Both view and action passed to trace.request{...}.&quot;)
    end
    if not (view or action) then
      error(&quot;Neither view nor action passed to trace.request{...}.&quot;)
    end
    if view and type(view) ~= &quot;string&quot; then
      error(&quot;No view string passed to trace.request{...}.&quot;)
    end
    if action and type(action) ~= &quot;string&quot; then
      error(&quot;No action string passed to trace.request{...}.&quot;)
    end
    trace._new_entry{
      type = &quot;request&quot;,
      module       = args.module,
      view         = args.view,
      action       = args.action
    }
  end
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_227').style.display = document.getElementById('autodoc_details_227').style.display ? '' : 'none';">
    trace.restore_slots{ }
  </div>
  <div id="autodoc_details_227" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>trace.restore_slots{
}</pre>
    </div>
    <div class="autodoc_comment">This function is used to log the event of restoring previously stored slot contents.    </div>
    <div class="autodoc_source">
<pre>function trace.restore_slots(args)
  if not trace._disabled then
    trace._new_entry{ type = &quot;restore_slots&quot; }
  end
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_228').style.display = document.getElementById('autodoc_details_228').style.display ? '' : 'none';">
    trace.sql{ command = command, error_position = error_position }
  </div>
  <div id="autodoc_details_228" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>trace.sql{
  command        = command,        <span class="autodoc_comment_tail">-- executed SQL command as string</span>
  error_position = error_position  <span class="autodoc_comment_tail">-- optional position in bytes where an error occurred</span>
}</pre>
    </div>
    <div class="autodoc_comment">This command can be used to log SQL command execution. It is currently not invoked automatically.    </div>
    <div class="autodoc_source">
<pre><span class="autodoc_comment_tail">-- TODO: automatic use of this function?</span>

function trace.sql(args)
  if not trace._disabled then
    local command = args.command
    local error_position = args.error_position
    if type(command) ~= &quot;string&quot; then
      error(&quot;No command string passed to trace.sql{...}.&quot;)
    end
    if error_position and type(error_position) ~= &quot;number&quot; then
      error(&quot;error_position must be a number.&quot;)
    end
    trace._new_entry{
      type = &quot;sql&quot;,
      command = command,
      error_position = error_position
    }
  end
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_229').style.display = document.getElementById('autodoc_details_229').style.display ? '' : 'none';">
    ui._partial_load_js{ ... }
  </div>
  <div id="autodoc_details_229" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>ui._partial_load_js(
  {
    module = module,
    view   = view,
    id     = id,
    params = params,
    target = target
  },
  mode = mode
}</pre>
    </div>
    <div class="autodoc_comment">This function is not supposed to be called directly, but only to be used by<br/>ui.link{...} and ui.form{...}.<br/><br/>It returns a JavaScript which can be used for onclick or onsubmit<br/>attributes in HTML to cause a partial load of contents. Behaviour differs<br/>for the following cases:<br/>a) module, view and target (and optionally id) are given as parameters<br/>b) neither module, view, id, nor target are given as parameters<br/><br/>In case of a) the function will create a JavaScript which requests the<br/>given view (optionally with the given id and params) as JSON data.<br/><br/>In case of b) the function will create a JavaScript requesting the view<br/>specified by the next outer ui.partial{...} call as JSON data. Request<br/>parameters specified by previous calls of add_partial_param_names({...})<br/>are copied from the GET/POST parameters of the current request, while they<br/>can be overwritten using the &quot;params&quot; argument to this function.<br/><br/>If there is no outer ui.partial{...} call in case b), then this function<br/>returns nil.<br/><br/>The called URL contains &quot;_webmcp_json_slots[]&quot; as GET parameters to<br/>indicate that slot contents should be returned as a JSON object, instead of<br/>being inserted to a page layout.<br/><br/>TODO: Currently the slots requested are &quot;default&quot;, &quot;trace&quot; and<br/>&quot;system_error&quot;. The target for the slot &quot;default&quot; is passed as argument to<br/>this function or to ui.partial{...}. The targets for the slots &quot;trace&quot; and<br/>&quot;system_error&quot; are &quot;trace&quot; and &quot;system_error&quot;. This is hardcoded and should<br/>be possible to change in future. The JavaScript will fail, if there are no<br/>HTML elements with id's &quot;trace&quot; and &quot;system_error&quot;.<br/><br/>A mode can be passed as second parameter to this function. When this mode<br/>is &quot;nil&quot; or non existent, the function creates JavaScript code to be used<br/>as onclick event for normal (GET) links. When mode is set to &quot;form_normal&quot;<br/>or &quot;form_action&quot;, the returned code can be used as onsubmit event of web<br/>forms. &quot;form_normal&quot; is used when the form calls a view, &quot;form_action&quot; is<br/>used when the form calls an action.    </div>
    <div class="autodoc_source">
<pre>function ui._partial_load_js(args, mode)
  local args = args or {}
  local module
  local view
  local id
  local params = {}
  local target
  if args.view and args.target then
    module = args.module
    view   = args.view
    id     = args.id
    target = args.target
  elseif not args.view and not args.target then
    if not ui._partial_state then
      return nil
    end
    module = ui._partial_state.module
    view   = ui._partial_state.view
    id     = ui._partial_state.id
    target = ui._partial_state.target
  else
    error(&quot;Unexpected arguments passed to ui._partial_load_js{...}&quot;)
  end

  if ui._partial_state then
    <span class="autodoc_comment_tail">-- TODO: do this only if args.view and args.target are unset!?</span>
    if ui._partial_state.params then
      for key, value in pairs(ui._partial_state.params) do
        params[key] = value
      end
    end
    for param_name, dummy in pairs(ui._partial_state.param_name_hash) do
      params[param_name] = cgi.params[param_name]
    end
  end
  if args.params then
    for key, value in pairs(args.params) do
      params[key] = value
    end
  end
  local encoded_url = encode.json(
    encode.url{
      module = module,
      view   = view,
      id     = id,
      params = params
    }
  )

  if mode == &quot;form_normal&quot; then
    <span class="autodoc_comment_tail">-- NOTE: action in &quot;action_mode&quot; refers to WebMCP actions, while action</span>
    <span class="autodoc_comment_tail">-- in &quot;this.action&quot; refers to the action attribute of HTML forms</span>
    slot.put('this.action = ', encoded_url, '; ')
  end

  return slot.use_temporary(function()
    slot.put(
      'partialMultiLoad({',
        <span class="autodoc_comment_tail">-- mapping:</span>
        '&quot;trace&quot;: &quot;trace&quot;, &quot;system_error&quot;: &quot;system_error&quot;, ',
        encode.json(target), ': &quot;default&quot; }, ',
        <span class="autodoc_comment_tail">-- tempLoadingContents:</span>
        '{}, ',
        <span class="autodoc_comment_tail">-- failureContents:</span>
        '&quot;error&quot;, ',
        <span class="autodoc_comment_tail">-- url:</span>
        (mode == &quot;form_normal&quot; or mode == &quot;form_action&quot;) and (
          'this'
        ) or (
          encoded_url
        ), ', ',
        <span class="autodoc_comment_tail">-- urlParams:</span>
        '&quot;_webmcp_json_slots[]=default&amp;_webmcp_json_slots[]=trace&amp;_webmcp_json_slots[]=system_error&quot;, ',
        <span class="autodoc_comment_tail">-- postParams:</span>
        '{}, ',
        <span class="autodoc_comment_tail">-- successHandler:</span>
        'function() {}, ',
        <span class="autodoc_comment_tail">-- failureHandler:</span>
        'function() {} ',
      '); ',
      'return false;'
    )
  end)
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_230').style.display = document.getElementById('autodoc_details_230').style.display ? '' : 'none';">
    ui.add_partial_param_names( name_list )
  </div>
  <div id="autodoc_details_230" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>ui.add_partial_param_names(
  name_list
)</pre>
    </div>
    <div class="autodoc_comment">This function adds names of GET/POST parameters to the list of parameters<br/>which are to be copied when calling ui._partial_load_js{...} or<br/>ui.link{..., partial = {...}} or ui.form{..., partial = {...}}.    </div>
    <div class="autodoc_source">
<pre>function ui.add_partial_param_names(name_list)
  if ui._partial_state then
    for idx, param_name in ipairs(name_list) do
      ui._partial_state.param_name_hash[param_name] = true
    end
  end
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_231').style.display = document.getElementById('autodoc_details_231').style.display ? '' : 'none';">
    ui.anchor{ name = name, attr = attr, content = content }
  </div>
  <div id="autodoc_details_231" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>ui.anchor{
  name    = name,    <span class="autodoc_comment_tail">-- name of anchor</span>
  attr    = attr,    <span class="autodoc_comment_tail">-- table of HTML attributes</span>
  content = content  <span class="autodoc_comment_tail">-- string to be HTML encoded, or function to be executed</span>
}</pre>
    </div>
    <div class="autodoc_comment">This function writes an HTML anchor into the active slot.    </div>
    <div class="autodoc_source">
<pre>function ui.anchor(args)
  local attr = table.new(args.attr)
  attr.name = args.name
  return ui.tag{
    tag = &quot;a&quot;,
    attr = attr,
    content = args.content
  }
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_232').style.display = document.getElementById('autodoc_details_232').style.display ? '' : 'none';">
    ui.autofield{ ... }
  </div>
  <div id="autodoc_details_232" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>ui.autofield{
  name           = name,               <span class="autodoc_comment_tail">-- field name (also used by default as HTML name)</span>
  html_name      = html_name,          <span class="autodoc_comment_tail">-- explicit HTML name to be used instead of 'name'</span>
  value          = nihil.lift(value),  <span class="autodoc_comment_tail">-- initial value, nil causes automatic lookup of value, use nihil.lift(nil) for nil</span>
  container_attr = container_attr,     <span class="autodoc_comment_tail">-- extra HTML attributes for the container (div) enclosing field and label</span>
  attr           = attr,               <span class="autodoc_comment_tail">-- extra HTML attributes for the field</span>
  label          = label,              <span class="autodoc_comment_tail">-- text to be used as label for the input field</span>
  label_attr     = label_attr,         <span class="autodoc_comment_tail">-- extra HTML attributes for the label</span>
  readonly       = readonly_flag       <span class="autodoc_comment_tail">-- set to true, to force read-only mode</span>
  record         = record,             <span class="autodoc_comment_tail">-- record to be used, defaults to record given to ui.form{...}</span>
  ...                                  <span class="autodoc_comment_tail">-- extra arguments for applicable ui.field.* helpers</span>
}</pre>
    </div>
    <div class="autodoc_comment">This function automatically selects a ui.field.* helper to be used for a field of a record.    </div>
    <div class="autodoc_source">
<pre>function ui.autofield(args)
  local args = table.new(args)
  assert(args.name, &quot;ui.autofield{...} needs a field 'name'.&quot;)
  if not args.record then
    local slot_state = slot.get_state_table()
    if not slot_state then
      error(&quot;ui.autofield{...} was called without an explicit record to be used, and is also not called inside a form.&quot;)
    elseif not slot_state.form_record then
      error(&quot;ui.autofield{...} was called without an explicit record to be used, and the form does not have a record assigned either.&quot;)
    else
      args.record = slot_state.form_record
    end
  end
  local class = args.record._class
  assert(class, &quot;Used ui.autofield{...} on a record with no class information stored in the '_class' attribute.&quot;)
  local fields, field_info, ui_field_type, ui_field_options
  fields = class.fields
  if fields then
    field_info = fields[args.name]
  end
  if field_info then
    ui_field_type    = field_info.ui_field_type
    ui_field_options = table.new(field_info.ui_field_options)
  end
  if not ui_field_type then
    ui_field_type = &quot;text&quot;
  end
  if not ui_field_options then
    ui_field_options = {}
  end
  local ui_field_func = ui.field[ui_field_type]
  if not ui_field_func then
    error(string.format(&quot;Did not find ui.field helper of type %q.&quot;, ui_field_type))
  end
  for key, value in pairs(ui_field_options) do
    if args[key] == nil then
      args[key] = value
    end
  end
  return ui_field_func(args)
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_233').style.display = document.getElementById('autodoc_details_233').style.display ? '' : 'none';">
    ui.container{ ... }
  </div>
  <div id="autodoc_details_233" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>ui.container{
  auto_args = auto_args,
  attr          = attr,           <span class="autodoc_comment_tail">-- HTML attributes for the surrounding div or fieldset</span>
  label         = label,          <span class="autodoc_comment_tail">-- text to be used as label</span>
  label_for     = label_for,      <span class="autodoc_comment_tail">-- DOM id of element to which the label should refer</span>
  label_attr    = label_attr,     <span class="autodoc_comment_tail">-- extra HTML attributes for a label tag</span>
  legend        = legend,         <span class="autodoc_comment_tail">-- text to be used as legend</span>
  legend_attr   = legend_attr,    <span class="autodoc_comment_tail">-- HTML attributes for a legend tag</span>
  content_first = content_first,  <span class="autodoc_comment_tail">-- set to true to place label or legend after the content</span>
  content = function()
    ...
  end
}</pre>
    </div>
    <div class="autodoc_comment">This function encloses content in a div element (or a fieldset element, if 'legend' is given). An additional 'label' or 'legend' can be placed before the content or after the content. The argument 'auto_args' is set by other ui helper functions when calling ui.container automatically.    </div>
    <div class="autodoc_source">
<pre>function ui.container(args)
  local attr, label, label_attr, legend, legend_attr, content
  local auto_args = args.auto_args
  if auto_args then
    attr        = auto_args.container_attr
    label       = auto_args.label
    label_attr  = auto_args.label_attr
    legend      = auto_args.legend
    legend_attr = auto_args.legend_attr
    if label and auto_args.attr and auto_args.attr.id then
      label_attr = table.new(label_attr)
      label_attr[&quot;for&quot;] = auto_args.attr.id
    end
  else
    attr        = args.attr
    label       = args.label
    label_attr  = args.label_attr or {}
    legend      = args.legend
    legend_attr = args.legend_attr
    content     = content
    if args.label_for then
      label_attr[&quot;for&quot;] = args.label_for
    end
  end
  local content = args.content
  if label and not legend then
    return ui.tag {
      tag     = &quot;div&quot;,
      attr    = attr,
      content = function()
        if not args.content_first then
          ui.tag{ tag = &quot;label&quot;, attr = label_attr, content = label }
          slot.put(&quot; &quot;)
        end
        if type(content) == &quot;function&quot; then
          content()
        elseif content then
          slot.put(encode.html(content))
        end
        if args.content_first then
          slot.put(&quot; &quot;)
          ui.tag{ tag = &quot;label&quot;, attr = label_attr, content = label }
        end
      end
    }
  elseif legend and not label then
    return ui.tag {
      tag     = &quot;fieldset&quot;,
      attr    = attr,
      content = function()
        if not args.content_first then
          ui.tag{ tag = &quot;legend&quot;, attr = legend_attr, content = legend }
          slot.put(&quot; &quot;)
        end
        if type(content) == &quot;function&quot; then
          content()
        elseif content then
          slot.put(encode.html(content))
        end
        if args.content_first then
          slot.put(&quot; &quot;)
          ui.tag{ tag = &quot;legend&quot;, attr = legend_attr, content = legend }
        end
      end
    }
  elseif fieldset and label then
    error(&quot;ui.container{...} may either get a label or a legend.&quot;)
  else
    return ui.tag{ tag = &quot;div&quot;, attr = attr, content = content }
  end
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_234').style.display = document.getElementById('autodoc_details_234').style.display ? '' : 'none';">
    ui.create_unique_id()
  </div>
  <div id="autodoc_details_234" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>unique_id =            <span class="autodoc_comment_tail">-- unique string to be used as an id in the DOM tree</span>
ui.create_unique_id()</pre>
    </div>
    <div class="autodoc_comment">This function returns a unique string to be used as an id in the DOM tree for elements.    </div>
    <div class="autodoc_source">
<pre>function ui.create_unique_id()
  return &quot;unique_&quot; .. multirand.string(32, &quot;bcdfghjklmnpqrstvwxyz&quot;)
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_235').style.display = document.getElementById('autodoc_details_235').style.display ? '' : 'none';">
    ui.enable_partial_loading()
  </div>
  <div id="autodoc_details_235" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>ui.enable_partial_loading()</pre>
    </div>
    <div class="autodoc_comment">This function tells subsequent calls of ui.link{...} and ui.form{...} that<br/>partial loading should be enabled when requested by passing &quot;partial&quot;<br/>arguments to ui.link or ui.form.<br/><br/>NOTE: To use partial loading, the slots being requested need to be<br/>white-listed by calling request.set_allowed_json_request_slots({...})<br/>in the application configuration file. TODO: By now, at least the slot<br/>names &quot;default&quot;, &quot;trace&quot; and &quot;system_error&quot; need to be white-listed, as<br/>these slots are currently hardwired in ui._partial_load_js(...).    </div>
    <div class="autodoc_source">
<pre>function ui.enable_partial_loading()
  ui._partial_loading_enabled = true
  request.force_absolute_baseurl()
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_236').style.display = document.getElementById('autodoc_details_236').style.display ? '' : 'none';">
    ui.field.boolean{ ... style = style, nil_allowed = nil_allowed }
  </div>
  <div id="autodoc_details_236" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>ui.field.boolean{
  ...                        <span class="autodoc_comment_tail">-- generic ui.field.* arguments, as described for ui.autofield{...}</span>
  style       = style,       <span class="autodoc_comment_tail">-- &quot;radio&quot; or &quot;checkbox&quot;,</span>
  nil_allowed = nil_allowed  <span class="autodoc_comment_tail">-- set to true, if nil is allowed as third value</span>
}</pre>
    </div>
    <div class="autodoc_comment">This function inserts a field for boolean values in the active slot. For description of the generic field helper arguments, see help for ui.autofield{...}.    </div>
    <div class="autodoc_source">
<pre>function ui.field.boolean(args)
  local style = args.style
  if not style then
    if args.nil_allowed then
      style = &quot;radio&quot;
    else
      style = &quot;checkbox&quot;
    end
  end
  local extra_args = { fetch_value = true }
  if not args.readonly and args.style == &quot;radio&quot; then
    extra_args.disable_label_for_id = true
  end
  ui.form_element(args, extra_args, function(args)
    local value = args.value
    if value ~= true and value ~= false and value ~= nil then
      error(&quot;Boolean value must be true, false or nil.&quot;)
    end
    if value == nil then
      if args.nil_allowed then
        value = args.default
      else
        value = args.default or false
      end
    end
    if args.readonly then
      ui.tag{
        tag     = args.tag,
        attr    = args.attr,
        content = format.boolean(value, args.format_options)
      }
    elseif style == &quot;radio&quot; then
      local attr = table.new(args.attr)
      attr.type  = &quot;radio&quot;
      attr.name  = args.html_name
      attr.id    = ui.create_unique_id()
      attr.value = &quot;1&quot;
      if value == true then
        attr.checked = &quot;checked&quot;
      else
        attr.checked = nil
      end
      ui.container{
        attr          = { class = &quot;ui_radio_div&quot; },
        label         = args.true_as or &quot;Yes&quot;,  <span class="autodoc_comment_tail">-- TODO: localize</span>
        label_for     = attr.id,
        label_attr    = { class = &quot;ui_radio_label&quot; },
        content_first = true,
        content       = function()
          ui.tag{ tag  = &quot;input&quot;, attr = attr }
        end
      }
      attr.id    = ui.create_unique_id()
      attr.value = &quot;0&quot;
      if value == false then
        attr.checked = &quot;1&quot;
      else
        attr.checked = nil
      end
      ui.container{
        attr          = { class = &quot;ui_radio_div&quot; },
        label         = args.false_as or &quot;No&quot;,  <span class="autodoc_comment_tail">-- TODO: localize</span>
        label_for     = attr.id,
        label_attr    = { class = &quot;ui_radio_label&quot; },
        content_first = true,
        content       = function()
          ui.tag{ tag  = &quot;input&quot;, attr = attr }
        end
      }
      if args.nil_allowed then
        attr.id    = ui.create_unique_id()
        attr.value = &quot;&quot;
        if value == nil then
          attr.checked = &quot;1&quot;
        else
          attr.checked = nil
        end
        ui.container{
          attr          = { class = &quot;ui_radio_div&quot; },
          label         = args.nil_as or &quot;N/A&quot;,  <span class="autodoc_comment_tail">-- TODO: localize</span>
          label_for     = attr.id,
          label_attr    = { class = &quot;ui_radio_label&quot; },
          content_first = true,
          content       = function()
            ui.tag{ tag  = &quot;input&quot;, attr = attr }
          end
        }
      end
      ui.hidden_field{
        name = args.html_name .. &quot;__format&quot;, value = &quot;boolean&quot;
      }
    elseif style == &quot;checkbox&quot; then
      if args.nil_allowed then
        error(&quot;Checkboxes do not support nil values.&quot;)
      end
      local attr = table.new(args.attr)
      attr.type  = &quot;checkbox&quot;
      attr.name  = args.html_name
      attr.value = &quot;1&quot;
      if value then
        attr.checked = &quot;checked&quot;
      else
        attr.checked = nil
      end
      ui.tag{ tag = &quot;input&quot;, attr = attr }
      ui.hidden_field{
        name = args.html_name .. &quot;__format&quot;,
        value = encode.format_info(
          &quot;boolean&quot;,
          { true_as = &quot;1&quot;, false_as = &quot;&quot; }
        )
      }
    else
      error(&quot;'style' attribute for ui.field.boolean{...} must be set to \&quot;radio\&quot;, \&quot;checkbox\&quot; or nil.&quot;)
    end
  end)
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_237').style.display = document.getElementById('autodoc_details_237').style.display ? '' : 'none';">
    ui.field.date{ ... }
  </div>
  <div id="autodoc_details_237" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>ui.field.date{
  ...           <span class="autodoc_comment_tail">-- generic ui.field.* arguments, as described for ui.autofield{...}</span>
}</pre>
    </div>
    <div class="autodoc_comment">This function inserts a field for dates in the active slot. If the JavaScript library &quot;gregor.js&quot; has been loaded, a rich input field is used. For description of the generic field helper arguments, see help for ui.autofield{...}.    </div>
    <div class="autodoc_source">
<pre>function ui.field.date(args)
  ui.form_element(args, {fetch_value = true}, function(args)
    local value_string = format.date(args.value, args.format_options)
    if args.readonly then
      ui.tag{ tag = args.tag, attr = args.attr, content = value_string }
    else
      local fallback_data = slot.use_temporary(function()
        local attr = table.new(args.attr)
        attr.type  = &quot;text&quot;
        attr.name  = args.html_name
        attr.value = value_string
        attr.class = attr.class or &quot;ui_field_date&quot;
        ui.tag{ tag  = &quot;input&quot;, attr = attr }
        ui.hidden_field{
          name  = args.html_name .. &quot;__format&quot;,
          value = encode.format_info(&quot;date&quot;, args.format_options)
        }
      end)
      local user_field_id, hidden_field_id
      local helper_data = slot.use_temporary(function()
        local attr = table.new(args.attr)
        user_field_id = attr.id or ui.create_unique_id()
        hidden_field_id = ui.create_unique_id()
        attr.id    = user_field_id
        attr.type  = &quot;text&quot;
        attr.class = attr.class or &quot;ui_field_date&quot;
        ui.tag{ tag = &quot;input&quot;, attr = attr }
        local attr = table.new(args.attr)
        attr.id    = hidden_field_id
        attr.type  = &quot;hidden&quot;
        attr.name  = args.html_name
        attr.value = atom.dump(args.value)  <span class="autodoc_comment_tail">-- extra safety for JS failure</span>
        ui.tag{
          tag = &quot;input&quot;,
          attr = {
            id   = hidden_field_id,
            type = &quot;hidden&quot;,
            name = args.html_name
          }
        }
      end)
      <span class="autodoc_comment_tail">-- TODO: localization</span>
      ui.script{
        noscript = fallback_data,
        type     = &quot;text/javascript&quot;,
        content  = function()
          slot.put(
            &quot;if (gregor_addGui == null) document.write(&quot;,
            encode.json(fallback_data),
            &quot;); else { document.write(&quot;,
            encode.json(helper_data),
            &quot;); gregor_addGui({element_id: &quot;,
            encode.json(user_field_id),
            &quot;, month_names: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'], weekday_names: ['Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa', 'Su'], week_numbers: 'left', format: 'DD.MM.YYYY', selected: &quot;
          )
          if (args.value) then
            slot.put(
              &quot;{year: &quot;, tostring(args.value.year),
              &quot;, month: &quot;, tostring(args.value.month),
              &quot;, day: &quot;, tostring(args.value.day),
              &quot;}&quot;
            )
          else
            slot.put(&quot;null&quot;)
          end
          slot.put(
           &quot;, select_callback: function(date) { document.getElementById(&quot;,
           encode.json(hidden_field_id),
           &quot;).value = (date == null) ? '' : date.iso_string; } } ) }&quot;
          )
        end
      }
    end
  end)
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_238').style.display = document.getElementById('autodoc_details_238').style.display ? '' : 'none';">
    ui.field.file{ ... }
  </div>
  <div id="autodoc_details_238" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>ui.field.file{
  ...                        <span class="autodoc_comment_tail">-- generic ui.field.* arguments, as described for ui.autofield{...}</span>
}</pre>
    </div>
    <div class="autodoc_comment">This function inserts a field for uploading a file in the active slot. For read-only forms this function does nothing. For description of the generic field helper arguments, see help for ui.autofield{...}.    </div>
    <div class="autodoc_source">
<pre>function ui.field.file(args)
  ui.form_element(args, nil, function(args)
    if args.readonly then
      <span class="autodoc_comment_tail">-- nothing</span>
    else
      if not slot.get_state_table().form_file_upload then
        error('Parameter &quot;file_upload&quot; of ui.form{...} must be set to true to allow file uploads.')
      end
      local attr = table.new(args.attr)
      attr.type  = &quot;file&quot;
      attr.name  = args.html_name
      ui.tag{ tag  = &quot;input&quot;, attr = attr }
    end
  end)
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_239').style.display = document.getElementById('autodoc_details_239').style.display ? '' : 'none';">
    ui.field.hidden{ ... }
  </div>
  <div id="autodoc_details_239" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>ui.field.hidden{
  ...             <span class="autodoc_comment_tail">-- generic ui.field.* arguments, as described for ui.autofield{...}</span>
}</pre>
    </div>
    <div class="autodoc_comment">This function inserts a hidden form field in the active slot. It is a high level function compared to ui.hidden_field{...}. If called inside a read-only form, then this function does nothing.    </div>
    <div class="autodoc_source">
<pre>function ui.field.hidden(args)
  ui.form_element(args, {fetch_value = true}, function(args)
    if not args.readonly then
      ui.hidden_field{
        attr  = args.attr,
        name  = args.html_name,
        value = args.value
      }
    end
  end)
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_240').style.display = document.getElementById('autodoc_details_240').style.display ? '' : 'none';">
    ui.field.integer{ ... format_options = format_options }
  </div>
  <div id="autodoc_details_240" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>ui.field.integer{
  ...                              <span class="autodoc_comment_tail">-- generic ui.field.* arguments, as described for ui.autofield{...}</span>
  format_options = format_options  <span class="autodoc_comment_tail">-- format options for format.decimal</span>
}</pre>
    </div>
    <div class="autodoc_comment">This function inserts a field for an integer in the active slot. For description of the generic field helper arguments, see help for ui.autofield{...}.    </div>
    <div class="autodoc_source">
<pre>function ui.field.integer(args)
  ui.form_element(args, {fetch_value = true}, function(args)
    local value_string = format.decimal(args.value, args.format_options)
    if args.readonly then
      ui.tag{ tag = args.tag, attr = args.attr, content = value_string }
    else
      local attr = table.new(args.attr)
      attr.type  = &quot;text&quot;
      attr.name  = args.html_name
      attr.value = value_string
      ui.tag{ tag  = &quot;input&quot;, attr = attr }
      ui.hidden_field{
        name  = args.html_name .. &quot;__format&quot;,
        value = encode.format_info(&quot;decimal&quot;, args.format_options)
      }
    end
  end)
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_241').style.display = document.getElementById('autodoc_details_241').style.display ? '' : 'none';">
    ui.field.password{ ... }
  </div>
  <div id="autodoc_details_241" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>ui.field.password{
  ...                        <span class="autodoc_comment_tail">-- generic ui.field.* arguments, as described for ui.autofield{...}</span>
}</pre>
    </div>
    <div class="autodoc_comment">This function inserts a field for a password in the active slot. For read-only forms this function does nothing. For description of the generic field helper arguments, see help for ui.autofield{...}.    </div>
    <div class="autodoc_source">
<pre>function ui.field.password(args)
  ui.form_element(args, {fetch_value = true}, function(args)
    local value_string = atom.dump(args.value)
    if args.readonly then
      <span class="autodoc_comment_tail">-- nothing</span>
    else
      local attr = table.new(args.attr)
      attr.type  = &quot;password&quot;
      attr.name  = args.html_name
      attr.value = value_string
      ui.tag{ tag  = &quot;input&quot;, attr = attr }
    end
  end)
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_242').style.display = document.getElementById('autodoc_details_242').style.display ? '' : 'none';">
    ui.field.select{ ... }
  </div>
  <div id="autodoc_details_242" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>ui.field.select{
  ...                                  <span class="autodoc_comment_tail">-- generic ui.field.* arguments, as described for ui.autofield{...}</span>
  foreign_records  = foreign_records,  <span class="autodoc_comment_tail">-- list of records to be chosen from, or function returning such a list</span>
  foreign_id       = foreign_id,       <span class="autodoc_comment_tail">-- name of id field in foreign records</span>
  foreign_name     = foreign_name,     <span class="autodoc_comment_tail">-- name of field to be used as name in foreign records</span>
  format_options   = format_options    <span class="autodoc_comment_tail">-- format options for format.string</span>
  selected_record  = selected_record   <span class="autodoc_comment_tail">-- id of (or reference to) record which is selected (optional, overrides &quot;value&quot; argument when not nil)</span>
  disabled_records = disabled_records  <span class="autodoc_comment_tail">-- table with ids of (or references to) records that should be disabled (stored as table keys mapped to true)</span>
}</pre>
    </div>
    <div class="autodoc_comment">This function inserts a select field in the active slot. For description of the generic field helper arguments, see help for ui.autofield{...}.    </div>
    <div class="autodoc_source">
<pre>function ui.field.select(args)
  ui.form_element(args, {fetch_value = true}, function(args)
    local foreign_records = args.foreign_records
    if type(foreign_records) == &quot;function&quot; then
      foreign_records = foreign_records(args.record)
    end
    if args.readonly then
      local name
      for idx, record in ipairs(foreign_records) do
        if record[args.foreign_id] == args.value then
          name = record[args.foreign_name]
          break
        end
      end
      ui.tag{
        tag     = args.tag,
        attr    = args.attr,
        content = format.string(name, args.format_options)
      }
    else
      local attr = table.new(args.attr)
      attr.name  = args.html_name
      ui.tag{
        tag     = &quot;select&quot;,
        attr    = attr,
        content = function()
          if args.nil_as then
            ui.tag{
              tag     = &quot;option&quot;,
              attr    = { value = &quot;&quot; },
              content = format.string(
                args.nil_as,
                args.format_options
              )
            }
          end
          local one_selected = false
          for idx, record in ipairs(foreign_records) do
            local key = record[args.foreign_id]
            local selected = false
            if not one_selected then
              if args.selected_record == nil then
                if args.value == key then
                  selected = true
                end
              else
                if args.selected_record == record or args.selected_record == key then
                  selected = true
                end
              end
              one_selected = selected
            end
            local disabled = false
            if args.disabled_records then
              if args.disabled_records[record] or args.disabled_records[key] then
                disabled = true
              end
            end
            ui.tag{
              tag     = &quot;option&quot;,
              attr    = {
                value    = key,
                disabled = disabled and &quot;disabled&quot; or nil,
                selected = selected and &quot;selected&quot; or nil
              },
              content = format.string(
                record[args.foreign_name],
                args.format_options
              )
            }
          end
        end
      }
    end
  end)
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_243').style.display = document.getElementById('autodoc_details_243').style.display ? '' : 'none';">
    ui.field.text{ ... format_options = format_options }
  </div>
  <div id="autodoc_details_243" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>ui.field.text{
  ...                              <span class="autodoc_comment_tail">-- generic ui.field.* arguments, as described for ui.autofield{...}</span>
  format_options = format_options  <span class="autodoc_comment_tail">-- format options for format.string</span>
}</pre>
    </div>
    <div class="autodoc_comment">This function inserts a field for a text in the active slot. For description of the generic field helper arguments, see help for ui.autofield{...}.    </div>
    <div class="autodoc_source">
<pre>function ui.field.text(args)
  ui.form_element(args, {fetch_value = true}, function(args)
    local value_string = format.string(args.value, args.format_options)
    if args.readonly then
      ui.tag{ tag = args.tag, attr = args.attr, content = value_string }
    else
      local attr = table.new(args.attr)
      attr.name  = args.html_name
      if args.multiline then
        ui.tag { tag = &quot;textarea&quot;, attr = attr, content = value_string }
      else
        attr.type  = &quot;text&quot;
        attr.value = value_string
        ui.tag{ tag  = &quot;input&quot;, attr = attr }
      end
    end
  end)
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_244').style.display = document.getElementById('autodoc_details_244').style.display ? '' : 'none';">
    ui.filters{ ... }
  </div>
  <div id="autodoc_details_244" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>ui.filters{
  selector = selector,  <span class="autodoc_comment_tail">-- selector to be modified</span>
  label    = label,     <span class="autodoc_comment_tail">-- text to be displayed when filters are collapsed</span>
  {
    name  = name1,      <span class="autodoc_comment_tail">-- name of first filter (used as GET param)</span>
    label = label1,     <span class="autodoc_comment_tail">-- label of first filter</span>
    {
      name  = name1a,   <span class="autodoc_comment_tail">-- name of first option of first filter</span>
      label = label1a,  <span class="autodoc_comment_tail">-- label of first option of first filter</span>
      selector_modifier = function(selector)
        ...
      end
    },
    {
      name  = name1b,   <span class="autodoc_comment_tail">-- name of second option of first filter</span>
      label = label1b,  <span class="autodoc_comment_tail">-- label of second option of first filter</span>
      selector_modifier = function(selector)
        ...
      end
    },
    ...
  },
  {
    name  = name2,      <span class="autodoc_comment_tail">-- name of second filter (used as GET param)</span>
    label = label2,     <span class="autodoc_comment_tail">-- label of second filter</span>
    {
      ...
    }, {
      ...
    },
    ...
  },
  ...
  content = function()
    ...                 <span class="autodoc_comment_tail">-- inner code where filter is to be applied</span>
  end
}</pre>
    </div>
    <div class="autodoc_comment">    </div>
    <div class="autodoc_source">
<pre>function ui.filters(args)
  local el_id = ui.create_unique_id()
  ui.container{
    attr = { class = &quot;ui_filter&quot; },
    content = function()
      ui.container{
        attr = {
          class = &quot;ui_filter_closed_head&quot;
        },
        content = function()
          ui.tag{
            tag = &quot;span&quot;,
            content = function()
              local current_options = {}
              for idx, filter in ipairs(args) do
                local filter_name = filter.name or &quot;filter&quot;
                local current_option = atom.string:load(cgi.params[filter_name])
                if not current_option then
                  current_option = param.get(filter_name)
                end
                if not current_option or #current_option == 0 then
                  current_option = filter[1].name
                end
                for idx, option in ipairs(filter) do
                  if current_option == option.name then
                    current_options[#current_options+1] = encode.html(filter.label) .. &quot;: &quot; .. encode.html(option.label)
                  end
                end
              end
              slot.put(table.concat(current_options, &quot;; &quot;))
            end
          }
          slot.put(&quot; (&quot;)
          ui.link{
            attr = {
              onclick = &quot;this.parentNode.style.display='none'; document.getElementById('&quot; .. el_id .. &quot;_head').style.display='block'; return(false);&quot;
            },
            text = args.label,
            external = &quot;#&quot;
          }
          slot.put(&quot;)&quot;)
        end
      }
      ui.container{
        attr = {
          id = el_id .. &quot;_head&quot;,
          style = &quot;display: none;&quot;
        },
        content = function()
          for idx, filter in ipairs(args) do
            local filter_name = filter.name or &quot;filter&quot;
            local current_option = atom.string:load(cgi.params[filter_name])
            if not current_option then
              current_option = param.get(filter_name)
            end
            if not current_option or #current_option == 0 then
              current_option = filter[1].name
            end
            local id     = request.get_id_string()
            local params = request.get_param_strings()
            ui.container{
              attr = { class = &quot;ui_filter_head&quot; },
              content = function()
                slot.put(filter.label or &quot;Filter&quot;, &quot;: &quot;)
                for idx, option in ipairs(filter) do
                  params[filter_name] = option.name
                  local attr = {}
                  if current_option == option.name then
                    attr.class = &quot;active&quot;
                    option.selector_modifier(args.selector)
                  end
                  ui.link{
                    attr    = attr,
                    module  = request.get_module(),
                    view    = request.get_view(),
                    id      = id,
                    params  = params,
                    text    = option.label,
                    partial = {
                      params = {
                        [filter_name] = option.name
                      }
                    }
                  }
                end
              end
            }
          end
        end
      }
    end
  }
  ui.container{
    attr = { class = &quot;ui_filter_content&quot; },
    content = function()
      args.content()
    end
  }
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_245').style.display = document.getElementById('autodoc_details_245').style.display ? '' : 'none';">
    ui.form_element{ ... }
  </div>
  <div id="autodoc_details_245" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>ui.form_element(
  args,                                                <span class="autodoc_comment_tail">-- external arguments</span>
  {                                                    <span class="autodoc_comment_tail">-- options for this function call</span>
    fetch_value          = fetch_value_flag,           <span class="autodoc_comment_tail">-- true causes automatic determination of args.value, if nil</span>
    fetch_record         = fetch_record_flag,          <span class="autodoc_comment_tail">-- true causes automatic determination of args.record, if nil</span>
    disable_label_for_id = disable_label_for_id_flag,  <span class="autodoc_comment_tail">-- true suppresses automatic setting of args.attr.id for a HTML label_for reference</span>
  },
  function(args)
    ...                                                <span class="autodoc_comment_tail">-- program code</span>
  end
)</pre>
    </div>
    <div class="autodoc_comment">This function helps other form helpers by preprocessing arguments passed to the helper, e.g. fetching a value from a record stored in a state-table of the currently active slot.    </div>
    <div class="autodoc_source">
<pre><span class="autodoc_comment_tail">-- TODO: better documentation</span>

function ui.form_element(args, extra_args, func)
  local args = table.new(args)
  if extra_args then
    for key, value in pairs(extra_args) do
      args[key] = value
    end
  end
  local slot_state = slot.get_state_table()
  args.html_name = args.html_name or args.name
  if args.fetch_value then
    if args.value == nil then
      if not args.record and slot_state then
        args.record = slot_state.form_record
      end
      if args.record then
        args.value = args.record[args.name]
      end
    else
      args.value = nihil.lower(args.value)
    end
  elseif args.fetch_record then
    if not args.record and slot_state then
      args.record = slot_state.form_record
    end
  end
  if
    args.html_name and
    not args.readonly and
    slot_state.form_readonly == false
  then
    args.readonly = false
    local prefix
    if args.html_name_prefix == nil then
      prefix = slot_state.html_name_prefix
    else
      prefix = args.html_name_prefix
    end
    if prefix then
      args.html_name = prefix .. args.html_name
    end
  else
    args.readonly = true
  end
  if args.label then
    if not args.disable_label_for_id then
      if not args.attr then
        args.attr = { id = ui.create_unique_id() }
      elseif not args.attr.id then
        args.attr.id = ui.create_unique_id()
      end
    end
    if not args.label_attr then
      args.label_attr = { class = &quot;ui_field_label&quot; }
    elseif not args.label_attr.class then
      args.label_attr.class = &quot;ui_field_label&quot;
    end
  end
  ui.container{
    auto_args = args,
    content = function() return func(args) end
  }
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_246').style.display = document.getElementById('autodoc_details_246').style.display ? '' : 'none';">
    ui.form{ ... }
  </div>
  <div id="autodoc_details_246" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>ui.form{
  record      = record,       <span class="autodoc_comment_tail">-- optional record to be used</span>
  read_only   = read_only,    <span class="autodoc_comment_tail">-- set to true, if form should be read-only (no submit button)</span>
  file_upload = file_upload,  <span class="autodoc_comment_tail">-- must be set to true, if form contains file upload element</span>
  external    = external,     <span class="autodoc_comment_tail">-- external URL to be used as HTML form action</span>
  module      = module,       <span class="autodoc_comment_tail">-- module name to be used for HTML form action</span>
  view        = view,         <span class="autodoc_comment_tail">-- view name   to be used for HTML form action</span>
  action      = action,       <span class="autodoc_comment_tail">-- action name to be used for HTML form action</span>
  routing = {
    default = {           <span class="autodoc_comment_tail">-- default routing for called action</span>
      mode   = mode,      <span class="autodoc_comment_tail">-- &quot;forward&quot; or &quot;redirect&quot;</span>
      module = module,    <span class="autodoc_comment_tail">-- optional module name, defaults to current module</span>
      view   = view,      <span class="autodoc_comment_tail">-- view name</span>
      id     = id,        <span class="autodoc_comment_tail">-- optional id to be passed to the view</span>
      params = params     <span class="autodoc_comment_tail">-- optional params to be passed to the view</span>
    },
    ok    = { ... },      <span class="autodoc_comment_tail">-- routing when &quot;ok&quot;    is returned by the called action</span>
    error = { ... },      <span class="autodoc_comment_tail">-- routing when &quot;error&quot; is returned by the called action</span>
    ...   = { ... }       <span class="autodoc_comment_tail">-- routing when &quot;...&quot;   is returned by the called action</span>
  },
  partial = {             <span class="autodoc_comment_tail">-- parameters for partial loading, see below</span>
    module = module,
    view   = view,
    id     = id,
    params = params,
    target = target
  },
  content = function()
    ...                   <span class="autodoc_comment_tail">-- code creating the contents of the form</span>
  end
}</pre>
    </div>
    <div class="autodoc_comment">This functions creates a web form, which encloses the content created by the given 'content' function. When a 'record' is given, ui.field.* helper functions will be able to automatically determine field values by using the given record. If 'read_only' is set to true, then a call of ui.submit{...} will be ignored, and ui.field.* helper functions will behave differently.<br/><br/>When passing a table as &quot;partial&quot; argument, AND if partial loading has been enabled by calling ui.enable_partial_loading(), then ui._partial_load_js is<br/>used to create an onsubmit event. The &quot;partial&quot; setting table is passed to ui._partial_load_js as first argument. See ui._partial_load_js(...) for<br/>further documentation.    </div>
    <div class="autodoc_source">
<pre>local function prepare_routing_params(params, routing, default_module)
  local routing_default_given = false
  if routing then
    for status, settings in pairs(routing) do
      if status == &quot;default&quot; then
        routing_default_given = true
      end
      local module = settings.module or default_module or request.get_module()
      assert(settings.mode, &quot;No mode specified in routing entry.&quot;)
      assert(settings.view, &quot;No view specified in routing entry.&quot;)
      params[&quot;_webmcp_routing.&quot; .. status .. &quot;.mode&quot;]   = settings.mode
      params[&quot;_webmcp_routing.&quot; .. status .. &quot;.module&quot;] = module
      params[&quot;_webmcp_routing.&quot; .. status .. &quot;.view&quot;]   = settings.view
      params[&quot;_webmcp_routing.&quot; .. status .. &quot;.id&quot;]     = settings.id
      if settings.params then
        for key, value in pairs(settings.params) do
          params[&quot;_webmcp_routing.&quot; .. status .. &quot;.params.&quot; .. key] = value
        end
      end
    end
  end
  if not routing_default_given then
    params[&quot;_webmcp_routing.default.mode&quot;]   = &quot;forward&quot;
    params[&quot;_webmcp_routing.default.module&quot;] = request.get_module()
    params[&quot;_webmcp_routing.default.view&quot;]   = request.get_view()
  end
  return params
end

function ui.form(args)
  local args = args or {}
  local slot_state = slot.get_state_table()
  local old_record      = slot_state.form_record
  local old_readonly    = slot_state.form_readonly
  local old_file_upload = slot_state.form_file_upload
  slot_state.form_record = args.record
  if args.readonly then
    slot_state.form_readonly = true
    ui.container{ attr = args.attr, content = args.content }
  else
    slot_state.form_readonly = false
    local params = table.new(args.params)
    prepare_routing_params(params, args.routing, args.module)
    params._webmcp_csrf_secret = request.get_csrf_secret()
    local attr = table.new(args.attr)
    if attr.enctype==&quot;multipart/form-data&quot; or args.file_upload then
      slot_state.form_file_upload = true
      if attr.enctype == nil then
        attr.enctype = &quot;multipart/form-data&quot;
      end
    end
    attr.action = encode.url{
      external  = args.external,
      module    = args.module or request.get_module(),
      view      = args.view,
      action    = args.action,
    }
    attr.method = args.method and string.upper(args.method) or &quot;POST&quot;
    if ui.is_partial_loading_enabled() and args.partial then
      attr.onsubmit = slot.use_temporary(function()
        local partial_mode = &quot;form_normal&quot;
        if args.action then
          partial_mode = &quot;form_action&quot;
          slot.put(
            'var element; ',
            'var formElements = []; ',
            'for (var i=0; i&lt;this.elements.length; i++) { ',
              'formElements[formElements.length] = this.elements[i]; ',
            '} ',
            'for (i=0; i&lt;formElements.length; i++) { ',
              'element = formElements[i]; ',
              'if (element.name.search(/^_webmcp_routing\\./) &gt;= 0) { ',
                'element.parentNode.removeChild(element); ',
              '} ',
            '}'
          )
          local routing_params = {}
          prepare_routing_params(
            routing_params,
            args.partial.routing,
            args.partial.module
          )
          for key, value in pairs(routing_params) do
            slot.put(
              ' ',
              'element = document.createElement(&quot;input&quot;); ',
              'element.setAttribute(&quot;type&quot;, &quot;hidden&quot;); ',
              'element.setAttribute(&quot;name&quot;, ', encode.json(key), '); ',
              'element.setAttribute(&quot;value&quot;, ', encode.json(value), '); ',
              'this.appendChild(element);'
            )
          end
          slot.put(' ')
        end
        slot.put(ui._partial_load_js(args.partial, partial_mode))
      end)
    end
    if slot_state.form_opened then
      error(&quot;Cannot open a non-readonly form inside a non-readonly form.&quot;)
    end
    slot_state.form_opened = true
    ui.tag {
      tag     = &quot;form&quot;,
      attr    = attr,
      content = function()
        if args.id then
          ui.hidden_field{ name = &quot;_webmcp_id&quot;, value = args.id }
        end
        for key, value in pairs(params) do
          ui.hidden_field{ name = key, value = value }
        end
        if args.content then
          args.content()
        end
      end
    }
    slot_state.form_opened = false
  end
  slot_state.form_file_upload = old_file_upload
  slot_state.form_readonly    = old_readonly
  slot_state.form_record      = old_record
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_247').style.display = document.getElementById('autodoc_details_247').style.display ? '' : 'none';">
    ui.heading{ level = level, attr = attr, content = content }
  </div>
  <div id="autodoc_details_247" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>ui.heading{
  level   = level,   <span class="autodoc_comment_tail">-- level from 1 to 6, defaults to 1</span>
  attr    = attr,    <span class="autodoc_comment_tail">-- extra HTML attributes</span>
  content = content  <span class="autodoc_comment_tail">-- string or function for content</span>
}</pre>
    </div>
    <div class="autodoc_comment">This function inserts a heading into the active slot.    </div>
    <div class="autodoc_source">
<pre>function ui.heading(args)
  return ui.tag{
    tag     = &quot;h&quot; .. (args.level or 1),
    attr    = args.attr,
    content = args.content
  }
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_248').style.display = document.getElementById('autodoc_details_248').style.display ? '' : 'none';">
    ui.hidden_field{ name = name, value = value, attr = attr }
  </div>
  <div id="autodoc_details_248" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>ui.hidden_field{
  name = name,    <span class="autodoc_comment_tail">-- HTML name</span>
  value = value,  <span class="autodoc_comment_tail">-- value</span>
  attr  = attr    <span class="autodoc_comment_tail">-- extra HTML attributes</span>
}</pre>
    </div>
    <div class="autodoc_comment">This function inserts a hidden form field in the active slot. It is a low level function compared to ui.field.hidden{...}.    </div>
    <div class="autodoc_source">
<pre>function ui.hidden_field(args)
  local args = args or {}
  local attr = table.new(args.attr)
  attr.type  = &quot;hidden&quot;
  attr.name  = args.name
  attr.value = atom.dump(args.value)
  return ui.tag{ tag  = &quot;input&quot;, attr = attr }
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_249').style.display = document.getElementById('autodoc_details_249').style.display ? '' : 'none';">
    ui.is_partial_loading_enabled()
  </div>
  <div id="autodoc_details_249" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>result =
ui.is_partial_loading_enabled()</pre>
    </div>
    <div class="autodoc_comment">This function returns true, if partial loading has been enabled by calling<br/>ui.enable_partial_loading().    </div>
    <div class="autodoc_source">
<pre>function ui.is_partial_loading_enabled()
  return ui._partial_loading_enabled
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_250').style.display = document.getElementById('autodoc_details_250').style.display ? '' : 'none';">
    ui.link{ ... }
  </div>
  <div id="autodoc_details_250" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>ui.link{
  external  = external,   <span class="autodoc_comment_tail">-- external URL</span>
  static    = static,     <span class="autodoc_comment_tail">-- URL relative to the static file directory</span>
  module    = module,     <span class="autodoc_comment_tail">-- module name</span>
  view      = view,       <span class="autodoc_comment_tail">-- view name</span>
  action    = action,     <span class="autodoc_comment_tail">-- action name</span>
  attr      = attr,       <span class="autodoc_comment_tail">-- for views: table of HTML attributes</span>
  a_attr    = a_attr,     <span class="autodoc_comment_tail">-- for actions: table of HTML attributes for the &quot;a&quot; tag</span>
  form_attr = form_attr,  <span class="autodoc_comment_tail">-- for actions: table of HTML attributes for the &quot;form&quot; tag</span>
  id        = id,         <span class="autodoc_comment_tail">-- optional id to be passed to the view or action to select a particular data record</span>
  params    = params,     <span class="autodoc_comment_tail">-- optional parameters to be passed to the view or action</span>
  routing   = routing,    <span class="autodoc_comment_tail">-- optional routing information for action links, as described for ui.form{...}</span>
  anchor    = anchor,     <span class="autodoc_comment_tail">-- for views: anchor in destination URL</span>
  text      = text,       <span class="autodoc_comment_tail">-- link text</span>
  content   = content,    <span class="autodoc_comment_tail">-- link content (overrides link text, except for submit buttons for action calls without JavaScript)</span>
  partial   = {           <span class="autodoc_comment_tail">-- parameters for partial loading, see below</span>
    module = module,
    view   = view,
    id     = id,
    params = params,
    target = target
  }
}</pre>
    </div>
    <div class="autodoc_comment">This function inserts a link into the active slot. It may be either an internal application link ('module' given and 'view' or 'action' given), or a link to an external web page ('external' given), or a link to a file in the static file directory of the application ('static' given).<br/><br/>When passing a table as &quot;partial&quot; argument, AND if partial loading has been enabled by calling ui.enable_partial_loading(), then ui._partial_load_js is<br/>used to create an onclick event (onsubmit event for action links). The<br/>&quot;partial&quot; setting table is passed to ui._partial_load_js as first argument.<br/>See ui._partial_load_js(...) for further documentation.    </div>
    <div class="autodoc_source">
<pre>function ui.link(args)
  local args = args or {}
  local content = args.content or args.text
  assert(content, &quot;ui.link{...} needs a text.&quot;)
  local function wrapped_content()
    if args.image then
      ui.image(args.image)
    end
    if type(content) == &quot;function&quot; then
      content()
    else
      slot.put(encode.html(content))
    end
  end
  if args.action then
    local form_attr   = table.new(args.form_attr)
    local form_id
    if form_attr.id then
      form_id = form_attr.id
    else
      form_id = ui.create_unique_id()
    end
    local quoted_form_id = encode.json(form_id)
    form_attr.id      = form_id
    local a_attr      = table.new(args.attr)
    a_attr.href       = &quot;#&quot;
    a_attr.onclick    =
      &quot;var f = document.getElementById(&quot; .. quoted_form_id .. &quot;); if (! f.onsubmit || f.onsubmit() != false) { f.submit() }; return false;&quot;
    ui.form{
      external = args.external,
      module   = args.module or request.get_module(),
      action   = args.action,
      id       = args.id,
      params   = args.params,
      routing  = args.routing,
      partial  = args.partial,
      attr     = form_attr,
      content  = function()
        ui.submit{ text = args.text, attr = args.submit_attr }
      end
    }
    ui.script{
      type = &quot;text/javascript&quot;,
      script = (
        &quot;document.getElementById(&quot; ..
        quoted_form_id ..
        &quot;).style.display = 'none'; document.write(&quot; ..
        encode.json(
          slot.use_temporary(
            function()
              ui.tag{
                tag     = &quot;a&quot;,
                attr    = a_attr,
                content = wrapped_content
              }
            end
          )
        ) ..
        &quot;);&quot;
      )
    }
  else
    <span class="autodoc_comment_tail">-- TODO: support content function</span>
    local a_attr = table.new(args.attr)
    a_attr.href = encode.url{
      external  = args.external,
      static    = args.static,
      module    = args.module or request.get_module(),
      view      = args.view,
      id        = args.id,
      params    = args.params,
      anchor    = args.anchor
    }
    if ui.is_partial_loading_enabled() and args.partial then
      a_attr.onclick = ui._partial_load_js(args.partial)
    end
    return ui.tag{ tag  = &quot;a&quot;, attr = a_attr, content = wrapped_content }
  end
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_251').style.display = document.getElementById('autodoc_details_251').style.display ? '' : 'none';">
    ui.list{ ... }
  </div>
  <div id="autodoc_details_251" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>ui.list{
  label   = list_label,  <span class="autodoc_comment_tail">-- optional label for the whole list</span>
  style   = style,       <span class="autodoc_comment_tail">-- &quot;table&quot;, &quot;ulli&quot; or &quot;div&quot;</span>
  prefix  = prefix,      <span class="autodoc_comment_tail">-- prefix for HTML field names</span>
  records = records,     <span class="autodoc_comment_tail">-- array of records to be displayed as rows in the list</span>
  columns = {
    {
      label          = column_label,    <span class="autodoc_comment_tail">-- label for the column</span>
      label_attr     = label_attr,      <span class="autodoc_comment_tail">-- table with HTML attributes for the heading cell or div</span>
      field_attr     = field_attr,      <span class="autodoc_comment_tail">-- table with HTML attributes for the data cell or div</span>
      name           = name,            <span class="autodoc_comment_tail">-- name of the field in each record</span>
      html_name      = html_name,       <span class="autodoc_comment_tail">-- optional html-name for writable fields (defaults to name)</span>
      ui_field_type  = ui_field_type,   <span class="autodoc_comment_tail">-- name of the ui.field.* function to use</span>
      ....,                             <span class="autodoc_comment_tail">-- other options for the given ui.field.* functions</span>
      format         = format,          <span class="autodoc_comment_tail">-- name of the format function to be used (if not using ui_field_type)</span>
      format_options = format_options,  <span class="autodoc_comment_tail">-- options to be passed to the format function</span>
      content        = content          <span class="autodoc_comment_tail">-- function to output field data per record (ignoring name, format, ...)</span>
    },
    { ... },
    ...
  }
}</pre>
    </div>
    <div class="autodoc_comment">This function takes an array of records to be displayed in a list. The whole list may have a label. The style's &quot;table&quot; (for &lt;table&gt;), &quot;ulli&quot; (for &lt;ul&gt;&lt;li&gt;) and &quot;div&quot; (just using &lt;div&gt; tags) are supported. For each column several options must be specified.    </div>
    <div class="autodoc_source">
<pre><span class="autodoc_comment_tail">-- TODO: documentation of the prefix option</span>
<span class="autodoc_comment_tail">-- TODO: check short descriptions of fields in documentation</span>
<span class="autodoc_comment_tail">-- TODO: field_attr is used for the OUTER html tag's attributes, while attr is used for the INNER html tag's attributes (produced by ui.field.*), is that okay?</span>
<span class="autodoc_comment_tail">-- TODO: use field information of record class, if no columns are given</span>
<span class="autodoc_comment_tail">-- TODO: callback to set row attr's for a specific row</span>

function ui.list(args)
  local args = args or {}
  local label     = args.label
  local list_type = args.style or &quot;table&quot;
  local prefix    = args.prefix
  local records   = assert(args.records, &quot;ui.list{...} needs records.&quot;)
  local columns   = assert(args.columns, &quot;ui.list{...} needs column definitions.&quot;)
  local outer_attr = table.new(args.attr)
  local header_existent = false
  for idx, column in ipairs(columns) do
    if column.label then
      header_existent = true
      break
    end
  end
  local slot_state = slot.get_state_table()
  local outer_tag, head_tag, head_tag2, label_tag, body_tag, row_tag
  if list_type == &quot;table&quot; then
    outer_tag = &quot;table&quot;
    head_tag  = &quot;thead&quot;
    head_tag2 = &quot;tr&quot;
    label_tag = &quot;th&quot;
    body_tag  = &quot;tbody&quot;
    row_tag   = &quot;tr&quot;
    field_tag = &quot;td&quot;
  elseif list_type == &quot;ulli&quot; then
    outer_tag = &quot;div&quot;
    head_tag  = &quot;div&quot;
    label_tag = &quot;div&quot;
    body_tag  = &quot;ul&quot;
    row_tag   = &quot;li&quot;
    field_tag = &quot;td&quot;
  elseif list_type == &quot;div&quot; then
    outer_tag = &quot;div&quot;
    head_tag  = &quot;div&quot;
    label_tag = &quot;div&quot;
    body_tag  = &quot;div&quot;
    row_tag   = &quot;div&quot;
    field_tag = &quot;div&quot;
  else
    error(&quot;Unknown list type specified for ui.list{...}.&quot;)
  end
  outer_attr.class = outer_attr.class or &quot;ui_list&quot;
  ui.container{
    auto_args = args,
    content   = function()
      ui.tag{
        tag     = outer_tag,
        attr    = outer_attr,
        content = function()
          if header_existent then
            ui.tag{
              tag     = head_tag,
              attr    = { class = &quot;ui_list_head&quot; },
              content = function()
                local function header_content()
                  for idx, column in ipairs(columns) do
                    if column.ui_field_type ~= &quot;hidden&quot; then
                      local label_attr = table.new(column.label_attr)
                      label_attr.class =
                        label_attr.class or { class = &quot;ui_list_label&quot; }
                      ui.tag{
                        tag     = label_tag,
                        attr    = label_attr,
                        content = column.label or &quot;&quot;
                      }
                    end
                  end
                end
                if head_tag2 then
                  ui.tag{ tag = head_tag2, content = header_content }
                else
                  header_content()
                end
              end
            }
          end
          ui.tag{
            tag     = body_tag,
            attr    = { class = &quot;ui_list_body&quot; },
            content = function()
              for record_idx, record in ipairs(records) do
                local row_class
                if record_idx % 2 == 0 then
                  row_class = &quot;ui_list_row ui_list_even&quot;
                else
                  row_class = &quot;ui_list_row ui_list_odd&quot;
                end
                ui.tag{
                  tag     = row_tag,
                  attr    = { class = row_class },
                  content = function()
                    local old_html_name_prefix, old_form_record
                    if prefix then
                      old_html_name_prefix        = slot_state.html_name_prefix
                      old_form_record             = slot_state.form_record
                      slot_state.html_name_prefix = prefix .. &quot;[&quot; .. record_idx .. &quot;]&quot;
                      slot_state.form_record      = record
                    end
                    local first_column = true
                    for column_idx, column in ipairs(columns) do
                      if column.ui_field_type ~= &quot;hidden&quot; then
                        local field_attr = table.new(column.field_attr)
                        field_attr.class =
                          field_attr.class or { class = &quot;ui_list_field&quot; }
                        local field_content
                        if column.content then
                          field_content = function()
                            return column.content(record)
                          end
                        elseif column.name then
                          if column.ui_field_type then
                            local ui_field_func = ui.field[column.ui_field_type]
                            if not ui_field_func then
                              error('Unknown ui_field_type &quot;' .. column.ui_field_type .. '&quot;.')
                            end
                            local ui_field_options = table.new(column)
                            ui_field_options.record = record
                            ui_field_options.label  = nil
                            if not prefix and ui_field_options.readonly == nil then
                              ui_field_options.readonly = true
                            end
                            field_content = function()
                              return ui.field[column.ui_field_type](ui_field_options)
                            end
                          elseif column.format then
                            local formatter = format[column.format]
                            if not formatter then
                              error('Unknown format &quot;' .. column.format .. '&quot;.')
                            end
                            field_content = formatter(
                              record[column.name], column.format_options
                            )
                          else
                            field_content = function()
                              return ui.autofield{
                                record    = record,
                                name      = column.name,
                                html_name = column.html_name
                              }
                            end
                          end
                        else
                          error(&quot;Each column needs either a 'content' or a 'name'.&quot;)
                        end
                        local extended_field_content
                        if first_column then
                          first_column = false
                          extended_field_content = function()
                            for column_idx, column in ipairs(columns) do
                              if column.ui_field_type == &quot;hidden&quot; then
                                local ui_field_options = table.new(column)
                                ui_field_options.record = record
                                ui_field_options.label  = nil
                                if not prefix and ui_field_options.readonly == nil then
                                  ui_field_options.readonly = true
                                end
                                ui.field.hidden(ui_field_options)
                              end
                            end
                            field_content()
                          end
                        else
                          extended_field_content = field_content
                        end
                        ui.tag{
                          tag     = field_tag,
                          attr    = field_attr,
                          content = extended_field_content
                        }
                      end
                    end
                    if prefix then
                      slot_state.html_name_prefix = old_html_name_prefix
                      slot_state.form_record      = old_form_record
                    end
                  end
                }
              end
            end
          }
        end
      }
    end
  }
  if prefix then
    <span class="autodoc_comment_tail">-- ui.field.hidden is used instead of ui.hidden_field to suppress output in case of read-only mode.</span>
    ui.field.hidden{
      html_name = prefix .. &quot;[len]&quot;,
      value     = #records
    }
  end
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_252').style.display = document.getElementById('autodoc_details_252').style.display ? '' : 'none';">
    ui.multiselect{ ... }
  </div>
  <div id="autodoc_details_252" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>ui.multiselect{
  name               = name,                <span class="autodoc_comment_tail">-- HTML name ('html_name' is NOT a valid argument for this function)</span>
  container_attr     = container_attr,      <span class="autodoc_comment_tail">-- extra HTML attributes for the container (div) enclosing field and label</span>
  container2_attr    = container2_attr,     <span class="autodoc_comment_tail">-- extra HTML attributes for the container (div) of the real element (in checkbox case only)</span>
  attr               = attr,                <span class="autodoc_comment_tail">-- extra HTML attributes for the field</span>
  label              = label,               <span class="autodoc_comment_tail">-- text to be used as label for the input field</span>
  label_attr         = label_attr,          <span class="autodoc_comment_tail">-- extra HTML attributes for the label</span>
  readonly           = readonly_flag        <span class="autodoc_comment_tail">-- set to true, to force read-only mode</span>
  foreign_records    = foreign_records,     <span class="autodoc_comment_tail">-- list of records to be chosen from, or function returning such a list</span>
  foreign_id         = foreign_id,          <span class="autodoc_comment_tail">-- name of id field in foreign records</span>
  foreign_name       = foreign_name,        <span class="autodoc_comment_tail">-- name of field to be used as name in foreign records</span>
  selected_ids       = selected_ids,        <span class="autodoc_comment_tail">-- list of ids of currently selected foreign records</span>
  connecting_records = connecting_records,  <span class="autodoc_comment_tail">-- list of connection entries, determining which foreign records are currently selected</span>
  own_id             = own_id,              <span class="autodoc_comment_tail">-- TODO documentation needed</span>
  own_reference      = own_reference,       <span class="autodoc_comment_tail">-- name of foreign key field in connecting records, which references the main record</span>
  foreign_reference  = foreign_reference,   <span class="autodoc_comment_tail">-- name of foreign key field in connecting records, which references foreign records</span>
  format_options     = format_options       <span class="autodoc_comment_tail">-- format options for format.string</span>
}</pre>
    </div>
    <div class="autodoc_comment">This function inserts a select field with possibility of multiple selections in the active slot. This function does not reside within ui.field.*, because multiple selections are not stored within a field of a record, but within a different SQL table. Note that 'html_name' is NOT a valid argument to this function. For description of the generic field helper arguments, see help for ui.autofield{...}.    </div>
    <div class="autodoc_source">
<pre>function ui.multiselect(args)
  local style = args.style or &quot;checkbox&quot;
  local extra_args = { fetch_record = true }
  if not args.readonly and args.style == &quot;checkbox&quot; then
    extra_args.disable_label_for_id = true
  end
  ui.form_element(args, extra_args, function(args)
    local foreign_records = args.foreign_records
    if type(foreign_records) == &quot;function&quot; then
      foreign_records = foreign_records(args.record)
    end
    local connecting_records = args.connecting_records
    if type(connecting_records) == &quot;function&quot; then
      connecting_records = connecting_records(args.record)
    end
    local select_hash = {}
    if args.selected_ids then
      for idx, selected_id in ipairs(args.selected_ids) do
        select_hash[selected_id] = true
      end
    elseif args.own_reference then
      for idx, connecting_record in ipairs(args.connecting_records) do
        if connecting_record[args.own_reference] == args.record[args.own_id] then
          select_hash[connecting_record[args.foreign_reference]] = true
        end
      end
    else
      for idx, connecting_record in ipairs(args.connecting_records) do
        select_hash[connecting_record[args.foreign_reference]] = true
      end
    end
    local attr = table.new(args.attr)
    if not attr.class then
      attr.class = &quot;ui_multi_selection&quot;
    end
    if args.readonly then
      ui.tag{
        tag     = &quot;ul&quot;,
        attr    = attr,
        content = function()
          for idx, record in ipairs(foreign_records) do
            if select_hash[record[args.foreign_id]] then
              ui.tag{
                tag     = &quot;li&quot;,
                content = format.string(
                  record[args.foreign_name],
                  args.format_options
                )
              }
            end
          end
        end
      }
    elseif style == &quot;select&quot; then
      attr.name     = args.name
      attr.multiple = &quot;multiple&quot;
      ui.tag{
        tag     = &quot;select&quot;,
        attr    = attr,
        content = function()
          if args.nil_as then
            ui.tag{
              tag     = &quot;option&quot;,
              attr    = { value = &quot;&quot; },
              content = format.string(
                args.nil_as,
                args.format_options
              )
            }
          end
          for idx, record in ipairs(foreign_records) do
            local key = record[args.foreign_id]
            local selected = select_hash[key]
            ui.tag{
              tag     = &quot;option&quot;,
              attr    = {
                value    = key,
                selected = (selected and &quot;selected&quot; or nil)
              },
              content = format.string(
                record[args.foreign_name],
                args.format_options
              )
            }
          end
        end
      }
    elseif style == &quot;checkbox&quot; then
      attr.type = &quot;checkbox&quot;
      attr.name = args.name
      for idx, record in ipairs(foreign_records) do
        local key = record[args.foreign_id]
        local selected = select_hash[key]
        attr.id   = ui.create_unique_id()
        attr.value = key
        attr.checked = selected and &quot;checked&quot; or nil
        ui.container{
          label = format.string(
            record[args.foreign_name],
            args.format_options
          ),
          attr          = args.container2_attr or { class = &quot;ui_checkbox_div&quot; },
          label_for     = attr.id,
          label_attr    = args.label_attr or { class = &quot;ui_checkbox_label&quot; },
          content_first = true,
          content       = function()
            ui.tag{ tag  = &quot;input&quot;, attr = attr }
          end
        }
      end
    else
      error(&quot;'style' attribute for ui.multiselect{...} must be set to \&quot;select\&quot;, \&quot;checkbox\&quot; or nil.&quot;)
    end
  end)
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_253').style.display = document.getElementById('autodoc_details_253').style.display ? '' : 'none';">
    ui.paginate{ ... }
  </div>
  <div id="autodoc_details_253" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>ui.paginate{
  selector       = selector,       <span class="autodoc_comment_tail">-- a selector for items from the database (will be modified)</span>
  anchor         = anchor,         <span class="autodoc_comment_tail">-- optional name of anchor in document to jump to</span>
  per_page       = per_page,       <span class="autodoc_comment_tail">-- items per page, defaults to 10</span>
  container_attr = container_attr  <span class="autodoc_comment_tail">-- html attr for the container element</span>
  name           = name,           <span class="autodoc_comment_tail">-- name of the CGI get variable, defaults to &quot;page&quot;</span>
  page           = page,           <span class="autodoc_comment_tail">-- directly specify a page, and ignore 'name' parameter</span>
  content        = function()
    ...                            <span class="autodoc_comment_tail">-- code block which should be encapsulated with page selection links</span>
  end
}</pre>
    </div>
    <div class="autodoc_comment">This function preceeds and appends the output of the given 'content' function with page selection links. The passed selector will be modified to show only a limited amount ('per_page') of items. The currently displayed page will be determined directly by cgi.params, and not via the param.get(...) function, in order to pass page selections automatically to sub-views.    </div>
    <div class="autodoc_source">
<pre>function ui.paginate(args)
  local selector = args.selector
  local per_page = args.per_page or 10
  local name     = args.name or 'page'
  local content  = args.content
  local count_selector = selector:get_db_conn():new_selector()
  count_selector:add_field('count(1)')
  count_selector:add_from(selector)
  count_selector:single_object_mode()
  local count = count_selector:exec().count
  local page_count = 1
  if count &gt; 0 then
    page_count = math.floor((count - 1) / per_page) + 1
  end
  local current_page = atom.integer:load(cgi.params[name]) or 1
  if current_page &gt; page_count then
    current_page = page_count
  end
  selector:limit(per_page)
  selector:offset((current_page - 1) * per_page)
  local id     = request.get_id_string()
  local params = request.get_param_strings()
  local function pagination_elements()
    if page_count &gt; 1 then
      for page = 1, page_count do
        if page &gt; 1 then
          slot.put(&quot; &quot;)
        end
        params[name] = page
        local attr = {}
        if current_page == page then
          attr.class = &quot;active&quot;
        end
        local partial
        if ui.is_partial_loading_enabled() then
          partial = {
            params = {
              [name] = tostring(page)
            }
          }
        end
        ui.link{
          attr   = attr,
          module = request.get_module(),
          view   = request.get_view(),
          id     = id,
          params = params,
          anchor = args.anchor,
          text   = tostring(page),
          partial = partial
        }
      end
    end
  end
  ui.container{
    attr = args.container_attr or { class = 'ui_paginate' },
    content = function()
      ui.container{
        attr = { class = 'ui_paginate_head ui_paginate_select' },
        content = pagination_elements
      }
      ui.container{
        attr = { class = 'ui_paginate_content' },
        content = content
      }
      ui.container{
        attr = { class = 'ui_paginate_foot ui_paginate_select' },
        content = pagination_elements
      }
    end
  }
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_254').style.display = document.getElementById('autodoc_details_254').style.display ? '' : 'none';">
    ui.partial{ ... }
  </div>
  <div id="autodoc_details_254" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>ui.partial{
  module  = module,     <span class="autodoc_comment_tail">-- module to be used to reload inner contents</span>
  view    = view,       <span class="autodoc_comment_tail">-- view   to be used to reload inner contents</span>
  id      = id,         <span class="autodoc_comment_tail">-- id     to be used to reload inner contents</span>
  params  = params,     <span class="autodoc_comment_tail">-- params to be used to reload inner contents</span>
  target  = target,     <span class="autodoc_comment_tail">-- id of HTML element containing contents to be replaced</span>
  content = function()
    ...
  end
}</pre>
    </div>
    <div class="autodoc_comment">Calling this function declares that the inner contents can be requested<br/>directly via the given module, view, id and params. The parameter &quot;target&quot;<br/>specifies the id of the HTML element, which should be replaced when<br/>reloading partially.<br/><br/>The function has an effect on inner calls of ui.link{..., partial = {...}}<br/>and ui.form{..., partial = {...}}.    </div>
    <div class="autodoc_source">
<pre>function ui.partial(args)
  local old_state = ui._partial_state
  ui._partial_state = table.new(args)
  ui._partial_state.param_name_hash = {}
  if args.param_names then
    ui.add_partial_param_names(args.param_names)
  end
  args.content()
  ui._partial_state = old_state
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_255').style.display = document.getElementById('autodoc_details_255').style.display ? '' : 'none';">
    ui.script{ ... }
  </div>
  <div id="autodoc_details_255" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>ui.script{
  noscript_attr = noscript_attr,  <span class="autodoc_comment_tail">-- HTML attributes for noscript tag</span>
  noscript      = noscript,       <span class="autodoc_comment_tail">-- string or function for noscript content</span>
  attr          = attr,           <span class="autodoc_comment_tail">-- extra HTML attributes for script tag</span>
  type          = type,           <span class="autodoc_comment_tail">-- type of script, defaults to &quot;text/javascript&quot;</span>
  script        = script,         <span class="autodoc_comment_tail">-- string or function for script content</span>
}</pre>
    </div>
    <div class="autodoc_comment">This function is used to insert a script into the active slot.<br/><br/>WARNING: If the script contains two closing square brackets directly followed by a greater-than sign, it will be rejected to avoid ambiguity related to HTML vs. XML parsing. Additional space characters can be added within the program code to avoid occurrence of the character sequence. The function encode.json{...} encodes all string literals in a way that the sequence is not contained.    </div>
    <div class="autodoc_source">
<pre>function ui.script(args)
  local args = args or {}
  local noscript_attr = args.noscript_attr
  local noscript = args.noscript
  local attr = table.new(args.attr)
  attr.type = attr.type or args.type or &quot;text/javascript&quot;
  local script = args.script
  if args.external then
    attr.src = encode.url{ external = args.external }
  elseif args.static then
    attr.src = encode.url{ static = args.static }
  end
  if noscript then
    ui.tag{ tag = &quot;noscript&quot;, attr = attr, content = noscript }
  end
  if attr.src then
    ui.tag{ tag = &quot;script&quot;, attr = attr, content = &quot;&quot; }
  elseif script then
    local script_string
    if type(script) == &quot;function&quot; then
      script_string = slot.use_temporary(script)
    else
      script_string = script
    end
    if string.find(script_string, &quot;]]&gt;&quot;) then
      error('Script contains character sequence &quot;]]&gt;&quot; and is thus rejected to avoid ambiguity. If this sequence occurs as part of program code, please add additional space characters. If this sequence occurs inside a string literal, please encode one of this characters using the \\uNNNN unicode escape sequence.')
    end
    ui.tag{
      tag  = &quot;script&quot;,
      attr = attr,
      content = function()
        slot.put(&quot;/* &lt;![CDATA[ */&quot;)
        slot.put(script_string)
        slot.put(&quot;/* ]]&gt; */&quot;)
      end
    }
  end
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_256').style.display = document.getElementById('autodoc_details_256').style.display ? '' : 'none';">
    ui.submit{ name = name, value = value, text = value }
  </div>
  <div id="autodoc_details_256" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>ui.submit{
  name  = name,   <span class="autodoc_comment_tail">-- optional HTML name</span>
  value = value,  <span class="autodoc_comment_tail">-- HTML value</span>
  text  = value   <span class="autodoc_comment_tail">-- text on button</span>
}</pre>
    </div>
    <div class="autodoc_comment">This function places a HTML form submit button in the active slot. Currently the text displayed on the button and the value attribute are the same, so specifying both a 'value' and a 'text' makes no sense.    </div>
    <div class="autodoc_source">
<pre>function ui.submit(args)
  if slot.get_state_table().form_readonly == false then
    local args = args or {}
    local attr = table.new(attr)
    attr.type  = &quot;submit&quot;
    attr.name  = args.name
    attr.value = args.value or args.text
    return ui.tag{ tag  = &quot;input&quot;, attr = attr }
  end
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_257').style.display = document.getElementById('autodoc_details_257').style.display ? '' : 'none';">
    ui.tag{ tag = tag, attr = attr, content = content }
  </div>
  <div id="autodoc_details_257" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>ui.tag{
  tag     = tag,     <span class="autodoc_comment_tail">-- HTML tag, e.g. &quot;a&quot; for &lt;a&gt;...&lt;/a&gt;</span>
  attr    = attr,    <span class="autodoc_comment_tail">-- table of HTML attributes, e.g. { class = &quot;hide&quot; }</span>
  content = content  <span class="autodoc_comment_tail">-- string to be HTML encoded, or function to be executed</span>
}</pre>
    </div>
    <div class="autodoc_comment">This function writes a HTML tag into the active slot.<br/><br/>NOTE: ACCELERATED FUNCTION<br/>Do not change unless also you also update webmcp_accelerator.c    </div>
    <div class="autodoc_source">
<pre>function ui.tag(args)
  local tag, attr, content
  tag     = args.tag
  attr    = args.attr or {}
  content = args.content
  if type(attr.class) == &quot;table&quot; then
    attr = table.new(attr)
    attr.class = table.concat(attr.class, &quot; &quot;)
  end
  if not tag and next(attr) then
    tag = &quot;span&quot;
  end
  if tag then
    slot.put('&lt;', tag)
    for key, value in pairs(attr) do
      slot.put(' ', key, '=&quot;', encode.html(value), '&quot;')
    end
  end
  if content then
    if tag then
      slot.put('&gt;')
    end
    if type(content) == &quot;function&quot; then
      content()
    else
      slot.put(encode.html(content))
    end
    if tag then
      slot.put('&lt;/', tag, '&gt;')
    end
  else
    if tag then
      slot.put(' /&gt;')
    end
  end
end</pre>
    </div>
  </div>
</li>
<li class="autodoc_entry">
  <div class="short_synopsis" onclick="document.getElementById('autodoc_details_258').style.display = document.getElementById('autodoc_details_258').style.display ? '' : 'none';">
    url, auth.openid._normalize_url( url )
  </div>
  <div id="autodoc_details_258" class="autodoc_details" style="display: none;">
    <div class="autodoc_synopsis">
<pre>url,                         <span class="autodoc_comment_tail">-- normalized URL or nil</span>
auth.openid._normalize_url(
  url                        <span class="autodoc_comment_tail">-- unnormalized URL</span>
)</pre>
    </div>
    <div class="autodoc_comment">This function normalizes an URL, and returns nil if the given URL is not a<br/>valid absolute URL. For security reasons only a restricted set of URLs is<br/>valid.    </div>
    <div class="autodoc_source">
<pre>function auth.openid._normalize_url(url)
  local url = string.match(url, &quot;^(.-)??$&quot;)  <span class="autodoc_comment_tail">-- remove &quot;?&quot; at end</span>
  local proto, host, path = string.match(
    url,
    &quot;([A-Za-z]+)://([0-9A-Za-z.:_-]+)/?([0-9A-Za-z%%/._~-]*)$&quot;
  )
  if not proto then
    return nil
  end
  proto = string.lower(proto)
  host  = string.lower(host)
  local port = string.match(host, &quot;:(.*)&quot;)
  if port then
    if string.find(port, &quot;^[0-9]+$&quot;) then
      port = tonumber(port)
      host = string.match(host, &quot;^(.-):&quot;)
      if port &lt; 1 or port &gt; 65535 then
        return nil
      end
    else
      return nil
    end
  end
  if proto == &quot;http&quot; then
    if port == 80 then port = nil end
  elseif proto == &quot;https&quot; then
    if port == 443 then port = nil end
  else
    return nil
  end
  if
    string.find(host, &quot;^%.&quot;) or
    string.find(host, &quot;%.$&quot;) or
    string.find(host, &quot;%.%.&quot;)
  then
    return nil
  end
  for part in string.gmatch(host, &quot;[^.]+&quot;) do
    if not string.find(part, &quot;[A-Za-z]&quot;) then
      return nil
    end
  end
  local path_parts = {}
  for part in string.gmatch(path, &quot;[^/]+&quot;) do
    if part == &quot;.&quot; then
      <span class="autodoc_comment_tail">-- do nothing</span>
    elseif part == &quot;..&quot; then
      path_parts[#path_parts] = nil
    else
      local fail = false
      local part = string.gsub(
        part,
        &quot;%%([0-9A-Fa-f]?[0-9A-Fa-f]?)&quot;,
        function (hex)
          if #hex ~= 2 then
            fail = true
            return
          end
          local char = string.char(tonumber(&quot;0x&quot; .. hex))
          if string.find(char, &quot;[0-9A-Za-z._~-]&quot;) then
            return char
          else
            return &quot;%&quot; .. string.upper(hex)
          end
        end
      )
      if fail then
        return nil
      end
      path_parts[#path_parts+1] = part
    end
  end
  if string.find(path, &quot;/$&quot;) then
    path_parts[#path_parts+1] = &quot;&quot;
  end
  path = table.concat(path_parts, &quot;/&quot;)
  if port then
    host = host .. &quot;:&quot; .. tostring(port)
  end
  return proto .. &quot;://&quot; .. host .. &quot;/&quot; .. path
end</pre>
    </div>
  </div>
</li>
    </ul>
    <hr style="margin-top: 3em;"/>
    <p style="text-align: right; font-style: italic;">
      Copyright (c) 2009-2010 Public Software Group e. V., Berlin
    </p>
  </body>
</html>
